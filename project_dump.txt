### FILE: ./bot.py
#!/usr/bin/env python3
# bot.py — Version 1.0.1

import os
import asyncio
from dotenv import load_dotenv
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from utils.backtester import Backtester
from utils.logger import logger

__version__ = "1.0.1"

def load_config():
    load_dotenv()
    return {
        "api_key": os.getenv("BINANCE_API_KEY"),
        "api_secret": os.getenv("BINANCE_API_SECRET"),
        "testnet": os.getenv("USE_TESTNET", "True").lower() == "true",
        "symbol": os.getenv("SYMBOL", "BTCUSDC"),
        "backtest_start": os.getenv("BACKTEST_START", "2025-01-01T00:00"),
        "backtest_end": os.getenv("BACKTEST_END", "2025-06-01T00:00"),
        "granularity": os.getenv("GRANULARITY", "1h"),
        "initial_balance": float(os.getenv("INITIAL_BALANCE", "20.0")),
        "trade_quantity": float(os.getenv("TRADE_QUANTITY", "0.001")),
        "paper_trading": os.getenv("PAPER_TRADING", "True").lower() == "true",
        "atr_period": int(os.getenv("ATR_PERIOD", "14")),
        "sl_multiplier": float(os.getenv("SL_MULTIPLIER", "1.5")),
        "tp_multiplier": float(os.getenv("TP_MULTIPLIER", "3.0")),
        "martingale_factor": float(os.getenv("MARTINGALE_FACTOR", "1.0")),
    }

async def main():
    cfg = load_config()
    logger.info(f"🚀 Starting Grok-FuturesBot v{__version__}")

    # 1) Backtest
    logger.info("🔍 Running backtest…")
    bt = Backtester(
        symbol=cfg["symbol"],
        start=cfg["backtest_start"],
        end=cfg["backtest_end"],
        granularity=cfg["granularity"],
        initial_balance=cfg["initial_balance"],
    )
    await bt.run()

    # 2) Live-/Paper-Trading Beispiel
    logger.info("💡 Starting live/paper trading example…")
    client = await BinanceClient.create(
        api_key=cfg["api_key"],
        api_secret=cfg["api_secret"],
        testnet=cfg["testnet"],
    )
    executor = TradeExecutor(client)
    result = await executor.execute_trade(
        symbol=cfg["symbol"],
        side="BUY",
        quantity=cfg["trade_quantity"],
        atr_period=cfg["atr_period"],
        sl_multiplier=cfg["sl_multiplier"],
        tp_multiplier=cfg["tp_multiplier"],
        martingale_factor=cfg["martingale_factor"],
        paper=cfg["paper_trading"],
    )
    logger.info(
        f"🎯 Trade result (paper={cfg['paper_trading']}): Entry={result['entry_price']}, SL={result['sl_price']}, TP={result['tp_price']}"
    )

if __name__ == "__main__":
    asyncio.run(main())



### FILE: ./core/client.py
# core/client.py — Version 1.0.1

import asyncio
import ccxt.async_support as ccxt
from binance import AsyncClient
from utils.logger import logger


class BinanceClient:
    def __init__(self, client: AsyncClient):
        self.client = client

    @classmethod
    async def create(cls, api_key: str, api_secret: str, testnet: bool = False):
        logger.info(f"🔌 Verbinde mit Binance (testnet={testnet})...")
        client = await AsyncClient.create(
            api_key=api_key,
            api_secret=api_secret,
            testnet=testnet
        )
        return cls(client)

    async def get_futures_price(self, symbol: str) -> float:
        ticker = await self.client.futures_symbol_ticker(symbol=symbol)
        return float(ticker["price"])

    async def fetch_ohlcv(self, symbol: str, timeframe: str, since: int = None, limit: int = None, until: int = None):
        exchange = ccxt.binance({
            'enableRateLimit': True,
            'options': {
                'defaultType': 'future'
            }
        })
        if since and until:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since)
            ohlcv = [c for c in ohlcv if c[0] <= until]
        else:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
        await exchange.close()
        return ohlcv

    async def close(self):
        await self.client.close_connection()



### FILE: ./core/strategy_engine.py
from strategies.RSI_ema import ema_rsi_signal
from strategies.breakouts import breakout_signal
from strategies.reversal import reversal_signal
from strategies.range_trading import range_trading_signal
from utils.market_classifier import classify_market
from utils.volatility import calculate_volatility

class StrategyEngine:
    def __init__(self):
        pass

    def choose_strategy(self, ohlcv):
        market_state = classify_market(ohlcv)
        volatility = calculate_volatility(ohlcv)
        
        if market_state == "trend_bullish":
            return breakout_signal, market_state
        elif market_state == "trend_bearish":
            return reversal_signal, market_state
        elif market_state == "sideways":
            return range_trading_signal, market_state
        elif market_state == "volatile":
            return breakout_signal, market_state
        else:
            return None, market_state

    def get_signal(self, ohlcv):
        strategy, market_state = self.choose_strategy(ohlcv)
        if strategy:
            return strategy(ohlcv), market_state
        return None, market_state



### FILE: ./core/trade_executor.py
from utils.logger import logger
from strategies.indicators import calculate_atr
from binance.enums import *

SIDE_Buy = "Buy"

class TradeExecutor:
    def __init__(self, client, base_currency: str = "USDC"):
        self.client = client
        self.base_currency = base_currency

    async def execute_trade(
        self,
        symbol: str,
        side: str,
        quantity: float,
        sl: float = None,
        tp: float = None,
        atr_period: int = 14,
        sl_multiplier: float = 1.5,
        tp_multiplier: float = 3.0,
        martingale_factor: float = 1.0,
        paper: bool = True
    ):
        qty = quantity * martingale_factor
        logger.info(f"Placing {side} order for {symbol} qty={qty:.6f} (martingale={martingale_factor})")

        # Preis ermitteln
        if paper:
            price = await self.client.get_futures_price(symbol)
            logger.info(f"(Paper) Order simulated at {price}")
        else:
            order = await self.client.client.futures_create_order(
                symbol=symbol,
                side=side,
                type=FUTURE_ORDER_TYPE_MARKET,
                quantity=qty
            )
            price = float(order["avgPrice"])
            logger.info(f"Order executed at price={price}")

        # SL/TP berechnen wenn nicht manuell übergeben
        if sl is None or tp is None:
            ohlcv = await self.client.fetch_ohlcv(symbol, timeframe='1h', limit=atr_period + 1)
            atr = calculate_atr(ohlcv, period=atr_period)[-1]
            sl, tp = self._compute_sl_tp(price, atr, side, sl_multiplier, tp_multiplier)

        return {
            "entry_price": price,
            "sl_price": sl,
            "tp_price": tp,
            "qty": qty
        }

    def _compute_sl_tp(self, entry: float, atr: float, side: str,
                       sl_mult: float, tp_mult: float):
        if side == SIDE_BUY:
            sl = entry - atr * sl_mult
            tp = entry + atr * tp_mult
        else:
            sl = entry + atr * sl_mult
            tp = entry - atr * tp_mult
        return sl, tp



### FILE: ./dashboard/app.py
from flask import Flask, render_template, send_file
import os
import sys
import pandas as pd
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.equity_plot import plot_equity_curve
from utils.trade_logger import log_trade 


app = Flask(__name__)

@app.route("/")
def index():
    # Equity-Kurve aktualisieren
    plot_equity_curve("paper_trades.csv", "dashboard/static/equity_curve.png")

    # Daten aus CSV laden
    df = pd.read_csv("paper_trades.csv")
    df_closed = df[df["pnl"].notna()]
    balance = 20.0 + df_closed["pnl"].sum()
    winrate = (df_closed["pnl"] > 0).mean() * 100 if not df_closed.empty else 0

    return render_template("index.html", 
        balance=round(balance, 2),
        total_trades=len(df),
        winrate=round(winrate, 1),
        trades=df.tail(10).to_dict(orient="records")
    )

@app.route("/chart")
def chart():
    return send_file("static/equity_curve.png", mimetype='image/png')

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)



### FILE: ./multi_backtest.py
import asyncio
from utils.backtester import Backtester

symbol_list = ["BTCUSDC", "ETHUSDC", "BNBUSDC", "SOLUSDC"]
start = "2025-01-01T00:00"
end = "2025-06-01T00:00"
granularity = "1h"
initial_balance = 20.0

async def run_backtests():
    tasks = []
    for symbol in symbol_list:
        bt = Backtester(
            symbol=symbol,
            start=start,
            end=end,
            granularity=granularity,
            initial_balance=initial_balance
        )
        tasks.append(bt.run())
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(run_backtests())



### FILE: ./paper_loop.py
import os
import sys
import asyncio
from dotenv import load_dotenv
from datetime import datetime
import aiohttp

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.engine import StrategyEngine
from strategies.indicators import calculate_atr
from utils.logger import logger
from utils.trade_logger import log_trade
from utils.trade_tracker import update_trade_pnls
from utils.risk_manager import RiskManager
from utils.cooldown_manager import CooldownManager
from utils.signal_filter import SignalFilter
from utils.drawdown_guard import DrawdownGuard
from utils.strategy_watchdog import StrategyWatchdog

# Einstellungen
load_dotenv()
PAPER = True
INTERVAL = 30
START_BALANCE = 20.0
SYMBOLS = []

# Bot-Komponenten
engine = StrategyEngine()
risk_manager = RiskManager(initial_balance=START_BALANCE, max_risk_per_trade=0.02)
cooldown = CooldownManager(cooldown_minutes=30)
signal_filter = SignalFilter()
drawdown_guard = DrawdownGuard(start_balance=START_BALANCE, max_loss_pct=5.0)
watchdog = StrategyWatchdog()

# Abruf der Top 100 USDC-Futures-Paare nach Volumen
async def get_top_usdc_symbols_by_volume(limit=100):
    url = "https://fapi.binance.com/fapi/v1/ticker/24hr"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
            filtered = [
                d for d in data if d["symbol"].endswith("USDC") and float(d["quoteVolume"]) > 100000
            ]
            sorted_pairs = sorted(filtered, key=lambda x: float(x["quoteVolume"]), reverse=True)
            return [item["symbol"] for item in sorted_pairs[:limit]]

# Hauptloop
async def trade_loop():
    global SYMBOLS
    client = await BinanceClient.create(
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
        testnet=os.getenv("USE_TESTNET", "True").lower() == "true"
    )
    executor = TradeExecutor(client)

    # Handelsuniversum bestimmen
    SYMBOLS = await get_top_usdc_symbols_by_volume(limit=100)

    logger.info(f"📊 Überwachte Paare: {', '.join(SYMBOLS[:10])} ...")

    try:
        while True:
            if drawdown_guard.loss_today_exceeded():
                logger.warning("🛑 Tagesverlustgrenze erreicht – Trading pausiert.")
                await asyncio.sleep(INTERVAL)
                continue

            for symbol in SYMBOLS:
                try:
                    ohlcv = await client.fetch_ohlcv(symbol, "1h", limit=50)
                    closes = [row[4] for row in ohlcv]
                    price = closes[-1]
                    atr = calculate_atr(ohlcv, 14)

                    strategy = engine.select_strategy(ohlcv)
                    signal = strategy.generate_signal(ohlcv)

                    if not signal:
                        continue

                    if cooldown.is_in_cooldown(symbol):
                        logger.info(f"[COOLDOWN] {symbol}: aktiv – übersprungen.")
                        continue

                    if not signal_filter.passes_filters(ohlcv):
                        logger.info(f"[FILTER] {symbol}: Markt ungeeignet.")
                        continue

                    sl, tp = strategy.sl_tp(price, atr)
                    qty = risk_manager.calculate_position_size(entry_price=price, stop_loss=sl)

                    if qty <= 0:
                        logger.warning(f"[RISK] {symbol}: Ordergröße zu klein – übersprungen.")
                        continue

                    logger.info(f"[TRADE] {symbol}: {signal} @ {price:.2f} SL={sl:.2f} TP={tp:.2f} QTY={qty:.4f}")

                    result = await executor.execute_trade(
                        symbol=symbol,
                        side=signal,
                        quantity=qty,
                        sl=sl,
                        tp=tp,
                        paper=PAPER
                    )

                    log_trade(
                        symbol=symbol,
                        side=signal,
                        entry_price=result["entry_price"],
                        sl=sl,
                        tp=tp,
                        qty=qty,
                        strategy=strategy.__class__.__name__
                    )

                    cooldown.update_cooldown(symbol)

                except Exception as e:
                    logger.error(f"[{symbol}] Fehler im Loop: {e}")

            try:
                current_prices = {symbol: await client.get_futures_price(symbol) for symbol in SYMBOLS}
                update_trade_pnls(current_prices=current_prices)
            except Exception as e:
                logger.warning(f"[PnL] Preisabruf fehlgeschlagen: {e}")

            logger.info(f"⏳ Nächster Zyklus in {INTERVAL} Sekunden...\n")
            await asyncio.sleep(INTERVAL)

    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(trade_loop())



### FILE: ./strategies/breakout.py
# strategies/breakout.py

class BreakoutStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "trend"

    def generate_signal(self, ohlcv):
        highs = [c[2] for c in ohlcv[-20:]]
        lows = [c[3] for c in ohlcv[-20:]]
        close = ohlcv[-1][4]
        if close > max(highs[:-1]):
            return "BUY"
        elif close < min(lows[:-1]):
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.0 * atr
        tp = price + 2.5 * atr
        return sl, tp



### FILE: ./strategies/engine.py
# strategies/engine.py

from strategies.rsi_ema import RSIEMAStrategy
from strategies.breakout import BreakoutStrategy

class StrategyEngine:
    def __init__(self):
        self.strategies = [
            RSIEMAStrategy(),
            BreakoutStrategy()
        ]

    def evaluate_market(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        change = abs(closes[-1] - closes[-20]) / closes[-20]
        if change > 0.02:
            return "trend"
        return "sideways"

    def select_strategy(self, ohlcv):
        market = self.evaluate_market(ohlcv)
        for strategy in self.strategies:
            if strategy.suits(market):
                return strategy
        return self.strategies[0]



### FILE: ./strategies/futures_ema_rsi.py
# strategies/futures_ema_rsi.py

"""
EMA & RSI-basierte Futures-Strategie mit ATR-SL/TP
"""
import numpy as np
import pandas as pd
from utils.logger import logger
from utils.indicators import EMA, RSI, ATR

class EMARSI_Strategy:
def **init**(self, client, symbols, interval, leverage, risk\_per\_trade):
self.client = client
self.symbols = symbols
self.interval = interval
self.leverage = leverage
self.risk_per_trade = risk_per_trade

```
async def check_signal(self, symbol):
    data = await self.client.fetch_ohlcv(symbol, self.interval)
    df = pd.DataFrame(data, columns=['timestamp','open','high','low','close','volume'])

    ema_fast = calculate_ema(df['close'], period=10)
    ema_slow = calculate_ema(df['close'], period=20)
    rsi = calculate_rsi(df['close'], period=14)

    if ema_fast.iloc[-1] > ema_slow.iloc[-1] and rsi.iloc[-1] < 30:
        logger.info(f"Long signal für {symbol}")
        return 'LONG'
    if ema_fast.iloc[-1] < ema_slow.iloc[-1] and rsi.iloc[-1] > 70:
        logger.info(f"Short signal für {symbol}")
        return 'SHORT'
    return None

async def execute_trade(self, symbol, signal):
    # Positionsgröße berechnen
    balance = await self.client.fetch_balance()
    available = balance['total']['USDC']
    amount = (available * self.risk_per_trade) / price  # Preis muss aus DataFrame
    side = 'buy' if signal == 'LONG' else 'sell'
    order = await self.client.create_order(symbol, side, amount)
    if order:
        logger.info(f"Order ausgeführt: {order}")
```



### FILE: ./strategies/indicators.py
# strategies/indicators.py — Version 1.0.1

import pandas as pd

def calculate_ema(series, period=14):
    return pd.Series(series).ewm(span=period, adjust=False).mean().tolist()

def calculate_rsi(series, period=14):
    df = pd.Series(series)
    delta = df.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi.fillna(0).tolist()

def calculate_atr(ohlcv, period=14):
    df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
    df["h-l"] = df["high"] - df["low"]
    df["h-pc"] = abs(df["high"] - df["close"].shift(1))
    df["l-pc"] = abs(df["low"] - df["close"].shift(1))
    tr = df[["h-l", "h-pc", "l-pc"]].max(axis=1)
    atr = tr.rolling(window=period).mean()
    return atr.fillna(0).tolist()

def calculate_atr(ohlcv, period=14):
    return calculate_atr(ohlcv, period)



### FILE: ./strategies/rsi_ema.py
# strategies/rsi_ema.py

from strategies.indicators import calculate_ema, calculate_rsi

class RSIEMAStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        price = closes[-1]
        ema = calculate_ema(closes, 20)[-1]
        rsi = calculate_rsi(closes, 14)[-1]

        if price > ema and rsi < 45:
            return "BUY"
        elif price < ema and rsi > 55:
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.5 * atr
        tp = price + 3.0 * atr
        return sl, tp



### FILE: ./utils/backtester.py
# utils/backtester.py — Version 1.0.2

import os
import asyncio
import csv
import math
from datetime import datetime
from statistics import mean, pstdev
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.indicators import calculate_ema, calculate_rsi, ATR
from utils.logger import logger
from dotenv import load_dotenv


__version__ = "1.0.2"

class Backtester:
    def __init__(self, symbol: str, start: str, end: str,
                 granularity: str = '1h', initial_balance: float = 20.0):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.granularity = granularity
        self.initial_balance = initial_balance
        self.client = None
        self.executor = None
        self.reset()

    def reset(self):
        self.balance = self.initial_balance
        self.pos = None
        self.trades = []
        self.equity_curve = [self.initial_balance]

    async def run(self):
        # Lade API-Konfig aus .env
        load_dotenv()
        api_key = os.getenv("BINANCE_API_KEY")
        api_secret = os.getenv("BINANCE_API_SECRET")
        testnet = os.getenv("USE_TESTNET", "True").lower() == "true"

        # BinanceClient asynchron initialisieren
        self.client = await BinanceClient.create(api_key, api_secret, testnet)
        self.executor = TradeExecutor(self.client)

        logger.info(f"📊 Backtest für {self.symbol} gestartet…")
        ohlcv = await self.client.fetch_ohlcv(
            self.symbol, self.granularity,
            since=self._ts(self.start),
            until=self._ts(self.end)
        )

        for i in range(len(ohlcv)):
            ts, o, h, l, c, v = ohlcv[i]
            time = datetime.utcfromtimestamp(ts/1000)

            # Indikatoren berechnen
            window_ema = [row[4] for row in ohlcv[max(0, i-50):i+1]]
            window_rsi = [row[4] for row in ohlcv[max(0, i-15):i+1]]
            window_atr = ohlcv[max(0, i-15):i+1]
            ema = calculate_ema(window_ema, period=20)[-1]
            rsi = calculate_rsi(window_rsi, period=14)[-1]
            atr = calculate_atr(window_atr, period=14)[-1]

            # Entry-Signale
            if not self.pos:
                if c > ema and rsi < 30:
                    signal = 'BUY'
                elif c < ema and rsi > 70:
                    signal = 'SELL'
                else:
                    signal = None

                if signal:
                    qty = self.balance / c
                    res = await self.executor.execute_trade(
                        self.symbol, signal, qty,
                        atr_period=14, sl_multiplier=1.5, tp_multiplier=3.0,
                        martingale_factor=1.0, paper=True
                    )
                    self.pos = {
                        'entry_time': time,
                        'entry_price': res['entry_price'],
                        'sl': res['sl_price'],
                        'tp': res['tp_price'],
                        'qty': res['qty'],
                        'side': signal
                    }

            # Exit-Logik
            if self.pos:
                price = c
                side = self.pos['side']
                exit_trade = False
                if side == 'BUY' and (price <= self.pos['sl'] or price >= self.pos['tp']):
                    exit_trade = True
                elif side == 'SELL' and (price >= self.pos['sl'] or price <= self.pos['tp']):
                    exit_trade = True

                if exit_trade:
                    pnl = (price - self.pos['entry_price']) * self.pos['qty']
                    if side == 'SELL':
                        pnl *= -1
                    self.balance += pnl
                    self.trades.append({
                        'entry': self.pos['entry_price'],
                        'exit': price,
                        'pnl': pnl
                    })
                    self.equity_curve.append(self.balance)
                    logger.info(
                        f"[Backtest] {side} {self.symbol} Entry={self.pos['entry_price']:.2f} Exit={price:.2f} P&L={pnl:.4f} Bal={self.balance:.4f}"
                    )
                    self.pos = None

        stats = self._compute_metrics()
        self._save_results(stats)
        logger.info(f"📈 Backtest abgeschlossen — Endbalance: {self.balance:.2f} — Stats: {stats}")

    def _compute_metrics(self):
        returns = []
        peak = self.initial_balance
        max_dd = 0
        wins = 0

        for bal in self.equity_curve[1:]:
            ret = (bal - peak) / peak
            returns.append(ret)
            if bal > peak:
                peak = bal
            dd = (peak - bal) / peak
            max_dd = max(max_dd, dd)
            if ret > 0:
                wins += 1

        win_rate = wins / len(returns) if returns else 0
        avg_ret = mean(returns) if returns else 0
        std_ret = pstdev(returns) if len(returns) > 1 else 0.0001
        sharpe = (avg_ret / std_ret) * math.sqrt(8760) if std_ret else 0
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        return {
            'total_return': total_return,
            'max_drawdown': max_dd,
            'win_rate': win_rate,
            'sharpe_ratio': sharpe
        }

    def _save_results(self, stats: dict):
        base = f"backtest_{self.symbol}_{self.start}_{self.end}"
        with open(f"{base}.csv", 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=['entry', 'exit', 'pnl'])
            writer.writeheader()
            for t in self.trades:
                writer.writerow(t)
        with open(f"{base}_stats.txt", 'w') as f:
            for k, v in stats.items():
                f.write(f"{k}: {v}\n")

    @staticmethod
    def _ts(date_str: str) -> int:
        dt = datetime.fromisoformat(date_str)
        return int(dt.timestamp() * 1000)



### FILE: ./utils/cooldown_manager.py
# utils/cooldown_manager.py

from datetime import datetime, timedelta

class CooldownManager:
    def __init__(self, cooldown_minutes=30):
        self.cooldowns = {}  # symbol → datetime
        self.cooldown_duration = timedelta(minutes=cooldown_minutes)

    def is_in_cooldown(self, symbol: str) -> bool:
        now = datetime.utcnow()
        last = self.cooldowns.get(symbol)
        return last and (now - last) < self.cooldown_duration

    def update_cooldown(self, symbol: str):
        self.cooldowns[symbol] = datetime.utcnow()



### FILE: ./utils/drawdown_guard.py
# utils/drawdown_guard.py

from datetime import datetime
import pandas as pd

class DrawdownGuard:
    def __init__(self, csv_file="paper_trades.csv", start_balance=20.0, max_loss_pct=5.0):
        self.csv_file = csv_file
        self.start_balance = start_balance
        self.max_loss_pct = max_loss_pct

    def loss_today_exceeded(self) -> bool:
        try:
            df = pd.read_csv(self.csv_file)
            df = df[df["pnl"].notna()]
            today = datetime.utcnow().date()
            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df[df["timestamp"].dt.date == today]

            if df.empty:
                return False

            pnl_sum = df["pnl"].sum()
            loss_pct = -pnl_sum / self.start_balance * 100 if pnl_sum < 0 else 0

            return loss_pct >= self.max_loss_pct
        except Exception:
            return False  # Lieber weiter traden als fälschlich stoppen



### FILE: ./utils/equity_plot.py
# utils/equity_plot.py

import pandas as pd
import matplotlib.pyplot as plt

def plot_equity_curve(csv_file="paper_trades.csv", out_file="equity_curve.png"):
    df = pd.read_csv(csv_file)
    df["timestamp"] = pd.to_datetime(df["timestamp"])
    df = df.sort_values("timestamp")

    # Equity berechnen
    equity = []
    balance = 20  # Startwert
    for _, row in df.iterrows():
        if pd.notna(row["pnl"]):
            balance += row["pnl"]
        equity.append(balance)

    df["equity"] = equity

    plt.figure(figsize=(10, 5))
    plt.plot(df["timestamp"], df["equity"], label="Equity Curve", color="green")
    plt.title("Equity Curve (Paper-Trades)")
    plt.xlabel("Zeit")
    plt.ylabel("USDC")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_file)
    plt.close()



### FILE: ./utils/logger.py
# utils/logger.py — Version 1.0.2

import logging
import os
import sys
from logging.handlers import RotatingFileHandler

LOG_DIR = "logs"
LOG_FILE = os.path.join(LOG_DIR, "bot.log")

def setup_logger(name="bot"):
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', "%Y-%m-%d %H:%M:%S")

    # File Handler
    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5*1024*1024, backupCount=2)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Console Handler (optional)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Prevent duplicate logs
    logger.propagate = False

    return logger

# Global Logger
logger = setup_logger()

# Capture unhandled exceptions
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception



### FILE: ./utils/market_classifier.py
# utils/market_classifier.py

import numpy as np
from strategies.indicators import calculate_ema, calculate_atr

def classify_market(ohlcv, short_ema=20, long_ema=50, atr_period=14, atr_threshold=0.01):
    closes = [candle[4] for candle in ohlcv]
    highs = [candle[2] for candle in ohlcv]
    lows = [candle[3] for candle in ohlcv]

    ema_short = calculate_ema(closes, short_ema)[-1]
    ema_long = calculate_ema(closes, long_ema)[-1]
    atr = calculate_atr(highs, lows, closes, atr_period)[-1]

    # Verhältnis ATR zu aktuellem Preis → Volatilität
    current_price = closes[-1]
    volatility_ratio = atr / current_price

    # Klassifizierung
    if ema_short > ema_long * 1.01:
        if volatility_ratio > atr_threshold:
            return "trend_bullish"
        else:
            return "bullish_sideways"
    elif ema_short < ema_long * 0.99:
        if volatility_ratio > atr_threshold:
            return "trend_bearish"
        else:
            return "bearish_sideways"
    elif volatility_ratio > atr_threshold * 1.5:
        return "volatile"
    else:
        return "sideways"



### FILE: ./utils/risk_manager.py
# utils/risk_manager.py

class RiskManager:
    def __init__(self, initial_balance: float = 20.0, max_risk_per_trade: float = 0.02):
        self.balance = initial_balance
        self.risk_pct = max_risk_per_trade  # z. B. 2 %

    def update_balance(self, new_balance: float):
        self.balance = new_balance

    def calculate_position_size(self, entry_price: float, stop_loss: float) -> float:
        sl_distance = abs(entry_price - stop_loss)
        if sl_distance == 0:
            return 0.0  # keine sinnvolle Positionsgröße möglich
        risk_amount = self.balance * self.risk_pct
        qty = risk_amount / sl_distance
        return round(qty, 6)



### FILE: ./utils/signal_filter.py
# utils/signal_filter.py

from strategies.indicators import calculate_ema, calculate_atr

class SignalFilter:
    def __init__(self, volume_factor=1.2, atr_threshold=0.001, trend_strength=0.001):
        self.volume_factor = volume_factor       # z. B. 1.2x über 10er-Avg
        self.atr_threshold = atr_threshold       # z. B. mind. 0.1 % Bewegung
        self.trend_strength = trend_strength     # z. B. Preisabstand zu EMA20 > 0.1 %

    def passes_filters(self, ohlcv) -> bool:
        closes = [c[4] for c in ohlcv]
        highs = [c[2] for c in ohlcv]
        lows = [c[3] for c in ohlcv]
        volumes = [c[5] for c in ohlcv]

        # Trend-Erkennung
        ema = calculate_ema(closes, 20)[-1]
        price = closes[-1]
        trend_diff = abs(price - ema) / ema
        if trend_diff < self.trend_strength:
            return False  # Kein klarer Trend

        # Volumen-Filter
        avg_vol = sum(volumes[-11:-1]) / 10
        if volumes[-1] < avg_vol * self.volume_factor:
            return False  # Kein Volumenimpuls

        # ATR-basierte Volatilitätsprüfung
        atr = calculate_atr(ohlcv, 14)[-1]
        if atr / price < self.atr_threshold:
            return False  # Markt zu ruhig

        return True  # Alles passt



### FILE: ./utils/strategy_watchdog.py
# utils/strategy_watchdog.py

import csv
import os
from datetime import datetime
from collections import defaultdict

WATCHDOG_FILE = "strategy_watchdog.csv"

class StrategyWatchdog:
    def __init__(self):
        self.stats = defaultdict(lambda: {"trades": 0, "wins": 0, "losses": 0})
        self._load_existing()

    def _load_existing(self):
        if not os.path.isfile(WATCHDOG_FILE):
            return
        with open(WATCHDOG_FILE, mode="r") as f:
            reader = csv.DictReader(f)
            for row in reader:
                strat = row["strategy"]
                self.stats[strat] = {
                    "trades": int(row["trades"]),
                    "wins": int(row["wins"]),
                    "losses": int(row["losses"])
                }

    def record_trade(self, strategy_name: str, pnl: float):
        stat = self.stats[strategy_name]
        stat["trades"] += 1
        if pnl > 0:
            stat["wins"] += 1
        else:
            stat["losses"] += 1
        self._save()

    def _save(self):
        with open(WATCHDOG_FILE, mode="w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["strategy", "trades", "wins", "losses"])
            for strat, s in self.stats.items():
                writer.writerow([strat, s["trades"], s["wins"], s["losses"]])



### FILE: ./utils/trade_logger.py
# utils/trade_logger.py

import csv
import os
from datetime import datetime

TRADE_LOG_FILE = "paper_trades.csv"

def log_trade(symbol, side, entry_price, sl, tp, qty, pnl=None, strategy=None):
    file_exists = os.path.isfile(TRADE_LOG_FILE)
    with open(TRADE_LOG_FILE, mode='a', newline='') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow([
                "timestamp", "symbol", "side", "entry_price",
                "stop_loss", "take_profit", "qty", "pnl"
            ])
        writer.writerow([
	    datetime.utcnow().isoformat(), symbol, side, entry_price,
    	sl, tp, qty, pnl if pnl is not None else "", strategy or ""
	])



### FILE: ./utils/trade_tracker.py
import pandas as pd
from datetime import datetime
from utils.trade_logger import log_trade

def update_trade_pnls(csv_file="paper_trades.csv", current_prices=None):
    df = pd.read_csv(csv_file)
    updated = False

    for idx, row in df[df["pnl"].isna()].iterrows():
        symbol = row["symbol"]
        price = current_prices.get(symbol)
        if price is None:
            continue

        side = row["side"]
        entry = row["entry_price"]
        sl = row["stop_loss"]
        tp = row["take_profit"]
        qty = row["qty"]

        pnl = None
        # Prüfen, ob SL oder TP erreicht wurde
        if side == "BUY" and (price <= sl or price >= tp):
            pnl = (price - entry) * qty
        elif side == "SELL" and (price >= sl or price <= tp):
            pnl = (entry - price) * qty

        # Nur wenn Trade geschlossen wurde:
        if pnl is not None:
            df.at[idx, "pnl"] = pnl
            updated = True

            # Optional: Watchdog informieren, falls Strategie geloggt wurde
            strategy_name = row.get("strategy", "Unknown")
            try:
                from utils.strategy_watchdog import StrategyWatchdog
                StrategyWatchdog().record_trade(strategy_name=strategy_name, pnl=pnl)
            except Exception as e:
                print(f"[Watchdog] Fehler bei Strategie-Tracking: {e}")

    if updated:
        df.to_csv(csv_file, index=False)


### FILE: ./bot.py
#!/usr/bin/env python3
# bot.py — Version 1.0.1

import os
import asyncio
from dotenv import load_dotenv
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from utils.backtester import Backtester
from utils.logger import logger

__version__ = "1.0.1"

def load_config():
    load_dotenv()
    return {
        "api_key": os.getenv("BINANCE_API_KEY"),
        "api_secret": os.getenv("BINANCE_API_SECRET"),
        "testnet": os.getenv("USE_TESTNET", "True").lower() == "true",
        "symbol": os.getenv("SYMBOL", "BTCUSDC"),
        "backtest_start": os.getenv("BACKTEST_START", "2025-01-01T00:00"),
        "backtest_end": os.getenv("BACKTEST_END", "2025-06-01T00:00"),
        "granularity": os.getenv("GRANULARITY", "1h"),
        "initial_balance": float(os.getenv("INITIAL_BALANCE", "20.0")),
        "trade_quantity": float(os.getenv("TRADE_QUANTITY", "0.001")),
        "paper_trading": os.getenv("PAPER_TRADING", "True").lower() == "true",
        "atr_period": int(os.getenv("ATR_PERIOD", "14")),
        "sl_multiplier": float(os.getenv("SL_MULTIPLIER", "1.5")),
        "tp_multiplier": float(os.getenv("TP_MULTIPLIER", "3.0")),
        "martingale_factor": float(os.getenv("MARTINGALE_FACTOR", "1.0")),
    }

async def main():
    cfg = load_config()
    logger.info(f"🚀 Starting Grok-FuturesBot v{__version__}")

    # 1) Backtest
    logger.info("🔍 Running backtest…")
    bt = Backtester(
        symbol=cfg["symbol"],
        start=cfg["backtest_start"],
        end=cfg["backtest_end"],
        granularity=cfg["granularity"],
        initial_balance=cfg["initial_balance"],
    )
    await bt.run()

    # 2) Live-/Paper-Trading Beispiel
    logger.info("💡 Starting live/paper trading example…")
    client = await BinanceClient.create(
        api_key=cfg["api_key"],
        api_secret=cfg["api_secret"],
        testnet=cfg["testnet"],
    )
    executor = TradeExecutor(client)
    result = await executor.execute_trade(
        symbol=cfg["symbol"],
        side="BUY",
        quantity=cfg["trade_quantity"],
        atr_period=cfg["atr_period"],
        sl_multiplier=cfg["sl_multiplier"],
        tp_multiplier=cfg["tp_multiplier"],
        martingale_factor=cfg["martingale_factor"],
        paper=cfg["paper_trading"],
    )
    logger.info(
        f"🎯 Trade result (paper={cfg['paper_trading']}): Entry={result['entry_price']}, SL={result['sl_price']}, TP={result['tp_price']}"
    )

if __name__ == "__main__":
    asyncio.run(main())



### FILE: ./core/client.py
# core/client.py — Version 1.0.2

import asyncio
import ccxt.async_support as ccxt
from binance import AsyncClient
from utils.logger import logger

class BinanceClient:
    def __init__(self, client: AsyncClient):
        self.client = client

    @classmethod
    async def create(cls, api_key: str, api_secret: str, testnet: bool = False):
        logger.info(f"🔌 Verbinde mit Binance (testnet={testnet})...")
        client = await AsyncClient.create(
            api_key=api_key,
            api_secret=api_secret,
            testnet=testnet
        )
        return cls(client)

    async def get_futures_price(self, symbol: str) -> float:
        ticker = await self.client.futures_symbol_ticker(symbol=symbol)
        return float(ticker["price"])

    async def fetch_ohlcv(self, symbol: str, timeframe: str, since: int = None, limit: int = None, until: int = None):
        exchange = ccxt.binance({
            'enableRateLimit': True,
            'options': {
                'defaultType': 'future'
            }
        })
        if since and until:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since)
            ohlcv = [c for c in ohlcv if c[0] <= until]
        else:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
        await exchange.close()
        return ohlcv

    async def futures_change_leverage(self, symbol: str, leverage: int):
        """
        Setzt das Leverage für ein Futures-Symbol.
        """
        try:
            result = await self.client.futures_change_leverage(symbol=symbol, leverage=leverage)
            logger.info(f"[LEVERAGE] {symbol}: Leverage wurde auf {leverage}x gesetzt. Antwort: {result}")
            return result
        except Exception as e:
            logger.error(f"[LEVERAGE] Fehler beim Setzen des Leverage für {symbol}: {e}")
            raise

    async def close(self):
        await self.client.close_connection()



### FILE: ./core/strategy_engine.old.py
from strategies.RSI_ema import ema_rsi_signal
from strategies.breakouts import breakout_signal
from strategies.reversal import reversal_signal
from strategies.range_trading import range_trading_signal
from utils.market_classifier import classify_market
from utils.volatility import calculate_volatility

class StrategyEngine:
    def __init__(self):
        pass

    def choose_strategy(self, ohlcv):
        market_state = classify_market(ohlcv)
        volatility = calculate_volatility(ohlcv)
        
        if market_state == "trend_bullish":
            return breakout_signal, market_state
        elif market_state == "trend_bearish":
            return reversal_signal, market_state
        elif market_state == "sideways":
            return range_trading_signal, market_state
        elif market_state == "volatile":
            return breakout_signal, market_state
        else:
            return None, market_state

    def get_signal(self, ohlcv):
        strategy, market_state = self.choose_strategy(ohlcv)
        if strategy:
            return strategy(ohlcv), market_state
        return None, market_state



### FILE: ./core/trade_executor.py
from utils.logger import logger
from strategies.indicators import calculate_atr
from binance.enums import *

SIDE_Buy = "Buy"

class TradeExecutor:
    def __init__(self, client, base_currency: str = "USDC"):
        self.client = client
        self.base_currency = base_currency

    async def execute_trade(
        self,
        symbol: str,
        side: str,
        quantity: float,
        sl: float = None,
        tp: float = None,
        atr_period: int = 14,
        sl_multiplier: float = 1.5,
        tp_multiplier: float = 3.0,
        martingale_factor: float = 1.0,
        paper: bool = True
    ):
        qty = quantity * martingale_factor
        logger.info(f"Placing {side} order for {symbol} qty={qty:.6f} (martingale={martingale_factor})")

        # Preis ermitteln
        if paper:
            price = await self.client.get_futures_price(symbol)
            logger.info(f"(Paper) Order simulated at {price}")
        else:
            order = await self.client.client.futures_create_order(
                symbol=symbol,
                side=side,
                type=FUTURE_ORDER_TYPE_MARKET,
                quantity=qty
            )
            price = float(order["avgPrice"])
            logger.info(f"Order executed at price={price}")

        # SL/TP berechnen wenn nicht manuell übergeben
        if sl is None or tp is None:
            ohlcv = await self.client.fetch_ohlcv(symbol, timeframe='1h', limit=atr_period + 1)
            atr = calculate_atr(ohlcv, period=atr_period)[-1]
            sl, tp = self._compute_sl_tp(price, atr, side, sl_multiplier, tp_multiplier)

        return {
            "entry_price": price,
            "sl_price": sl,
            "tp_price": tp,
            "qty": qty
        }

    def _compute_sl_tp(self, entry: float, atr: float, side: str,
                       sl_mult: float, tp_mult: float):
        if side == SIDE_BUY:
            sl = entry - atr * sl_mult
            tp = entry + atr * tp_mult
        else:
            sl = entry + atr * sl_mult
            tp = entry - atr * tp_mult
        return sl, tp



### FILE: ./dashboard/app.py
from flask import Flask, render_template, send_file
import os
import sys
import pandas as pd
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.equity_plot import plot_equity_curve
from utils.trade_logger import log_trade 
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

app = Flask(__name__)

@app.route("/")
def index():
    # Equity-Kurve aktualisieren
    plot_equity_curve(CSV_PATH, "dashboard/static/equity_curve.png")

    # Daten aus CSV laden
    df = pd.read_csv(CSV_PATH)
    df_closed = df[df["pnl"].notna()]
    balance = 20.0 + df_closed["pnl"].sum()
    winrate = (df_closed["pnl"] > 0).mean() * 100 if not df_closed.empty else 0

    return render_template("index.html", 
        balance=round(balance, 2),
        total_trades=len(df),
        winrate=round(winrate, 1),
        trades=df.tail(10).to_dict(orient="records")
    )

@app.route("/chart")
def chart():
    return send_file("static/equity_curve.png", mimetype='image/png')

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)



### FILE: ./multi_backtest.py
import asyncio
from utils.backtester import Backtester

symbol_list = ["BTCUSDC", "ETHUSDC", "BNBUSDC", "SOLUSDC"]
start = "2025-01-01T00:00"
end = "2025-06-01T00:00"
granularity = "1h"
initial_balance = 20.0

async def run_backtests():
    tasks = []
    for symbol in symbol_list:
        bt = Backtester(
            symbol=symbol,
            start=start,
            end=end,
            granularity=granularity,
            initial_balance=initial_balance
        )
        tasks.append(bt.run())
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(run_backtests())



### FILE: ./paper_loop.py
import os
import sys
import asyncio
from dotenv import load_dotenv
from datetime import datetime
import aiohttp

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.engine import StrategyEngine
from strategies.indicators import calculate_atr
from utils.logger import logger
from utils.trade_logger import log_trade
from utils.trade_tracker import update_trade_pnls
from utils.risk_manager import RiskManager
from utils.cooldown_manager import CooldownManager
from utils.signal_filter import SignalFilter
from utils.drawdown_guard import DrawdownGuard
from utils.strategy_watchdog import StrategyWatchdog

# Einstellungen
load_dotenv()
PAPER = True
INTERVAL = 30
START_BALANCE = 20.0
SYMBOLS = []

# Leverage-Setting (NEU)
LEVERAGE = int(os.getenv("BOT_LEVERAGE", 3))
traded_symbols = set()

# Bot-Komponenten
engine = StrategyEngine()
risk_manager = RiskManager(initial_balance=START_BALANCE, max_risk_per_trade=0.02)
cooldown = CooldownManager(cooldown_minutes=30)
signal_filter = SignalFilter()
drawdown_guard = DrawdownGuard(start_balance=START_BALANCE, max_loss_pct=5.0)
watchdog = StrategyWatchdog()

# Abruf der Top 100 USDC-Futures-Paare nach Volumen
async def get_top_usdc_symbols_by_volume(limit=100):
    url = "https://fapi.binance.com/fapi/v1/ticker/24hr"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
            filtered = [
                d for d in data if d["symbol"].endswith("USDC") and float(d["quoteVolume"]) > 100000
            ]
            sorted_pairs = sorted(filtered, key=lambda x: float(x["quoteVolume"]), reverse=True)
            return [item["symbol"] for item in sorted_pairs[:limit]]

# Hauptloop
async def trade_loop():
    global SYMBOLS
    client = await BinanceClient.create(
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
        testnet=os.getenv("USE_TESTNET", "True").lower() == "true"
    )
    executor = TradeExecutor(client)

    # Handelsuniversum bestimmen
    SYMBOLS = await get_top_usdc_symbols_by_volume(limit=100)

    logger.info(f"📊 Überwachte Paare: {', '.join(SYMBOLS[:10])} ...")

    try:
        while True:
            if drawdown_guard.loss_today_exceeded():
                logger.warning("🛑 Tagesverlustgrenze erreicht – Trading pausiert.")
                await asyncio.sleep(INTERVAL)
                continue

            for symbol in SYMBOLS:
                try:
                    ohlcv = await client.fetch_ohlcv(symbol, "1h", limit=50)
                    closes = [row[4] for row in ohlcv]
                    price = closes[-1]
                    atr = calculate_atr(ohlcv, 14)[-1] 

                    strategy = engine.select_strategy(ohlcv)
                    signal = strategy.generate_signal(ohlcv)

                    if not signal:
                        continue

                    if cooldown.is_in_cooldown(symbol):
                        logger.info(f"[COOLDOWN] {symbol}: aktiv – übersprungen.")
                        continue

                    if not signal_filter.passes_filters(ohlcv):
                        logger.info(f"[FILTER] {symbol}: Markt ungeeignet.")
                        continue

                    sl, tp = strategy.sl_tp(price, atr)
                    qty = risk_manager.calculate_position_size(entry_price=price, stop_loss=sl)

                    if qty <= 0:
                        logger.warning(f"[RISK] {symbol}: Ordergröße zu klein – übersprungen.")
                        continue

                    # LEVERAGE NUR BEIM ERSTEN TRADE PRO SYMBOL SETZEN (NEU)
                    if symbol not in traded_symbols:
                        await client.futures_change_leverage(symbol=symbol, leverage=LEVERAGE)
                        traded_symbols.add(symbol)

                    logger.info(f"[TRADE] {symbol}: {signal} @ {price:.2f} SL={sl:.2f} TP={tp:.2f} QTY={qty:.4f}")

                    result = await executor.execute_trade(
                        symbol=symbol,
                        side=signal,
                        quantity=qty,
                        sl=sl,
                        tp=tp,
                        paper=PAPER
                    )

                    log_trade(
                        symbol=symbol,
                        side=signal,
                        entry_price=result["entry_price"],
                        sl=sl,
                        tp=tp,
                        qty=qty,
                        strategy=strategy.__class__.__name__
                    )

                    cooldown.update_cooldown(symbol)

                except Exception as e:
                    logger.error(f"[{symbol}] Fehler im Loop: {e}")

            try:
                current_prices = {symbol: await client.get_futures_price(symbol) for symbol in SYMBOLS}
                update_trade_pnls(current_prices=current_prices)
            except Exception as e:
                logger.warning(f"[PnL] Preisabruf fehlgeschlagen: {e}")

            logger.info(f"⏳ Nächster Zyklus in {INTERVAL} Sekunden...\n")
            await asyncio.sleep(INTERVAL)

    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(trade_loop())



### FILE: ./strategies/breakout.py
# strategies/breakout.py

class BreakoutStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "trend"

    def generate_signal(self, ohlcv):
        highs = [c[2] for c in ohlcv[-20:]]
        lows = [c[3] for c in ohlcv[-20:]]
        close = ohlcv[-1][4]
        if close > max(highs[:-1]):
            return "BUY"
        elif close < min(lows[:-1]):
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.0 * atr
        tp = price + 2.5 * atr
        return sl, tp



### FILE: ./strategies/engine.py
# strategies/engine.py

from strategies.rsi_ema import RSIEMAStrategy
from strategies.breakout import BreakoutStrategy

class StrategyEngine:
    def __init__(self):
        self.strategies = [
            RSIEMAStrategy(),
            BreakoutStrategy()
        ]

    def evaluate_market(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        change = abs(closes[-1] - closes[-20]) / closes[-20]
        if change > 0.02:
            return "trend"
        return "sideways"

    def select_strategy(self, ohlcv):
        market = self.evaluate_market(ohlcv)
        for strategy in self.strategies:
            if strategy.suits(market):
                return strategy
        return self.strategies[0]



### FILE: ./strategies/futures_ema_rsi.py
# strategies/futures_ema_rsi.py

"""
EMA & RSI-basierte Futures-Strategie mit ATR-SL/TP
"""
import numpy as np
import pandas as pd
from utils.logger import logger
from utils.indicators import EMA, RSI, ATR

class EMARSI_Strategy:
def **init**(self, client, symbols, interval, leverage, risk\_per\_trade):
self.client = client
self.symbols = symbols
self.interval = interval
self.leverage = leverage
self.risk_per_trade = risk_per_trade

```
async def check_signal(self, symbol):
    data = await self.client.fetch_ohlcv(symbol, self.interval)
    df = pd.DataFrame(data, columns=['timestamp','open','high','low','close','volume'])

    ema_fast = calculate_ema(df['close'], period=10)
    ema_slow = calculate_ema(df['close'], period=20)
    rsi = calculate_rsi(df['close'], period=14)

    if ema_fast.iloc[-1] > ema_slow.iloc[-1] and rsi.iloc[-1] < 30:
        logger.info(f"Long signal für {symbol}")
        return 'LONG'
    if ema_fast.iloc[-1] < ema_slow.iloc[-1] and rsi.iloc[-1] > 70:
        logger.info(f"Short signal für {symbol}")
        return 'SHORT'
    return None

async def execute_trade(self, symbol, signal):
    # Positionsgröße berechnen
    balance = await self.client.fetch_balance()
    available = balance['total']['USDC']
    amount = (available * self.risk_per_trade) / price  # Preis muss aus DataFrame
    side = 'buy' if signal == 'LONG' else 'sell'
    order = await self.client.create_order(symbol, side, amount)
    if order:
        logger.info(f"Order ausgeführt: {order}")
```



### FILE: ./strategies/indicators.py
# strategies/indicators.py — Version 1.0.1

import pandas as pd

def calculate_ema(series, period=14):
    return pd.Series(series).ewm(span=period, adjust=False).mean().tolist()

def calculate_rsi(series, period=14):
    df = pd.Series(series)
    delta = df.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi.fillna(0).tolist()

def calculate_atr(ohlcv, period=14):
    df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])
    df["h-l"] = df["high"] - df["low"]
    df["h-pc"] = abs(df["high"] - df["close"].shift(1))
    df["l-pc"] = abs(df["low"] - df["close"].shift(1))
    tr = df[["h-l", "h-pc", "l-pc"]].max(axis=1)
    atr = tr.rolling(window=period).mean()
    return atr.fillna(0).tolist()




### FILE: ./strategies/rsi_ema.py
# strategies/rsi_ema.py

from strategies.indicators import calculate_ema, calculate_rsi

class RSIEMAStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        price = closes[-1]
        ema = calculate_ema(closes, 20)[-1]
        rsi = calculate_rsi(closes, 14)[-1]

        if price > ema and rsi < 45:
            return "BUY"
        elif price < ema and rsi > 55:
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.5 * atr
        tp = price + 3.0 * atr
        return sl, tp



### FILE: ./utils/backtester.py
# utils/backtester.py — Version 1.0.2

import os
import asyncio
import csv
import math
from datetime import datetime
from statistics import mean, pstdev
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.indicators import calculate_ema, calculate_rsi, ATR
from utils.logger import logger
from dotenv import load_dotenv


__version__ = "1.0.2"

class Backtester:
    def __init__(self, symbol: str, start: str, end: str,
                 granularity: str = '1h', initial_balance: float = 20.0):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.granularity = granularity
        self.initial_balance = initial_balance
        self.client = None
        self.executor = None
        self.reset()

    def reset(self):
        self.balance = self.initial_balance
        self.pos = None
        self.trades = []
        self.equity_curve = [self.initial_balance]

    async def run(self):
        # Lade API-Konfig aus .env
        load_dotenv()
        api_key = os.getenv("BINANCE_API_KEY")
        api_secret = os.getenv("BINANCE_API_SECRET")
        testnet = os.getenv("USE_TESTNET", "True").lower() == "true"

        # BinanceClient asynchron initialisieren
        self.client = await BinanceClient.create(api_key, api_secret, testnet)
        self.executor = TradeExecutor(self.client)

        logger.info(f"📊 Backtest für {self.symbol} gestartet…")
        ohlcv = await self.client.fetch_ohlcv(
            self.symbol, self.granularity,
            since=self._ts(self.start),
            until=self._ts(self.end)
        )

        for i in range(len(ohlcv)):
            ts, o, h, l, c, v = ohlcv[i]
            time = datetime.utcfromtimestamp(ts/1000)

            # Indikatoren berechnen
            window_ema = [row[4] for row in ohlcv[max(0, i-50):i+1]]
            window_rsi = [row[4] for row in ohlcv[max(0, i-15):i+1]]
            window_atr = ohlcv[max(0, i-15):i+1]
            ema = calculate_ema(window_ema, period=20)[-1]
            rsi = calculate_rsi(window_rsi, period=14)[-1]
            atr = calculate_atr(window_atr, period=14)[-1]

            # Entry-Signale
            if not self.pos:
                if c > ema and rsi < 30:
                    signal = 'BUY'
                elif c < ema and rsi > 70:
                    signal = 'SELL'
                else:
                    signal = None

                if signal:
                    qty = self.balance / c
                    res = await self.executor.execute_trade(
                        self.symbol, signal, qty,
                        atr_period=14, sl_multiplier=1.5, tp_multiplier=3.0,
                        martingale_factor=1.0, paper=True
                    )
                    self.pos = {
                        'entry_time': time,
                        'entry_price': res['entry_price'],
                        'sl': res['sl_price'],
                        'tp': res['tp_price'],
                        'qty': res['qty'],
                        'side': signal
                    }

            # Exit-Logik
            if self.pos:
                price = c
                side = self.pos['side']
                exit_trade = False
                if side == 'BUY' and (price <= self.pos['sl'] or price >= self.pos['tp']):
                    exit_trade = True
                elif side == 'SELL' and (price >= self.pos['sl'] or price <= self.pos['tp']):
                    exit_trade = True

                if exit_trade:
                    pnl = (price - self.pos['entry_price']) * self.pos['qty']
                    if side == 'SELL':
                        pnl *= -1
                    self.balance += pnl
                    self.trades.append({
                        'entry': self.pos['entry_price'],
                        'exit': price,
                        'pnl': pnl
                    })
                    self.equity_curve.append(self.balance)
                    logger.info(
                        f"[Backtest] {side} {self.symbol} Entry={self.pos['entry_price']:.2f} Exit={price:.2f} P&L={pnl:.4f} Bal={self.balance:.4f}"
                    )
                    self.pos = None

        stats = self._compute_metrics()
        self._save_results(stats)
        logger.info(f"📈 Backtest abgeschlossen — Endbalance: {self.balance:.2f} — Stats: {stats}")

    def _compute_metrics(self):
        returns = []
        peak = self.initial_balance
        max_dd = 0
        wins = 0

        for bal in self.equity_curve[1:]:
            ret = (bal - peak) / peak
            returns.append(ret)
            if bal > peak:
                peak = bal
            dd = (peak - bal) / peak
            max_dd = max(max_dd, dd)
            if ret > 0:
                wins += 1

        win_rate = wins / len(returns) if returns else 0
        avg_ret = mean(returns) if returns else 0
        std_ret = pstdev(returns) if len(returns) > 1 else 0.0001
        sharpe = (avg_ret / std_ret) * math.sqrt(8760) if std_ret else 0
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        return {
            'total_return': total_return,
            'max_drawdown': max_dd,
            'win_rate': win_rate,
            'sharpe_ratio': sharpe
        }

    def _save_results(self, stats: dict):
        base = f"backtest_{self.symbol}_{self.start}_{self.end}"
        with open(f"{base}.csv", 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=['entry', 'exit', 'pnl'])
            writer.writeheader()
            for t in self.trades:
                writer.writerow(t)
        with open(f"{base}_stats.txt", 'w') as f:
            for k, v in stats.items():
                f.write(f"{k}: {v}\n")

    @staticmethod
    def _ts(date_str: str) -> int:
        dt = datetime.fromisoformat(date_str)
        return int(dt.timestamp() * 1000)



### FILE: ./utils/cooldown_manager.py
# utils/cooldown_manager.py

from datetime import datetime, timedelta

class CooldownManager:
    def __init__(self, cooldown_minutes=30):
        self.cooldowns = {}  # symbol → datetime
        self.cooldown_duration = timedelta(minutes=cooldown_minutes)

    def is_in_cooldown(self, symbol: str) -> bool:
        now = datetime.utcnow()
        last = self.cooldowns.get(symbol)
        return last and (now - last) < self.cooldown_duration

    def update_cooldown(self, symbol: str):
        self.cooldowns[symbol] = datetime.utcnow()



### FILE: ./utils/drawdown_guard.py
# utils/drawdown_guard.py

from datetime import datetime
import pandas as pd

class DrawdownGuard:
    def __init__(self, csv_file="paper_trades.csv", start_balance=20.0, max_loss_pct=5.0):
        self.csv_file = csv_file
        self.start_balance = start_balance
        self.max_loss_pct = max_loss_pct

    def loss_today_exceeded(self) -> bool:
        try:
            df = pd.read_csv(self.csv_file)
            df = df[df["pnl"].notna()]
            today = datetime.utcnow().date()
            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df[df["timestamp"].dt.date == today]

            if df.empty:
                return False

            pnl_sum = df["pnl"].sum()
            loss_pct = -pnl_sum / self.start_balance * 100 if pnl_sum < 0 else 0

            return loss_pct >= self.max_loss_pct
        except Exception:
            return False  # Lieber weiter traden als fälschlich stoppen



### FILE: ./utils/equity_plot.py
# utils/equity_plot.py

import pandas as pd
import matplotlib.pyplot as plt
import os
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

def plot_equity_curve(csv_file=CSV_PATH, out_file="equity_curve.png"):
    df = pd.read_csv(csv_file)
    df["time"] = pd.to_datetime(df["time"])
    df = df.sort_values("time")

    # Equity berechnen
    equity = []
    balance = 20  # Startwert
    for _, row in df.iterrows():
        if pd.notna(row["pnl"]):
            balance += row["pnl"]
        equity.append(balance)

    df["equity"] = equity

    plt.figure(figsize=(10, 5))
    plt.plot(df["time"], df["equity"], label="Equity Curve", color="green")
    plt.title("Equity Curve (Paper-Trades)")
    plt.xlabel("Zeit")
    plt.ylabel("USDC")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_file), exist_ok=True)
    plt.savefig(out_file)
    plt.close()



### FILE: ./utils/logger.py
# utils/logger.py — Version 1.0.2

import logging
import os
import sys
from logging.handlers import RotatingFileHandler

LOG_DIR = "logs"
LOG_FILE = os.path.join(LOG_DIR, "bot.log")

def setup_logger(name="bot"):
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', "%Y-%m-%d %H:%M:%S")

    # File Handler
    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5*1024*1024, backupCount=2)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Console Handler (optional)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Prevent duplicate logs
    logger.propagate = False

    return logger

# Global Logger
logger = setup_logger()

# Capture unhandled exceptions
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception



### FILE: ./utils/market_classifier.py
# utils/market_classifier.py

import numpy as np
from strategies.indicators import calculate_ema, calculate_atr

def classify_market(ohlcv, short_ema=20, long_ema=50, atr_period=14, atr_threshold=0.01):
    closes = [candle[4] for candle in ohlcv]
    highs = [candle[2] for candle in ohlcv]
    lows = [candle[3] for candle in ohlcv]

    ema_short = calculate_ema(closes, short_ema)[-1]
    ema_long = calculate_ema(closes, long_ema)[-1]
    atr = calculate_atr(highs, lows, closes, atr_period)[-1]

    # Verhältnis ATR zu aktuellem Preis → Volatilität
    current_price = closes[-1]
    volatility_ratio = atr / current_price

    # Klassifizierung
    if ema_short > ema_long * 1.01:
        if volatility_ratio > atr_threshold:
            return "trend_bullish"
        else:
            return "bullish_sideways"
    elif ema_short < ema_long * 0.99:
        if volatility_ratio > atr_threshold:
            return "trend_bearish"
        else:
            return "bearish_sideways"
    elif volatility_ratio > atr_threshold * 1.5:
        return "volatile"
    else:
        return "sideways"



### FILE: ./utils/risk_manager.py
# utils/risk_manager.py

class RiskManager:
    def __init__(self, initial_balance: float = 20.0, max_risk_per_trade: float = 0.02):
        self.balance = initial_balance
        self.risk_pct = max_risk_per_trade  # z. B. 2 %

    def update_balance(self, new_balance: float):
        self.balance = new_balance

    def calculate_position_size(self, entry_price: float, stop_loss: float) -> float:
        sl_distance = abs(entry_price - stop_loss)
        if sl_distance == 0:
            return 0.0  # keine sinnvolle Positionsgröße möglich
        risk_amount = self.balance * self.risk_pct
        qty = risk_amount / sl_distance
        return round(qty, 6)



### FILE: ./utils/signal_filter.py
# utils/signal_filter.py

from strategies.indicators import calculate_ema, calculate_atr

class SignalFilter:
    def __init__(self, volume_factor=1.2, atr_threshold=0.001, trend_strength=0.001):
        self.volume_factor = volume_factor       # z. B. 1.2x über 10er-Avg
        self.atr_threshold = atr_threshold       # z. B. mind. 0.1 % Bewegung
        self.trend_strength = trend_strength     # z. B. Preisabstand zu EMA20 > 0.1 %

    def passes_filters(self, ohlcv) -> bool:
        closes = [c[4] for c in ohlcv]
        highs = [c[2] for c in ohlcv]
        lows = [c[3] for c in ohlcv]
        volumes = [c[5] for c in ohlcv]

        # Trend-Erkennung
        ema = calculate_ema(closes, 20)[-1]
        price = closes[-1]
        trend_diff = abs(price - ema) / ema
        if trend_diff < self.trend_strength:
            return False  # Kein klarer Trend

        # Volumen-Filter
        avg_vol = sum(volumes[-11:-1]) / 10
        if volumes[-1] < avg_vol * self.volume_factor:
            return False  # Kein Volumenimpuls

        # ATR-basierte Volatilitätsprüfung
        atr = calculate_atr(ohlcv, 14)[-1]
        if atr / price < self.atr_threshold:
            return False  # Markt zu ruhig

        return True  # Alles passt



### FILE: ./utils/strategy_watchdog.py
# utils/strategy_watchdog.py

import csv
import os
from datetime import datetime
from collections import defaultdict

WATCHDOG_FILE = "strategy_watchdog.csv"

class StrategyWatchdog:
    def __init__(self):
        self.stats = defaultdict(lambda: {"trades": 0, "wins": 0, "losses": 0})
        self._load_existing()

    def _load_existing(self):
        if not os.path.isfile(WATCHDOG_FILE):
            return
        with open(WATCHDOG_FILE, mode="r") as f:
            reader = csv.DictReader(f)
            for row in reader:
                strat = row["strategy"]
                self.stats[strat] = {
                    "trades": int(row["trades"]),
                    "wins": int(row["wins"]),
                    "losses": int(row["losses"])
                }

    def record_trade(self, strategy_name: str, pnl: float):
        stat = self.stats[strategy_name]
        stat["trades"] += 1
        if pnl > 0:
            stat["wins"] += 1
        else:
            stat["losses"] += 1
        self._save()

    def _save(self):
        with open(WATCHDOG_FILE, mode="w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["strategy", "trades", "wins", "losses"])
            for strat, s in self.stats.items():
                writer.writerow([strat, s["trades"], s["wins"], s["losses"]])



### FILE: ./utils/trade_logger.py
# utils/trade_logger.py

import csv
import os
from datetime import datetime

TRADE_LOG_FILE = "paper_trades.csv"

def log_trade(symbol, side, entry_price, sl, tp, qty, pnl=None, strategy=None):
    file_exists = os.path.isfile(TRADE_LOG_FILE)
    with open(TRADE_LOG_FILE, mode='a', newline='') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow([
                "timestamp", "symbol", "side", "entry_price",
                "stop_loss", "take_profit", "qty", "pnl"
            ])
        writer.writerow([
	    datetime.utcnow().isoformat(), symbol, side, entry_price,
    	sl, tp, qty, pnl if pnl is not None else "", strategy or ""
	])



### FILE: ./utils/trade_tracker.py
import pandas as pd
from datetime import datetime
from utils.trade_logger import log_trade

def update_trade_pnls(csv_file="paper_trades.csv", current_prices=None):
    expected_cols = ["time", "symbol", "side", "entry_price", "stop_loss", "take_profit", "qty", "pnl", "strategy"]
    df = pd.read_csv(csv_file, names=expected_cols, header=0)

    # Fehlende Spalten ergänzen (alte Zeilen/alte CSV)
    for col in expected_cols:
        if col not in df.columns:
            df[col] = None

    updated = False

    for idx, row in df[df["pnl"].isna()].iterrows():
        symbol = row["symbol"]
        price = current_prices.get(symbol)
        if price is None:
            continue

        side = row["side"]
        entry = row["entry_price"]
        sl = row["stop_loss"]
        tp = row["take_profit"]
        qty = row["qty"]

        pnl = None
        # Prüfen, ob SL oder TP erreicht wurde
        if side == "BUY" and (price <= sl or price >= tp):
            pnl = (price - entry) * qty
        elif side == "SELL" and (price >= sl or price <= tp):
            pnl = (entry - price) * qty

        # Nur wenn Trade geschlossen wurde:
        if pnl is not None:
            df.at[idx, "pnl"] = pnl
            updated = True

            # Optional: Watchdog informieren, falls Strategie geloggt wurde
            strategy_name = row.get("strategy", "Unknown")
            try:
                from utils.strategy_watchdog import StrategyWatchdog
                StrategyWatchdog().record_trade(strategy_name=strategy_name, pnl=pnl)
            except Exception as e:
                print(f"[Watchdog] Fehler bei Strategie-Tracking: {e}")

    if updated:
        df.to_csv(csv_file, index=False)



### FILE: 



### FILE: 



### FILE: ./bot.py
#!/usr/bin/env python3
# bot.py — Version 1.0.1

import os
import asyncio
from dotenv import load_dotenv
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from utils.backtester import Backtester
from utils.logger import logger

__version__ = "1.0.1"

def load_config():
    load_dotenv()
    return {
        "api_key": os.getenv("BINANCE_API_KEY"),
        "api_secret": os.getenv("BINANCE_API_SECRET"),
        "testnet": os.getenv("USE_TESTNET", "True").lower() == "true",
        "symbol": os.getenv("SYMBOL", "BTCUSDC"),
        "backtest_start": os.getenv("BACKTEST_START", "2025-01-01T00:00"),
        "backtest_end": os.getenv("BACKTEST_END", "2025-06-01T00:00"),
        "granularity": os.getenv("GRANULARITY", "1h"),
        "initial_balance": float(os.getenv("INITIAL_BALANCE", "20.0")),
        "trade_quantity": float(os.getenv("TRADE_QUANTITY", "0.001")),
        "paper_trading": os.getenv("PAPER_TRADING", "True").lower() == "true",
        "atr_period": int(os.getenv("ATR_PERIOD", "14")),
        "sl_multiplier": float(os.getenv("SL_MULTIPLIER", "1.5")),
        "tp_multiplier": float(os.getenv("TP_MULTIPLIER", "3.0")),
        "martingale_factor": float(os.getenv("MARTINGALE_FACTOR", "1.0")),
    }

async def main():
    cfg = load_config()
    logger.info(f"🚀 Starting Grok-FuturesBot v{__version__}")

    # 1) Backtest
    logger.info("🔍 Running backtest…")
    bt = Backtester(
        symbol=cfg["symbol"],
        start=cfg["backtest_start"],
        end=cfg["backtest_end"],
        granularity=cfg["granularity"],
        initial_balance=cfg["initial_balance"],
    )
    await bt.run()

    # 2) Live-/Paper-Trading Beispiel
    logger.info("💡 Starting live/paper trading example…")
    client = await BinanceClient.create(
        api_key=cfg["api_key"],
        api_secret=cfg["api_secret"],
        testnet=cfg["testnet"],
    )
    executor = TradeExecutor(client)
    result = await executor.execute_trade(
        symbol=cfg["symbol"],
        side="BUY",
        quantity=cfg["trade_quantity"],
        atr_period=cfg["atr_period"],
        sl_multiplier=cfg["sl_multiplier"],
        tp_multiplier=cfg["tp_multiplier"],
        martingale_factor=cfg["martingale_factor"],
        paper=cfg["paper_trading"],
    )
    logger.info(
        f"🎯 Trade result (paper={cfg['paper_trading']}): Entry={result['entry_price']}, SL={result['sl_price']}, TP={result['tp_price']}"
    )

if __name__ == "__main__":
    asyncio.run(main())



### FILE: ./core/client.py
# core/client.py — Version 1.0.2

import asyncio
import ccxt.async_support as ccxt
from binance import AsyncClient
from utils.logger import logger

class BinanceClient:
    def __init__(self, client: AsyncClient):
        self.client = client

    @classmethod
    async def create(cls, api_key: str, api_secret: str, testnet: bool = False):
        logger.info(f"🔌 Verbinde mit Binance (testnet={testnet})...")
        client = await AsyncClient.create(
            api_key=api_key,
            api_secret=api_secret,
            testnet=testnet
        )
        return cls(client)

    async def get_futures_price(self, symbol: str) -> float:
        ticker = await self.client.futures_symbol_ticker(symbol=symbol)
        return float(ticker["price"])

    async def fetch_ohlcv(self, symbol: str, timeframe: str, since: int = None, limit: int = None, until: int = None):
        exchange = ccxt.binance({
            'enableRateLimit': True,
            'options': {
                'defaultType': 'future'
            }
        })
        if since and until:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since)
            ohlcv = [c for c in ohlcv if c[0] <= until]
        else:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
        await exchange.close()
        return ohlcv

    async def futures_change_leverage(self, symbol: str, leverage: int):
        """
        Setzt das Leverage für ein Futures-Symbol.
        """
        try:
            result = await self.client.futures_change_leverage(symbol=symbol, leverage=leverage)
            logger.info(f"[LEVERAGE] {symbol}: Leverage wurde auf {leverage}x gesetzt. Antwort: {result}")
            return result
        except Exception as e:
            logger.error(f"[LEVERAGE] Fehler beim Setzen des Leverage für {symbol}: {e}")
            raise

    async def close(self):
        await self.client.close_connection()



### FILE: ./core/strategy_engine.old.py
from strategies.RSI_ema import ema_rsi_signal
from strategies.breakouts import breakout_signal
from strategies.reversal import reversal_signal
from strategies.range_trading import range_trading_signal
from utils.market_classifier import classify_market
from utils.volatility import calculate_volatility

class StrategyEngine:
    def __init__(self):
        pass

    def choose_strategy(self, ohlcv):
        market_state = classify_market(ohlcv)
        volatility = calculate_volatility(ohlcv)
        
        if market_state == "trend_bullish":
            return breakout_signal, market_state
        elif market_state == "trend_bearish":
            return reversal_signal, market_state
        elif market_state == "sideways":
            return range_trading_signal, market_state
        elif market_state == "volatile":
            return breakout_signal, market_state
        else:
            return None, market_state

    def get_signal(self, ohlcv):
        strategy, market_state = self.choose_strategy(ohlcv)
        if strategy:
            return strategy(ohlcv), market_state
        return None, market_state



### FILE: ./core/trade_executor.py
from utils.logger import logger
from strategies.indicators import calculate_atr
from binance.enums import *

SIDE_Buy = "Buy"

class TradeExecutor:
    def __init__(self, client, base_currency: str = "USDC"):
        self.client = client
        self.base_currency = base_currency

    async def execute_trade(
        self,
        symbol: str,
        side: str,
        quantity: float,
        sl: float = None,
        tp: float = None,
        atr_period: int = 14,
        sl_multiplier: float = 1.5,
        tp_multiplier: float = 3.0,
        martingale_factor: float = 1.0,
        paper: bool = True
    ):
        qty = quantity * martingale_factor
        logger.info(f"Placing {side} order for {symbol} qty={qty:.6f} (martingale={martingale_factor})")

        # Preis ermitteln
        if paper:
            price = await self.client.get_futures_price(symbol)
            logger.info(f"(Paper) Order simulated at {price}")
        else:
            order = await self.client.client.futures_create_order(
                symbol=symbol,
                side=side,
                type=FUTURE_ORDER_TYPE_MARKET,
                quantity=qty
            )
            price = float(order["avgPrice"])
            logger.info(f"Order executed at price={price}")

        # SL/TP berechnen wenn nicht manuell übergeben
        if sl is None or tp is None:
            ohlcv = await self.client.fetch_ohlcv(symbol, timeframe='1h', limit=atr_period + 1)
            atr = calculate_atr(ohlcv, period=atr_period)
            sl, tp = self._compute_sl_tp(price, atr, side, sl_multiplier, tp_multiplier)

        return {
            "entry_price": price,
            "sl_price": sl,
            "tp_price": tp,
            "qty": qty
        }

    def _compute_sl_tp(self, entry: float, atr: float, side: str,
                       sl_mult: float, tp_mult: float):
        if side == SIDE_BUY:
            sl = entry - atr * sl_mult
            tp = entry + atr * tp_mult
        else:
            sl = entry + atr * sl_mult
            tp = entry - atr * tp_mult
        return sl, tp



### FILE: ./dashboard/app.py
from flask import Flask, render_template, send_file
import os
import sys
import pandas as pd
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.equity_plot import plot_equity_curve
from utils.trade_logger import log_trade 
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

app = Flask(__name__)

@app.route("/")
def index():
    # Equity-Kurve aktualisieren
    plot_equity_curve(CSV_PATH, "dashboard/static/equity_curve.png")

    # Daten aus CSV laden
    df = pd.read_csv(CSV_PATH)
    df_closed = df[df["pnl"].notna()]
    balance = 20.0 + df_closed["pnl"].sum()
    winrate = (df_closed["pnl"] > 0).mean() * 100 if not df_closed.empty else 0

    return render_template("index.html", 
        balance=round(balance, 2),
        total_trades=len(df),
        winrate=round(winrate, 1),
        trades=df.tail(10).to_dict(orient="records")
    )

@app.route("/chart")
def chart():
    return send_file("static/equity_curve.png", mimetype='image/png')

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)



### FILE: ./ml/analyze_backtest.py
import pandas as pd
import matplotlib.pyplot as plt
import sys
import os

# CSV-Datei übergeben, sonst Standardpfad
CSV = sys.argv[1] if len(sys.argv) > 1 else "ml/backtest_results.csv"

if not os.path.isfile(CSV):
    print(f"Datei nicht gefunden: {CSV}")
    sys.exit(1)

df = pd.read_csv(CSV)
print(f"Analysiere {len(df)} Trades aus {CSV}")

# Equity-Kurve erzeugen
df = df.sort_values("timestamp")
df["cum_pnl"] = df["pnl"].cumsum()
plt.figure(figsize=(12,6))
plt.plot(df["timestamp"], df["cum_pnl"], label="Equity Curve")
plt.xlabel("Timestamp")
plt.ylabel("Kumuliertes Ergebnis")
plt.title("Equity Curve (Backtest)")
plt.grid()
plt.tight_layout()
plt.savefig("ml/equity_curve_backtest.png")
print("Equity Curve gespeichert als ml/equity_curve_backtest.png")

# Metriken je Strategie
strategies = df["strategy"].unique()
summary = []
for strat in strategies:
    sub = df[df["strategy"] == strat]
    trades = len(sub)
    wins = (sub["pnl"] > 0).sum()
    winrate = wins / trades * 100 if trades > 0 else 0
    total_pnl = sub["pnl"].sum()
    avg_pnl = sub["pnl"].mean()
    max_dd = (sub["cum_pnl"].cummax() - sub["cum_pnl"]).max()
    summary.append([strat, trades, wins, winrate, total_pnl, avg_pnl, max_dd])

summary_df = pd.DataFrame(summary, columns=["Strategie", "Trades", "Wins", "Winrate %", "Gesamt-PnL", "Ø PnL", "Max Drawdown"])
print("\n==== Strategien-Auswertung ====")
print(summary_df.sort_values("Gesamt-PnL", ascending=False))

# Optional: Heatmap Symbol vs. Strategie
if "symbol" in df.columns:
    pivot = df.pivot_table(index="strategy", columns="symbol", values="pnl", aggfunc="sum")
    plt.figure(figsize=(10, 6))
    import seaborn as sns
    sns.heatmap(pivot, annot=True, fmt=".2f", cmap="RdYlGn")
    plt.title("Profit Heatmap: Strategie vs. Symbol")
    plt.tight_layout()
    plt.savefig("ml/heatmap_backtest.png")
    print("Heatmap gespeichert als ml/heatmap_backtest.png")



### FILE: ./ml/backtest_data_import.py
import os
import csv
import time
from datetime import datetime
import ccxt
from tqdm import tqdm
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from strategies.indicators import calculate_ema, calculate_rsi, calculate_atr, calculate_bollinger_bands
from strategies.engine import StrategyEngine

# Konfiguration
EXCHANGE = ccxt.binance({
    'rateLimit': 1200,
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})

OUTPUT_FILE = "ml/training_data_backtest.csv"
SYMBOLS = ["BTC/USDC", "ETH/USDC", "SOL/USDC"]  # Beliebig erweiterbar
TIMEFRAME = "1h"
START_DATE = "2024-01-01T00:00:00Z"  # YYYY-MM-DDTHH:MM:SSZ
END_DATE = "2024-06-30T00:00:00Z"

# Helper
def parse_iso8601(date_str):
    return int(EXCHANGE.parse8601(date_str))

def ohlcv_to_dict(symbol, ohlcv, strategy, market_state):
    # ohlcv: [timestamp, open, high, low, close, volume]
    close = float(ohlcv[4])
    ema = calculate_ema([ohlcv], 1)     # Für Einzelkerze = Kerzenwert
    rsi = calculate_rsi([ohlcv], 1)
    atr = calculate_atr([ohlcv], 1)
    bb_upper, bb_lower = calculate_bollinger_bands([ohlcv], 1)
    return {
        "timestamp": datetime.utcfromtimestamp(ohlcv[0]/1000).isoformat(),
        "symbol": symbol,
        "open": ohlcv[1],
        "high": ohlcv[2],
        "low": ohlcv[3],
        "close": ohlcv[4],
        "volume": ohlcv[5],
        "ema": ema,
        "rsi": rsi,
        "atr": atr,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "market_state": market_state,
        "strategy": strategy,
        "signal": "",    # Noch leer (optional für späteren Backtest/ML-Label)
        "result": ""
    }

def fetch_all_ohlcv(symbol, timeframe, since, until):
    all_candles = []
    limit = 1000
    now = since
    pbar = tqdm(desc=f"Lade {symbol}", total=(until-since)//(60*60*1000))
    while now < until:
        candles = EXCHANGE.fetch_ohlcv(symbol, timeframe, since=now, limit=limit)
        if not candles:
            break
        for c in candles:
            if c[0] > until:
                break
            all_candles.append(c)
        now = candles[-1][0] + 1
        pbar.update(len(candles))
        time.sleep(0.1)
    pbar.close()
    return all_candles

def main():
    # Setup
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, "w", newline='') as f:
        fieldnames = [
            "timestamp", "symbol", "open", "high", "low", "close", "volume",
            "ema", "rsi", "atr", "bb_upper", "bb_lower",
            "market_state", "strategy", "signal", "result"
        ]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()

        engine = StrategyEngine()
        for symbol in SYMBOLS:
            since = parse_iso8601(START_DATE)
            until = parse_iso8601(END_DATE)
            ohlcv_data = fetch_all_ohlcv(symbol, TIMEFRAME, since, until)
            # Sliding-Window für Indikatoren und Strategieauswahl:
            window = []
            for row in tqdm(ohlcv_data, desc=f"Verarbeite {symbol}"):
                window.append(row)
                if len(window) > 50:
                    window = window[-50:]  # nur die letzten 50 Kerzen
                # Marktzustand und Strategie wählen:
                market_state = engine.evaluate_market(window) if len(window) >= 20 else ""
                strategy = engine.select_strategy(window).__class__.__name__ if len(window) >= 20 else ""
                writer.writerow(
                    ohlcv_to_dict(symbol, row, strategy, market_state)
                )

if __name__ == "__main__":
    main()



### FILE: ./ml/backtest_engine.py
import sys
import os
import asyncio
import pandas as pd

# Damit die Importe klappen, egal von wo du startest:
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import ccxt.async_support as ccxt

from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr, calculate_bollinger_bands
from strategies.rsi_ema import RSIEMAStrategy
from strategies.momentum import MomentumStrategy
from strategies.volatility import VolatilityStrategy
from strategies.breakout import BreakoutStrategy
from strategies.reversal import ReversalStrategy

STRATEGIES = [
    ("rsi_ema", RSIEMAStrategy()),
    ("momentum", MomentumStrategy()),
    ("volatility", VolatilityStrategy()),
    ("breakout", BreakoutStrategy()),
    ("reversal", ReversalStrategy())
]

async def fetch_ohlcv_ccxt(symbol, timeframe="1h", since=None, limit=1000):
    exchange = ccxt.binance({
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })
    ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
    await exchange.close()
    return ohlcv

def simulate_trade(entry, side, sl, tp, ohlcv_next):
    for row in ohlcv_next:
        price = float(row[4])
        if side == "BUY":
            if price <= sl:
                return sl, (sl - entry)
            elif price >= tp:
                return tp, (tp - entry)
        elif side == "SELL":
            if price >= sl:
                return sl, (entry - sl)
            elif price <= tp:
                return tp, (entry - tp)
    return price, (price - entry) if side == "BUY" else (entry - price)

def run_backtest(symbol, ohlcv, out_csv="ml/backtest_results.csv", lookahead=10):
    results = []
    for i in range(50, len(ohlcv) - lookahead):
        sub_ohlcv = ohlcv[:i]
        future_ohlcv = ohlcv[i:i+lookahead]
        price = float(ohlcv[i][4])
        atr = calculate_atr(sub_ohlcv, 14)
        for strat_name, strat in STRATEGIES:
            signal = strat.generate_signal(sub_ohlcv)
            if signal:
                sl, tp = strat.sl_tp(price, atr)
                exit_price, pnl = simulate_trade(price, signal, sl, tp, future_ohlcv)
                results.append({
                    "timestamp": ohlcv[i][0],
                    "symbol": symbol,
                    "strategy": strat_name,
                    "side": signal,
                    "entry": price,
                    "sl": sl,
                    "tp": tp,
                    "exit": exit_price,
                    "pnl": pnl
                })
                
    out_dir = os.path.dirname(out_csv)
    if out_dir and not os.path.exists(out_dir):
        os.makedirs(out_dir)
            
    pd.DataFrame(results).to_csv(out_csv, index=False)
    print(f"Backtest für {symbol} abgeschlossen – {len(results)} Trades.")

async def main(symbol="BTCUSDT", timeframe="1h", candles=1000, out_csv="ml/backtest_results.csv"):
    print(f"Lade OHLCV für {symbol}, Intervall {timeframe}, Anzahl {candles} ...")
    ohlcv = await fetch_ohlcv_ccxt(symbol, timeframe=timeframe, limit=candles)
    run_backtest(symbol, ohlcv, out_csv=out_csv)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--symbol", default="BTCUSDT", help="Symbol, z.B. BTCUSDT")
    parser.add_argument("--timeframe", default="1h", help="Kerzenintervall, z.B. 1h, 15m, 5m")
    parser.add_argument("--candles", type=int, default=1000, help="Anzahl Kerzen")
    parser.add_argument("--out", default="ml/backtest_results.csv", help="Ziel-Datei")
    args = parser.parse_args()
    asyncio.run(main(symbol=args.symbol, timeframe=args.timeframe, candles=args.candles, out_csv=args.out))



### FILE: ./ml/collect_training_data.py
import os
import csv
from datetime import datetime

TRAINING_CSV = "ml/training_data.csv"

# Stelle sicher, dass der Ordner existiert
os.makedirs(os.path.dirname(TRAINING_CSV), exist_ok=True)

def append_training_data(
    timestamp, symbol, open_, high, low, close, volume,
    rsi, ema, atr, bb_upper, bb_lower,
    market_state, strategy, signal, result=None
):
    header = [
        "timestamp", "symbol", "open", "high", "low", "close", "volume",
        "rsi", "ema", "atr", "bb_upper", "bb_lower",
        "market_state", "strategy", "signal", "result"
    ]

    row = [
        timestamp, symbol, open_, high, low, close, volume,
        rsi, ema, atr, bb_upper, bb_lower,
        market_state, strategy, signal, result
    ]

    file_exists = os.path.isfile(TRAINING_CSV)

    with open(TRAINING_CSV, mode="a", newline="") as f:
        writer = csv.writer(f)
        if not file_exists:
            writer.writerow(header)
        writer.writerow(row)

# Beispiel-Aufruf (kann überall im Bot platziert werden):
if __name__ == "__main__":
    # Dummy-Daten zum Testen
    append_training_data(
        timestamp=datetime.utcnow().isoformat(),
        symbol="BTCUSDC",
        open_=30000, high=30500, low=29900, close=30200, volume=1000,
        rsi=55, ema=30150, atr=150, bb_upper=30400, bb_lower=29800,
        market_state="trend", strategy="BreakoutStrategy", signal="BUY", result=1.2
    )
    print(f"Testdatensatz geschrieben nach {TRAINING_CSV}")



### FILE: ./multi_backtest.py
import asyncio
from utils.backtester import Backtester

symbol_list = ["BTCUSDC", "ETHUSDC", "BNBUSDC", "SOLUSDC"]
start = "2025-01-01T00:00"
end = "2025-06-01T00:00"
granularity = "1h"
initial_balance = 20.0

async def run_backtests():
    tasks = []
    for symbol in symbol_list:
        bt = Backtester(
            symbol=symbol,
            start=start,
            end=end,
            granularity=granularity,
            initial_balance=initial_balance
        )
        tasks.append(bt.run())
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(run_backtests())



### FILE: ./paper_loop.py
import os
import sys
import asyncio
from dotenv import load_dotenv
from datetime import datetime
import aiohttp

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.engine import StrategyEngine
from strategies.indicators import calculate_atr, calculate_ema, calculate_rsi, calculate_bollinger_bands
from utils.logger import logger
from utils.trade_logger import log_trade
from utils.trade_tracker import update_trade_pnls
from utils.risk_manager import RiskManager
from utils.cooldown_manager import CooldownManager
from utils.signal_filter import SignalFilter
from utils.drawdown_guard import DrawdownGuard
from utils.strategy_watchdog import StrategyWatchdog

# Neu: ML-Collector
from ml.collect_training_data import append_training_data

# Einstellungen
load_dotenv()
PAPER = True
INTERVAL = 10  # Schnelleres Intervall für mehr Datensätze & Trades!
START_BALANCE = 20.0
SYMBOLS = []

# Bot-Komponenten
engine = StrategyEngine()
risk_manager = RiskManager(initial_balance=START_BALANCE, max_risk_per_trade=0.02)
cooldown = CooldownManager(cooldown_minutes=30)
signal_filter = SignalFilter()
drawdown_guard = DrawdownGuard(start_balance=START_BALANCE, max_loss_pct=5.0)
watchdog = StrategyWatchdog()

# Abruf der Top 100 USDC-Futures-Paare nach Volumen
async def get_top_usdc_symbols_by_volume(limit=100):
    url = "https://fapi.binance.com/fapi/v1/ticker/24hr"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
            filtered = [
                d for d in data if d["symbol"].endswith("USDC") and float(d["quoteVolume"]) > 100000
            ]
            sorted_pairs = sorted(filtered, key=lambda x: float(x["quoteVolume"]), reverse=True)
            return [item["symbol"] for item in sorted_pairs[:limit]]

# Hauptloop
async def trade_task(symbol, client, executor):
    try:
        ohlcv = await client.fetch_ohlcv(symbol, "1h", limit=50)
        closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
        price = closes[-1]
        atr = calculate_atr(ohlcv, 14)
        ema = calculate_ema(ohlcv, 50)
        rsi = calculate_rsi(ohlcv, 14)
        bb_upper, bb_lower = calculate_bollinger_bands(ohlcv, 20, 2)

        strategy = engine.select_strategy(ohlcv)
        signal = strategy.generate_signal(ohlcv)
        market_state = engine.evaluate_market(ohlcv)

        # ML-Datensammlung: Immer protokollieren (auch wenn kein Trade ausgelöst wird)
        append_training_data(
            timestamp=datetime.utcnow().isoformat(),
            symbol=symbol,
            open_=ohlcv[-1][1],
            high=ohlcv[-1][2],
            low=ohlcv[-1][3],
            close=ohlcv[-1][4],
            volume=ohlcv[-1][5],
            rsi=rsi,
            ema=ema,
            atr=atr,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            market_state=market_state,
            strategy=strategy.__class__.__name__,
            signal=signal,
            result=None
        )

        if not signal:
            logger.info(f"[FILTER] {symbol}: Kein Signal.")
            return

        if cooldown.is_in_cooldown(symbol):
            logger.info(f"[COOLDOWN] {symbol}: aktiv – übersprungen.")
            return

        if not signal_filter.passes_filters(ohlcv):
            logger.info(f"[FILTER] {symbol}: Markt ungeeignet.")
            return

        sl, tp = strategy.sl_tp(price, atr)
        qty = risk_manager.calculate_position_size(entry_price=price, stop_loss=sl)

        if qty <= 0:
            logger.warning(f"[RISK] {symbol}: Ordergröße zu klein – übersprungen.")
            return

        logger.info(f"[TRADE] {symbol}: {signal} @ {price:.2f} SL={sl:.2f} TP={tp:.2f} QTY={qty:.4f}")

        result = await executor.execute_trade(
            symbol=symbol,
            side=signal,
            quantity=qty,
            sl=sl,
            tp=tp,
            paper=PAPER
        )

        # Log für Trade
        log_trade(
            symbol=symbol,
            side=signal,
            entry_price=result["entry_price"],
            sl=sl,
            tp=tp,
            qty=qty,
            strategy=strategy.__class__.__name__
        )

        cooldown.update_cooldown(symbol)

        # ML-Log mit Ergebnis
        append_training_data(
            timestamp=datetime.utcnow().isoformat(),
            symbol=symbol,
            open_=ohlcv[-1][1],
            high=ohlcv[-1][2],
            low=ohlcv[-1][3],
            close=ohlcv[-1][4],
            volume=ohlcv[-1][5],
            rsi=rsi,
            ema=ema,
            atr=atr,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            market_state=market_state,
            strategy=strategy.__class__.__name__,
            signal=signal,
            result=result.get("pnl") if result else None
        )

    except Exception as e:
        logger.error(f"[{symbol}] Fehler im Loop: {e}")

async def trade_loop():
    global SYMBOLS
    client = await BinanceClient.create(
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
        testnet=os.getenv("USE_TESTNET", "True").lower() == "true"
    )
    executor = TradeExecutor(client)

    SYMBOLS = await get_top_usdc_symbols_by_volume(limit=25)  # Bei RAM-Engpässen hier verringern!

    logger.info(f"📊 Überwachte Paare: {', '.join(SYMBOLS[:10])} ...")

    try:
        while True:
            if drawdown_guard.loss_today_exceeded():
                logger.warning("🛑 Tagesverlustgrenze erreicht – Trading pausiert.")
                await asyncio.sleep(INTERVAL)
                continue

            tasks = [trade_task(symbol, client, executor) for symbol in SYMBOLS]
            await asyncio.gather(*tasks)

            try:
                current_prices = {symbol: await client.get_futures_price(symbol) for symbol in SYMBOLS}
                update_trade_pnls(current_prices=current_prices)
            except Exception as e:
                logger.warning(f"[PnL] Preisabruf fehlgeschlagen: {e}")

            logger.info(f"⏳ Nächster Zyklus in {INTERVAL} Sekunden...\n")
            await asyncio.sleep(INTERVAL)

    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(trade_loop())



### FILE: ./strategies/breakout.py
from strategies.indicators import calculate_atr

class BreakoutStrategy:
    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        highs = [row[2] for row in ohlcv[-21:]]
        lows = [row[3] for row in ohlcv[-21:]]
        price = closes[-1]

        # Buy-Breakout: schließt über dem lokalen Hoch der letzten 20 Kerzen, mit Volumenfilter
        if price > max(highs[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "BUY"
        # Sell-Breakout: schließt unter dem lokalen Tief der letzten 20 Kerzen
        elif price < min(lows[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "SELL"
        else:
            return None

    def sl_tp(self, price, atr):
        # Aggressiver SL/TP für echte Ausbrüche!
        sl = price - 2.0 * atr
        tp = price + 4.0 * atr
        return sl, tp

    def score(self, ohlcv, market_type):
        # Perfekt in klaren Trendphasen!
        if market_type == "trend":
            return 2
        return 0



### FILE: ./strategies/engine.py
from strategies.rsi_ema import RSIEMAStrategy
from strategies.breakout import BreakoutStrategy
from strategies.momentum import MomentumStrategy
from strategies.reversal import ReversalStrategy

class StrategyEngine:
    def __init__(self):
        self.strategies = [
            RSIEMAStrategy(),
            BreakoutStrategy(),
            MomentumStrategy(),
            ReversalStrategy(),
        ]

    def evaluate_market(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        change = abs(closes[-1] - closes[-20]) / closes[-20]
        if change > 0.02:
            return "trend"
        return "sideways"

    def select_strategy(self, ohlcv):
        market = self.evaluate_market(ohlcv)
        for strategy in self.strategies:
            if hasattr(strategy, "suits") and strategy.suits(market):
                return strategy
        return self.strategies[0]


### FILE: ./strategies/futures_ema_rsi.py
# strategies/futures_ema_rsi.py

"""
EMA & RSI-basierte Futures-Strategie mit ATR-SL/TP
"""
import numpy as np
import pandas as pd
from utils.logger import logger
from utils.indicators import EMA, RSI, ATR

class EMARSI_Strategy:
def **init**(self, client, symbols, interval, leverage, risk\_per\_trade):
self.client = client
self.symbols = symbols
self.interval = interval
self.leverage = leverage
self.risk_per_trade = risk_per_trade

```
async def check_signal(self, symbol):
    data = await self.client.fetch_ohlcv(symbol, self.interval)
    df = pd.DataFrame(data, columns=['timestamp','open','high','low','close','volume'])

    ema_fast = calculate_ema(df['close'], period=10)
    ema_slow = calculate_ema(df['close'], period=20)
    rsi = calculate_rsi(df['close'], period=14)

    if ema_fast.iloc[-1] > ema_slow.iloc[-1] and rsi.iloc[-1] < 30:
        logger.info(f"Long signal für {symbol}")
        return 'LONG'
    if ema_fast.iloc[-1] < ema_slow.iloc[-1] and rsi.iloc[-1] > 70:
        logger.info(f"Short signal für {symbol}")
        return 'SHORT'
    return None

async def execute_trade(self, symbol, signal):
    # Positionsgröße berechnen
    balance = await self.client.fetch_balance()
    available = balance['total']['USDC']
    amount = (available * self.risk_per_trade) / price  # Preis muss aus DataFrame
    side = 'buy' if signal == 'LONG' else 'sell'
    order = await self.client.create_order(symbol, side, amount)
    if order:
        logger.info(f"Order ausgeführt: {order}")
```



### FILE: ./strategies/indicators.py
import numpy as np

def calculate_rsi(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period + 1:
        return 50.0
    deltas = np.diff(closes)
    gain = np.where(deltas > 0, deltas, 0).sum() / period
    loss = -np.where(deltas < 0, deltas, 0).sum() / period
    if loss == 0:
        return 100.0
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_ema(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return closes[-1] if closes else 0.0
    ema = np.mean(closes[-period:])
    multiplier = 2 / (period + 1)
    for price in closes[-period:]:
        ema = (price - ema) * multiplier + ema
    return ema

def calculate_atr(ohlcv, period=14):
    if len(ohlcv) < period + 1:
        return 0.0
    high = [float(row[2]) for row in ohlcv]
    low = [float(row[3]) for row in ohlcv]
    close = [float(row[4]) for row in ohlcv]
    tr = []
    for i in range(1, len(ohlcv)):
        tr.append(max(
            high[i] - low[i],
            abs(high[i] - close[i-1]),
            abs(low[i] - close[i-1])
        ))
    if len(tr) < period:
        return np.mean(tr) if tr else 0.0
    atr = np.mean(tr[-period:])
    return atr

def calculate_bollinger_bands(ohlcv, period=20, multiplier=2):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return (0.0, 0.0)
    moving_avg = np.mean(closes[-period:])
    std_dev = np.std(closes[-period:])
    upper_band = moving_avg + (std_dev * multiplier)
    lower_band = moving_avg - (std_dev * multiplier)
    return upper_band, lower_band



### FILE: ./strategies/momentum.py
class MomentumStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "trend"

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        momentum = closes[-1] - closes[-10]
        if momentum > 0:
            return "BUY"
        elif momentum < 0:
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.2 * atr
        tp = price + 2.0 * atr
        return sl, tp


### FILE: ./strategies/reversal.py
from strategies.indicators import calculate_rsi

class ReversalStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        rsi = calculate_rsi(ohlcv, 14)
        if rsi > 75:
            return "SELL"
        elif rsi < 25:
            return "BUY"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.3 * atr
        tp = price + 2.2 * atr
        return sl, tp


### FILE: ./strategies/rsi_ema.py
from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr

class RSIEMAStrategy:
    def __init__(self, rsi_period=14, ema_period=50):
        self.rsi_period = rsi_period
        self.ema_period = ema_period

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        rsi = calculate_rsi(ohlcv, self.rsi_period)
        ema = calculate_ema(ohlcv, self.ema_period)
        price = closes[-1]

        # Long wenn RSI unter 32 UND über EMA (bullisher Dip)
        if rsi < 32 and price > ema:
            return "BUY"
        # Short wenn RSI über 68 UND unter EMA (bearisher Spike)
        elif rsi > 68 and price < ema:
            return "SELL"
        else:
            return None

    def sl_tp(self, price, atr):
        sl = price - 1.5 * atr
        tp = price + 3.5 * atr
        return sl, tp

    def score(self, ohlcv, market_type):
        # Sehr gut in trendarmen oder schwankenden Märkten
        if market_type == "sideways":
            return 1
        return 0



### FILE: ./strategies/volatility.py
from strategies.indicators import calculate_atr, calculate_ema

class VolatilityStrategy:
    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        atr = calculate_atr(ohlcv, 14)
        ema50 = calculate_ema(ohlcv, 50)
        price = closes[-1]
        # Nur traden, wenn ATR sehr hoch (volatiler Markt)
        if atr > price * 0.02:  # >2% Schwankung auf 14h
            if price > ema50:
                return "BUY"
            elif price < ema50:
                return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 2.5 * atr
        tp = price + 5.0 * atr
        return sl, tp

    def score(self, ohlcv, market_type):
        if market_type == "volatile":
            return 2
        return 0



### FILE: ./utils/backtester.py
# utils/backtester.py — Version 1.0.2

import os
import asyncio
import csv
import math
from datetime import datetime
from statistics import mean, pstdev
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.indicators import calculate_ema, calculate_rsi, ATR
from utils.logger import logger
from dotenv import load_dotenv


__version__ = "1.0.2"

class Backtester:
    def __init__(self, symbol: str, start: str, end: str,
                 granularity: str = '1h', initial_balance: float = 20.0):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.granularity = granularity
        self.initial_balance = initial_balance
        self.client = None
        self.executor = None
        self.reset()

    def reset(self):
        self.balance = self.initial_balance
        self.pos = None
        self.trades = []
        self.equity_curve = [self.initial_balance]

    async def run(self):
        # Lade API-Konfig aus .env
        load_dotenv()
        api_key = os.getenv("BINANCE_API_KEY")
        api_secret = os.getenv("BINANCE_API_SECRET")
        testnet = os.getenv("USE_TESTNET", "True").lower() == "true"

        # BinanceClient asynchron initialisieren
        self.client = await BinanceClient.create(api_key, api_secret, testnet)
        self.executor = TradeExecutor(self.client)

        logger.info(f"📊 Backtest für {self.symbol} gestartet…")
        ohlcv = await self.client.fetch_ohlcv(
            self.symbol, self.granularity,
            since=self._ts(self.start),
            until=self._ts(self.end)
        )

        for i in range(len(ohlcv)):
            ts, o, h, l, c, v = ohlcv[i]
            time = datetime.utcfromtimestamp(ts/1000)

            # Indikatoren berechnen
            window_ema = [row[4] for row in ohlcv[max(0, i-50):i+1]]
            window_rsi = [row[4] for row in ohlcv[max(0, i-15):i+1]]
            window_atr = ohlcv[max(0, i-15):i+1]
            ema = calculate_ema(window_ema, period=20)
            rsi = calculate_rsi(window_rsi, period=14)
            atr = calculate_atr(window_atr, period=14)

            # Entry-Signale
            if not self.pos:
                if c > ema and rsi < 30:
                    signal = 'BUY'
                elif c < ema and rsi > 70:
                    signal = 'SELL'
                else:
                    signal = None

                if signal:
                    qty = self.balance / c
                    res = await self.executor.execute_trade(
                        self.symbol, signal, qty,
                        atr_period=14, sl_multiplier=1.5, tp_multiplier=3.0,
                        martingale_factor=1.0, paper=True
                    )
                    self.pos = {
                        'entry_time': time,
                        'entry_price': res['entry_price'],
                        'sl': res['sl_price'],
                        'tp': res['tp_price'],
                        'qty': res['qty'],
                        'side': signal
                    }

            # Exit-Logik
            if self.pos:
                price = c
                side = self.pos['side']
                exit_trade = False
                if side == 'BUY' and (price <= self.pos['sl'] or price >= self.pos['tp']):
                    exit_trade = True
                elif side == 'SELL' and (price >= self.pos['sl'] or price <= self.pos['tp']):
                    exit_trade = True

                if exit_trade:
                    pnl = (price - self.pos['entry_price']) * self.pos['qty']
                    if side == 'SELL':
                        pnl *= -1
                    self.balance += pnl
                    self.trades.append({
                        'entry': self.pos['entry_price'],
                        'exit': price,
                        'pnl': pnl
                    })
                    self.equity_curve.append(self.balance)
                    logger.info(
                        f"[Backtest] {side} {self.symbol} Entry={self.pos['entry_price']:.2f} Exit={price:.2f} P&L={pnl:.4f} Bal={self.balance:.4f}"
                    )
                    self.pos = None

        stats = self._compute_metrics()
        self._save_results(stats)
        logger.info(f"📈 Backtest abgeschlossen — Endbalance: {self.balance:.2f} — Stats: {stats}")

    def _compute_metrics(self):
        returns = []
        peak = self.initial_balance
        max_dd = 0
        wins = 0

        for bal in self.equity_curve[1:]:
            ret = (bal - peak) / peak
            returns.append(ret)
            if bal > peak:
                peak = bal
            dd = (peak - bal) / peak
            max_dd = max(max_dd, dd)
            if ret > 0:
                wins += 1

        win_rate = wins / len(returns) if returns else 0
        avg_ret = mean(returns) if returns else 0
        std_ret = pstdev(returns) if len(returns) > 1 else 0.0001
        sharpe = (avg_ret / std_ret) * math.sqrt(8760) if std_ret else 0
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        return {
            'total_return': total_return,
            'max_drawdown': max_dd,
            'win_rate': win_rate,
            'sharpe_ratio': sharpe
        }

    def _save_results(self, stats: dict):
        base = f"backtest_{self.symbol}_{self.start}_{self.end}"
        with open(f"{base}.csv", 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=['entry', 'exit', 'pnl'])
            writer.writeheader()
            for t in self.trades:
                writer.writerow(t)
        with open(f"{base}_stats.txt", 'w') as f:
            for k, v in stats.items():
                f.write(f"{k}: {v}\n")

    @staticmethod
    def _ts(date_str: str) -> int:
        dt = datetime.fromisoformat(date_str)
        return int(dt.timestamp() * 1000)



### FILE: ./utils/cooldown_manager.py
# utils/cooldown_manager.py

from datetime import datetime, timedelta

class CooldownManager:
    def __init__(self, cooldown_minutes=30):
        self.cooldowns = {}  # symbol → datetime
        self.cooldown_duration = timedelta(minutes=cooldown_minutes)

    def is_in_cooldown(self, symbol: str) -> bool:
        now = datetime.utcnow()
        last = self.cooldowns.get(symbol)
        return last and (now - last) < self.cooldown_duration

    def update_cooldown(self, symbol: str):
        self.cooldowns[symbol] = datetime.utcnow()



### FILE: ./utils/drawdown_guard.py
# utils/drawdown_guard.py

from datetime import datetime
import pandas as pd

class DrawdownGuard:
    def __init__(self, csv_file="paper_trades.csv", start_balance=20.0, max_loss_pct=5.0):
        self.csv_file = csv_file
        self.start_balance = start_balance
        self.max_loss_pct = max_loss_pct

    def loss_today_exceeded(self) -> bool:
        try:
            df = pd.read_csv(self.csv_file)
            df = df[df["pnl"].notna()]
            today = datetime.utcnow().date()
            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df[df["timestamp"].dt.date == today]

            if df.empty:
                return False

            pnl_sum = df["pnl"].sum()
            loss_pct = -pnl_sum / self.start_balance * 100 if pnl_sum < 0 else 0

            return loss_pct >= self.max_loss_pct
        except Exception:
            return False  # Lieber weiter traden als fälschlich stoppen



### FILE: ./utils/equity_plot.py
# utils/equity_plot.py

import pandas as pd
import matplotlib.pyplot as plt
import os
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

def plot_equity_curve(csv_file=CSV_PATH, out_file="equity_curve.png"):
    df = pd.read_csv(csv_file)
    df["time"] = pd.to_datetime(df["time"])
    df = df.sort_values("time")

    # Equity berechnen
    equity = []
    balance = 20  # Startwert
    for _, row in df.iterrows():
        if pd.notna(row["pnl"]):
            balance += row["pnl"]
        equity.append(balance)

    df["equity"] = equity

    plt.figure(figsize=(10, 5))
    plt.plot(df["time"], df["equity"], label="Equity Curve", color="green")
    plt.title("Equity Curve (Paper-Trades)")
    plt.xlabel("Zeit")
    plt.ylabel("USDC")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_file), exist_ok=True)
    plt.savefig(out_file)
    plt.close()



### FILE: ./utils/logger.py
# utils/logger.py — Version 1.0.2

import logging
import os
import sys
from logging.handlers import RotatingFileHandler

LOG_DIR = "logs"
LOG_FILE = os.path.join(LOG_DIR, "bot.log")

def setup_logger(name="bot"):
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', "%Y-%m-%d %H:%M:%S")

    # File Handler
    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5*1024*1024, backupCount=2)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Console Handler (optional)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Prevent duplicate logs
    logger.propagate = False

    return logger

# Global Logger
logger = setup_logger()

# Capture unhandled exceptions
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception



### FILE: ./utils/market_classifier.py
# utils/market_classifier.py

import numpy as np
from strategies.indicators import calculate_ema, calculate_atr

def classify_market(ohlcv):
    """
    Klassifiziert den Markt als 'trend', 'sideways' oder 'volatile' basierend auf EMA, ATR und Preisdynamik.
    """
    closes = [row[4] for row in ohlcv]
    highs = [row[2] for row in ohlcv]
    lows = [row[3] for row in ohlcv]

    # Trendbestimmung über EMA-Slope und Abstand
    ema50 = calculate_ema(ohlcv, 50)
    ema200 = calculate_ema(ohlcv, 200)
    price = closes[-1]
    slope = ema50 - ema50 if len(closes) < 52 else (ema50 - calculate_ema(ohlcv[-52:], 50))

    # ATR (Volatilität)
    atr = calculate_atr(ohlcv, 14)
    price_range = max(highs[-20:]) - min(lows[-20:])
    vola_ratio = atr / price if price != 0 else 0

    # Dynamische Schwellen (tune nach Wunsch!)
    strong_trend = abs(ema50 - ema200) / price > 0.01 and abs(slope) > 0.05 * price  # mind. 1% EMA-Diff, steile Steigung
    very_volatile = vola_ratio > 0.025 or price_range / price > 0.05  # 2.5% ATR oder 5% Range in 20 Kerzen

    if strong_trend:
        return "trend"
    elif very_volatile:
        return "volatile"
    else:
        return "sideways"



### FILE: ./utils/risk_manager.py
# utils/risk_manager.py

class RiskManager:
    def __init__(self, initial_balance: float = 20.0, max_risk_per_trade: float = 0.02):
        self.balance = initial_balance
        self.risk_pct = max_risk_per_trade  # z. B. 2 %

    def update_balance(self, new_balance: float):
        self.balance = new_balance

    def calculate_position_size(self, entry_price: float, stop_loss: float) -> float:
        sl_distance = abs(entry_price - stop_loss)
        if sl_distance == 0:
            return 0.0  # keine sinnvolle Positionsgröße möglich
        risk_amount = self.balance * self.risk_pct
        qty = risk_amount / sl_distance
        return round(qty, 6)



### FILE: ./utils/signal_filter.py
# utils/signal_filter.py

from strategies.indicators import calculate_ema, calculate_atr

class SignalFilter:
    def __init__(self, volume_factor=1.2, atr_threshold=0.001, trend_strength=0.001):
        self.volume_factor = volume_factor       # z. B. 1.2x über 10er-Avg
        self.atr_threshold = atr_threshold       # z. B. mind. 0.1 % Bewegung
        self.trend_strength = trend_strength     # z. B. Preisabstand zu EMA20 > 0.1 %

    def passes_filters(self, ohlcv) -> bool:
        closes = [c[4] for c in ohlcv]
        highs = [c[2] for c in ohlcv]
        lows = [c[3] for c in ohlcv]
        volumes = [c[5] for c in ohlcv]

        # Trend-Erkennung
        ema = calculate_ema(ohlcv, 20)
        price = closes[-1]
        trend_diff = abs(price - ema) / ema
        if trend_diff < self.trend_strength:
            return False  # Kein klarer Trend

        # Volumen-Filter
        avg_vol = sum(volumes[-11:-1]) / 10
        if volumes[-1] < avg_vol * self.volume_factor:
            return False  # Kein Volumenimpuls

        # ATR-basierte Volatilitätsprüfung
        atr = calculate_atr(ohlcv, 14)
        if atr / price < self.atr_threshold:
            return False  # Markt zu ruhig

        return True  # Alles passt



### FILE: ./utils/strategy_watchdog.py
# utils/strategy_watchdog.py

import csv
import os
from datetime import datetime
from collections import defaultdict

WATCHDOG_FILE = "strategy_watchdog.csv"

class StrategyWatchdog:
    def __init__(self):
        self.stats = defaultdict(lambda: {"trades": 0, "wins": 0, "losses": 0})
        self._load_existing()

    def _load_existing(self):
        if not os.path.isfile(WATCHDOG_FILE):
            return
        with open(WATCHDOG_FILE, mode="r") as f:
            reader = csv.DictReader(f)
            for row in reader:
                strat = row["strategy"]
                self.stats[strat] = {
                    "trades": int(row["trades"]),
                    "wins": int(row["wins"]),
                    "losses": int(row["losses"])
                }

    def record_trade(self, strategy_name: str, pnl: float):
        stat = self.stats[strategy_name]
        stat["trades"] += 1
        if pnl > 0:
            stat["wins"] += 1
        else:
            stat["losses"] += 1
        self._save()

    def _save(self):
        with open(WATCHDOG_FILE, mode="w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["strategy", "trades", "wins", "losses"])
            for strat, s in self.stats.items():
                writer.writerow([strat, s["trades"], s["wins"], s["losses"]])



### FILE: ./utils/trade_logger.py
# utils/trade_logger.py

import csv
import os
from datetime import datetime

TRADE_LOG_FILE = "paper_trades.csv"

def log_trade(symbol, side, entry_price, sl, tp, qty, pnl=None, strategy=None):
    file_exists = os.path.isfile(TRADE_LOG_FILE)
    with open(TRADE_LOG_FILE, mode='a', newline='') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow([
                "timestamp", "symbol", "side", "entry_price",
                "stop_loss", "take_profit", "qty", "pnl"
            ])
        writer.writerow([
	    datetime.utcnow().isoformat(), symbol, side, entry_price,
    	sl, tp, qty, pnl if pnl is not None else "", strategy or ""
	])



### FILE: ./utils/trade_tracker.py
import pandas as pd
from datetime import datetime
from utils.trade_logger import log_trade

def update_trade_pnls(csv_file="paper_trades.csv", current_prices=None):
    expected_cols = ["time", "symbol", "side", "entry_price", "stop_loss", "take_profit", "qty", "pnl", "strategy"]
    df = pd.read_csv(csv_file, names=expected_cols, header=0)

    # Fehlende Spalten ergänzen (alte Zeilen/alte CSV)
    for col in expected_cols:
        if col not in df.columns:
            df[col] = None

    updated = False

    for idx, row in df[df["pnl"].isna()].iterrows():
        symbol = row["symbol"]
        price = current_prices.get(symbol)
        if price is None:
            continue

        side = row["side"]
        entry = row["entry_price"]
        sl = row["stop_loss"]
        tp = row["take_profit"]
        qty = row["qty"]

        pnl = None
        # Prüfen, ob SL oder TP erreicht wurde
        if side == "BUY" and (price <= sl or price >= tp):
            pnl = (price - entry) * qty
        elif side == "SELL" and (price >= sl or price <= tp):
            pnl = (entry - price) * qty

        # Nur wenn Trade geschlossen wurde:
        if pnl is not None:
            df.at[idx, "pnl"] = pnl
            updated = True

            # Optional: Watchdog informieren, falls Strategie geloggt wurde
            strategy_name = row.get("strategy", "Unknown")
            try:
                from utils.strategy_watchdog import StrategyWatchdog
                StrategyWatchdog().record_trade(strategy_name=strategy_name, pnl=pnl)
            except Exception as e:
                print(f"[Watchdog] Fehler bei Strategie-Tracking: {e}")

    if updated:
        df.to_csv(csv_file, index=False)



### FILE: ./bot.py
#!/usr/bin/env python3
# bot.py — Version 1.0.1

import os
import asyncio
from dotenv import load_dotenv
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from utils.backtester import Backtester
from utils.logger import logger

__version__ = "1.0.1"

def load_config():
    load_dotenv()
    return {
        "api_key": os.getenv("BINANCE_API_KEY"),
        "api_secret": os.getenv("BINANCE_API_SECRET"),
        "testnet": os.getenv("USE_TESTNET", "True").lower() == "true",
        "symbol": os.getenv("SYMBOL", "BTCUSDC"),
        "backtest_start": os.getenv("BACKTEST_START", "2025-01-01T00:00"),
        "backtest_end": os.getenv("BACKTEST_END", "2025-06-01T00:00"),
        "granularity": os.getenv("GRANULARITY", "1h"),
        "initial_balance": float(os.getenv("INITIAL_BALANCE", "20.0")),
        "trade_quantity": float(os.getenv("TRADE_QUANTITY", "0.001")),
        "paper_trading": os.getenv("PAPER_TRADING", "True").lower() == "true",
        "atr_period": int(os.getenv("ATR_PERIOD", "14")),
        "sl_multiplier": float(os.getenv("SL_MULTIPLIER", "1.5")),
        "tp_multiplier": float(os.getenv("TP_MULTIPLIER", "3.0")),
        "martingale_factor": float(os.getenv("MARTINGALE_FACTOR", "1.0")),
    }

async def main():
    cfg = load_config()
    logger.info(f"🚀 Starting Grok-FuturesBot v{__version__}")

    # 1) Backtest
    logger.info("🔍 Running backtest…")
    bt = Backtester(
        symbol=cfg["symbol"],
        start=cfg["backtest_start"],
        end=cfg["backtest_end"],
        granularity=cfg["granularity"],
        initial_balance=cfg["initial_balance"],
    )
    await bt.run()

    # 2) Live-/Paper-Trading Beispiel
    logger.info("💡 Starting live/paper trading example…")
    client = await BinanceClient.create(
        api_key=cfg["api_key"],
        api_secret=cfg["api_secret"],
        testnet=cfg["testnet"],
    )
    executor = TradeExecutor(client)
    result = await executor.execute_trade(
        symbol=cfg["symbol"],
        side="BUY",
        quantity=cfg["trade_quantity"],
        atr_period=cfg["atr_period"],
        sl_multiplier=cfg["sl_multiplier"],
        tp_multiplier=cfg["tp_multiplier"],
        martingale_factor=cfg["martingale_factor"],
        paper=cfg["paper_trading"],
    )
    logger.info(
        f"🎯 Trade result (paper={cfg['paper_trading']}): Entry={result['entry_price']}, SL={result['sl_price']}, TP={result['tp_price']}"
    )

if __name__ == "__main__":
    asyncio.run(main())



### FILE: ./core/client.py
# core/client.py — Version 1.0.2

import asyncio
import ccxt.async_support as ccxt
from binance import AsyncClient
from utils.logger import logger

class BinanceClient:
    def __init__(self, client: AsyncClient):
        self.client = client

    @classmethod
    async def create(cls, api_key: str, api_secret: str, testnet: bool = False):
        logger.info(f"🔌 Verbinde mit Binance (testnet={testnet})...")
        client = await AsyncClient.create(
            api_key=api_key,
            api_secret=api_secret,
            testnet=testnet
        )
        return cls(client)

    async def get_futures_price(self, symbol: str) -> float:
        ticker = await self.client.futures_symbol_ticker(symbol=symbol)
        return float(ticker["price"])

    async def fetch_ohlcv(self, symbol: str, timeframe: str, since: int = None, limit: int = None, until: int = None):
        exchange = ccxt.binance({
            'enableRateLimit': True,
            'options': {
                'defaultType': 'future'
            }
        })
        if since and until:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since)
            ohlcv = [c for c in ohlcv if c[0] <= until]
        else:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
        await exchange.close()
        return ohlcv

    async def futures_change_leverage(self, symbol: str, leverage: int):
        """
        Setzt das Leverage für ein Futures-Symbol.
        """
        try:
            result = await self.client.futures_change_leverage(symbol=symbol, leverage=leverage)
            logger.info(f"[LEVERAGE] {symbol}: Leverage wurde auf {leverage}x gesetzt. Antwort: {result}")
            return result
        except Exception as e:
            logger.error(f"[LEVERAGE] Fehler beim Setzen des Leverage für {symbol}: {e}")
            raise

    async def close(self):
        await self.client.close_connection()



### FILE: ./core/trade_executor.py
from utils.logger import logger
from strategies.indicators import calculate_atr
from binance.enums import *

SIDE_Buy = "Buy"

class TradeExecutor:
    def __init__(self, client, base_currency: str = "USDC"):
        self.client = client
        self.base_currency = base_currency

    async def execute_trade(
        self,
        symbol: str,
        side: str,
        quantity: float,
        sl: float = None,
        tp: float = None,
        atr_period: int = 14,
        sl_multiplier: float = 1.5,
        tp_multiplier: float = 3.0,
        martingale_factor: float = 1.0,
        paper: bool = True
    ):
        qty = quantity * martingale_factor
        logger.info(f"Placing {side} order for {symbol} qty={qty:.6f} (martingale={martingale_factor})")

        # Preis ermitteln
        if paper:
            price = await self.client.get_futures_price(symbol)
            logger.info(f"(Paper) Order simulated at {price}")
        else:
            order = await self.client.client.futures_create_order(
                symbol=symbol,
                side=side,
                type=FUTURE_ORDER_TYPE_MARKET,
                quantity=qty
            )
            price = float(order["avgPrice"])
            logger.info(f"Order executed at price={price}")

        # SL/TP berechnen wenn nicht manuell übergeben
        if sl is None or tp is None:
            ohlcv = await self.client.fetch_ohlcv(symbol, timeframe='1h', limit=atr_period + 1)
            atr = calculate_atr(ohlcv, period=atr_period)
            sl, tp = self._compute_sl_tp(price, atr, side, sl_multiplier, tp_multiplier)

        return {
            "entry_price": price,
            "sl_price": sl,
            "tp_price": tp,
            "qty": qty
        }

    def _compute_sl_tp(self, entry: float, atr: float, side: str,
                       sl_mult: float, tp_mult: float):
        if side == SIDE_BUY:
            sl = entry - atr * sl_mult
            tp = entry + atr * tp_mult
        else:
            sl = entry + atr * sl_mult
            tp = entry - atr * tp_mult
        return sl, tp



### FILE: ./dashboard/app.py
from flask import Flask, render_template, send_file
import os
import sys
import pandas as pd
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.equity_plot import plot_equity_curve
from utils.trade_logger import log_trade 
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

app = Flask(__name__)

@app.route("/")
def index():
    # Equity-Kurve aktualisieren
    plot_equity_curve(CSV_PATH, "dashboard/static/equity_curve.png")

    # Daten aus CSV laden
    df = pd.read_csv(CSV_PATH)
    df_closed = df[df["pnl"].notna()]
    balance = 20.0 + df_closed["pnl"].sum()
    winrate = (df_closed["pnl"] > 0).mean() * 100 if not df_closed.empty else 0

    return render_template("index.html", 
        balance=round(balance, 2),
        total_trades=len(df),
        winrate=round(winrate, 1),
        trades=df.tail(10).to_dict(orient="records")
    )

@app.route("/chart")
def chart():
    return send_file("static/equity_curve.png", mimetype='image/png')

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)



### FILE: ./ml/analyze_backtest.py
import pandas as pd
import matplotlib.pyplot as plt
import sys
import os

# CSV-Datei übergeben, sonst Standardpfad
CSV = sys.argv[1] if len(sys.argv) > 1 else "ml/backtest_results.csv"

if not os.path.isfile(CSV):
    print(f"Datei nicht gefunden: {CSV}")
    sys.exit(1)

df = pd.read_csv(CSV)
print(f"Analysiere {len(df)} Trades aus {CSV}")

# Equity-Kurve erzeugen
df = df.sort_values("timestamp")
df["cum_pnl"] = df["pnl"].cumsum()
plt.figure(figsize=(12,6))
plt.plot(df["timestamp"], df["cum_pnl"], label="Equity Curve")
plt.xlabel("Timestamp")
plt.ylabel("Kumuliertes Ergebnis")
plt.title("Equity Curve (Backtest)")
plt.grid()
plt.tight_layout()
plt.savefig("ml/equity_curve_backtest.png")
print("Equity Curve gespeichert als ml/equity_curve_backtest.png")

# Metriken je Strategie
strategies = df["strategy"].unique()
summary = []
for strat in strategies:
    sub = df[df["strategy"] == strat]
    trades = len(sub)
    wins = (sub["pnl"] > 0).sum()
    winrate = wins / trades * 100 if trades > 0 else 0
    total_pnl = sub["pnl"].sum()
    avg_pnl = sub["pnl"].mean()
    max_dd = (sub["cum_pnl"].cummax() - sub["cum_pnl"]).max()
    summary.append([strat, trades, wins, winrate, total_pnl, avg_pnl, max_dd])

summary_df = pd.DataFrame(summary, columns=["Strategie", "Trades", "Wins", "Winrate %", "Gesamt-PnL", "Ø PnL", "Max Drawdown"])
print("\n==== Strategien-Auswertung ====")
print(summary_df.sort_values("Gesamt-PnL", ascending=False))

# Optional: Heatmap Symbol vs. Strategie
if "symbol" in df.columns:
    pivot = df.pivot_table(index="strategy", columns="symbol", values="pnl", aggfunc="sum")
    plt.figure(figsize=(10, 6))
    import seaborn as sns
    sns.heatmap(pivot, annot=True, fmt=".2f", cmap="RdYlGn")
    plt.title("Profit Heatmap: Strategie vs. Symbol")
    plt.tight_layout()
    plt.savefig("ml/heatmap_backtest.png")
    print("Heatmap gespeichert als ml/heatmap_backtest.png")



### FILE: ./ml/backtest_data_import.py
import os
import csv
import time
from datetime import datetime
import ccxt
from tqdm import tqdm
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from strategies.indicators import calculate_ema, calculate_rsi, calculate_atr, calculate_bollinger_bands
from strategies.engine import StrategyEngine

# Konfiguration
EXCHANGE = ccxt.binance({
    'rateLimit': 1200,
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})

OUTPUT_FILE = "ml/training_data_backtest.csv"
SYMBOLS = ["BTC/USDC", "ETH/USDC", "SOL/USDC"]  # Beliebig erweiterbar
TIMEFRAME = "1h"
START_DATE = "2024-01-01T00:00:00Z"  # YYYY-MM-DDTHH:MM:SSZ
END_DATE = "2024-06-30T00:00:00Z"

# Helper
def parse_iso8601(date_str):
    return int(EXCHANGE.parse8601(date_str))

def ohlcv_to_dict(symbol, ohlcv, strategy, market_state):
    # ohlcv: [timestamp, open, high, low, close, volume]
    close = float(ohlcv[4])
    ema = calculate_ema([ohlcv], 1)     # Für Einzelkerze = Kerzenwert
    rsi = calculate_rsi([ohlcv], 1)
    atr = calculate_atr([ohlcv], 1)
    bb_upper, bb_lower = calculate_bollinger_bands([ohlcv], 1)
    return {
        "timestamp": datetime.utcfromtimestamp(ohlcv[0]/1000).isoformat(),
        "symbol": symbol,
        "open": ohlcv[1],
        "high": ohlcv[2],
        "low": ohlcv[3],
        "close": ohlcv[4],
        "volume": ohlcv[5],
        "ema": ema,
        "rsi": rsi,
        "atr": atr,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "market_state": market_state,
        "strategy": strategy,
        "signal": "",    # Noch leer (optional für späteren Backtest/ML-Label)
        "result": ""
    }

def fetch_all_ohlcv(symbol, timeframe, since, until):
    all_candles = []
    limit = 1000
    now = since
    pbar = tqdm(desc=f"Lade {symbol}", total=(until-since)//(60*60*1000))
    while now < until:
        candles = EXCHANGE.fetch_ohlcv(symbol, timeframe, since=now, limit=limit)
        if not candles:
            break
        for c in candles:
            if c[0] > until:
                break
            all_candles.append(c)
        now = candles[-1][0] + 1
        pbar.update(len(candles))
        time.sleep(0.1)
    pbar.close()
    return all_candles

def main():
    # Setup
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, "w", newline='') as f:
        fieldnames = [
            "timestamp", "symbol", "open", "high", "low", "close", "volume",
            "ema", "rsi", "atr", "bb_upper", "bb_lower",
            "market_state", "strategy", "signal", "result"
        ]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()

        engine = StrategyEngine()
        for symbol in SYMBOLS:
            since = parse_iso8601(START_DATE)
            until = parse_iso8601(END_DATE)
            ohlcv_data = fetch_all_ohlcv(symbol, TIMEFRAME, since, until)
            # Sliding-Window für Indikatoren und Strategieauswahl:
            window = []
            for row in tqdm(ohlcv_data, desc=f"Verarbeite {symbol}"):
                window.append(row)
                if len(window) > 50:
                    window = window[-50:]  # nur die letzten 50 Kerzen
                # Marktzustand und Strategie wählen:
                market_state = engine.evaluate_market(window) if len(window) >= 20 else ""
                strategy = engine.select_strategy(window).__class__.__name__ if len(window) >= 20 else ""
                writer.writerow(
                    ohlcv_to_dict(symbol, row, strategy, market_state)
                )

if __name__ == "__main__":
    main()



### FILE: ./ml/backtest_engine.py
import sys
import os
import asyncio
import pandas as pd

# Damit die Importe klappen, egal von wo du startest:
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import ccxt.async_support as ccxt

from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr, calculate_bollinger_bands
from strategies.rsi_ema import RSIEMAStrategy
from strategies.momentum import MomentumStrategy
from strategies.volatility import VolatilityStrategy
from strategies.breakout import BreakoutStrategy
from strategies.reversal import ReversalStrategy

STRATEGIES = [
    ("rsi_ema", RSIEMAStrategy()),
    ("momentum", MomentumStrategy()),
    ("volatility", VolatilityStrategy()),
    ("breakout", BreakoutStrategy()),
    ("reversal", ReversalStrategy())
]

async def fetch_ohlcv_ccxt(symbol, timeframe="1h", since=None, limit=1000):
    exchange = ccxt.binance({
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })
    ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
    await exchange.close()
    return ohlcv

def simulate_trade(entry, side, sl, tp, ohlcv_next):
    for row in ohlcv_next:
        price = float(row[4])
        if side == "BUY":
            if price <= sl:
                return sl, (sl - entry)
            elif price >= tp:
                return tp, (tp - entry)
        elif side == "SELL":
            if price >= sl:
                return sl, (entry - sl)
            elif price <= tp:
                return tp, (entry - tp)
    return price, (price - entry) if side == "BUY" else (entry - price)

def run_backtest(symbol, ohlcv, out_csv="ml/backtest_results.csv", lookahead=10):
    results = []
    for i in range(50, len(ohlcv) - lookahead):
        sub_ohlcv = ohlcv[:i]
        future_ohlcv = ohlcv[i:i+lookahead]
        price = float(ohlcv[i][4])
        atr = calculate_atr(sub_ohlcv, 14)
        for strat_name, strat in STRATEGIES:
            signal = strat.generate_signal(sub_ohlcv)
            if signal:
                sl, tp = strat.sl_tp(price, atr)
                exit_price, pnl = simulate_trade(price, signal, sl, tp, future_ohlcv)
                results.append({
                    "timestamp": ohlcv[i][0],
                    "symbol": symbol,
                    "strategy": strat_name,
                    "side": signal,
                    "entry": price,
                    "sl": sl,
                    "tp": tp,
                    "exit": exit_price,
                    "pnl": pnl
                })
                
    out_dir = os.path.dirname(out_csv)
    if out_dir and not os.path.exists(out_dir):
        os.makedirs(out_dir)
            
    pd.DataFrame(results).to_csv(out_csv, index=False)
    print(f"Backtest für {symbol} abgeschlossen – {len(results)} Trades.")

async def main(symbol="BTCUSDT", timeframe="1h", candles=1000, out_csv="ml/backtest_results.csv"):
    print(f"Lade OHLCV für {symbol}, Intervall {timeframe}, Anzahl {candles} ...")
    ohlcv = await fetch_ohlcv_ccxt(symbol, timeframe=timeframe, limit=candles)
    run_backtest(symbol, ohlcv, out_csv=out_csv)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--symbol", default="BTCUSDT", help="Symbol, z.B. BTCUSDT")
    parser.add_argument("--timeframe", default="1h", help="Kerzenintervall, z.B. 1h, 15m, 5m")
    parser.add_argument("--candles", type=int, default=1000, help="Anzahl Kerzen")
    parser.add_argument("--out", default="ml/backtest_results.csv", help="Ziel-Datei")
    args = parser.parse_args()
    asyncio.run(main(symbol=args.symbol, timeframe=args.timeframe, candles=args.candles, out_csv=args.out))



### FILE: ./ml/collect_training_data.py
import os
import csv
from datetime import datetime

TRAINING_CSV = "ml/training_data.csv"

# Stelle sicher, dass der Ordner existiert
os.makedirs(os.path.dirname(TRAINING_CSV), exist_ok=True)

def append_training_data(
    timestamp, symbol, open_, high, low, close, volume,
    rsi, ema, atr, bb_upper, bb_lower,
    market_state, strategy, signal, result=None
):
    header = [
        "timestamp", "symbol", "open", "high", "low", "close", "volume",
        "rsi", "ema", "atr", "bb_upper", "bb_lower",
        "market_state", "strategy", "signal", "result"
    ]

    row = [
        timestamp, symbol, open_, high, low, close, volume,
        rsi, ema, atr, bb_upper, bb_lower,
        market_state, strategy, signal, result
    ]

    file_exists = os.path.isfile(TRAINING_CSV)

    with open(TRAINING_CSV, mode="a", newline="") as f:
        writer = csv.writer(f)
        if not file_exists:
            writer.writerow(header)
        writer.writerow(row)

# Beispiel-Aufruf (kann überall im Bot platziert werden):
if __name__ == "__main__":
    # Dummy-Daten zum Testen
    append_training_data(
        timestamp=datetime.utcnow().isoformat(),
        symbol="BTCUSDC",
        open_=30000, high=30500, low=29900, close=30200, volume=1000,
        rsi=55, ema=30150, atr=150, bb_upper=30400, bb_lower=29800,
        market_state="trend", strategy="BreakoutStrategy", signal="BUY", result=1.2
    )
    print(f"Testdatensatz geschrieben nach {TRAINING_CSV}")



### FILE: ./ml/feature_engineering_ml.py
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, StratifiedKFold, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import matplotlib.pyplot as plt
import seaborn as sns

# ======= 1. Daten einlesen =======
df = pd.read_csv('training_data.csv')

# Beispiel: Zeige Spalten und grobe Übersicht
print(df.head())
print(df.columns)

# ======= 2. Feature Engineering =======
# Beispiel-Features (bitte anpassen je nach Datenstruktur):
# - Returns, Volatility, Rolling-Mean, Trend, RSI/EMA-Kombis, etc.

if 'close' in df.columns:
    df['return'] = df['close'].pct_change()
    df['volatility'] = df['close'].rolling(window=14).std()
    df['rolling_mean'] = df['close'].rolling(window=14).mean()

# Zielspalte erstellen/umwandeln aus 'result'
if df['result'].dtype == 'int' or df['result'].dtype == 'float':
    df['target'] = df['result']
elif df['result'].dtype == 'bool':
    df['target'] = df['result'].astype(int)
else:
    # Falls z.B. win/loss oder True/False als String
    df['target'] = df['result'].map({'win': 1, 'loss': 0, 'true': 1, 'false': 0, 'True': 1, 'False': 0})
    if df['target'].isnull().any():
        raise Exception(f"Unbekannte Werte in 'result': {df['result'].unique()}")


# Fehlende Werte auffüllen
df = df.fillna(0)

# Beispiel: Features auswählen (passe ggf. an)
features = ['return', 'volatility', 'rolling_mean']
features = [f for f in features if f in df.columns]
X = df[features]
y = df['target']

# ======= 3. Daten aufteilen =======
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# ======= 4. Modell-Training & Auswahl =======
models = {
    'RandomForest': RandomForestClassifier(n_estimators=200, random_state=42),
    'XGBoost': XGBClassifier(n_estimators=200, use_label_encoder=False, eval_metric='logloss', random_state=42)
}

for name, model in models.items():
    print(f"\n== {name} ==")
    model.fit(X_train, y_train)
    preds = model.predict(X_test)
    print(classification_report(y_test, preds))
    print("Confusion Matrix:")
    print(confusion_matrix(y_test, preds))
    print("Accuracy:", accuracy_score(y_test, preds))
    # Feature Importance Plot
    if hasattr(model, "feature_importances_"):
        importances = model.feature_importances_
        sns.barplot(x=importances, y=features)
        plt.title(f"{name} Feature Importance")
        plt.show()

# ======= 5. Cross-Validation =======
for name, model in models.items():
    skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
    scores = cross_val_score(model, X, y, cv=skf, scoring='accuracy')
    print(f"{name} Cross-Validation Accuracy: {np.mean(scores):.4f} ± {np.std(scores):.4f}")

# ======= 6. Ergebnisse auswerten / speichern =======
# Z. B. besten Model speichern
import joblib
best_model = models['XGBoost']
joblib.dump(best_model, 'best_trading_model.pkl')
print("Bestes Modell gespeichert als best_trading_model.pkl")




### FILE: ./ml/ml_predict.py
# ml/ml_predict.py
import joblib
import pandas as pd

# Lade das ML-Modell (Pfad anpassen falls nötig)
ml_model = joblib.load('ml/best_trading_model.pkl')

# Definiere exakt die Features, die das Modell erwartet
FEATURES = [
    'open', 'high', 'low', 'close', 'volume',
    'rsi', 'ema', 'atr', 'bb_upper', 'bb_lower',
    'market_state', 'strategy', 'signal'
]

# Hilfsfunktion für Prediction
def predict_trade_signal(trade_dict):
    # trade_dict: dict mit allen notwendigen Features als Schlüssel
    df = pd.DataFrame([trade_dict])
    # Kategorische Spalten in numerische Codes
    for col in ['market_state', 'strategy', 'signal']:
        if col in df.columns and df[col].dtype == 'object':
            df[col] = df[col].astype('category').cat.codes
    # Fehlende Features mit 0 füllen
    for f in FEATURES:
        if f not in df.columns:
            df[f] = 0
    X = df[FEATURES]
    prediction = ml_model.predict(X)[0]
    probability = ml_model.predict_proba(X)[0][1]  # Wahrscheinlichkeit für Klasse "1"
    return prediction, probability



### FILE: ./multi_backtest.py
import asyncio
from utils.backtester import Backtester

symbol_list = ["BTCUSDC", "ETHUSDC", "BNBUSDC", "SOLUSDC"]
start = "2025-01-01T00:00"
end = "2025-06-01T00:00"
granularity = "1h"
initial_balance = 20.0

async def run_backtests():
    tasks = []
    for symbol in symbol_list:
        bt = Backtester(
            symbol=symbol,
            start=start,
            end=end,
            granularity=granularity,
            initial_balance=initial_balance
        )
        tasks.append(bt.run())
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(run_backtests())



### FILE: ./paper_loop.py
import os
import sys
import asyncio
from dotenv import load_dotenv
from datetime import datetime
import aiohttp

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.engine import StrategyEngine
from strategies.indicators import calculate_atr, calculate_ema, calculate_rsi, calculate_bollinger_bands
from utils.logger import logger
from utils.trade_logger import log_trade
from utils.trade_tracker import update_trade_pnls
from utils.risk_manager import RiskManager
from utils.cooldown_manager import CooldownManager
from utils.signal_filter import SignalFilter
from utils.drawdown_guard import DrawdownGuard
from utils.strategy_watchdog import StrategyWatchdog

# Neu: ML-Collector
from ml.collect_training_data import append_training_data

# === ML-Filter Import ===
from ml.ml_predict import predict_trade_signal

# Einstellungen
load_dotenv()
PAPER = True
INTERVAL = 10  # Schnelleres Intervall für mehr Datensätze & Trades!
START_BALANCE = 20.0
SYMBOLS = []

# Bot-Komponenten
engine = StrategyEngine()
risk_manager = RiskManager(initial_balance=START_BALANCE, max_risk_per_trade=0.02)
cooldown = CooldownManager(cooldown_minutes=30)
signal_filter = SignalFilter()
drawdown_guard = DrawdownGuard(start_balance=START_BALANCE, max_loss_pct=5.0)
watchdog = StrategyWatchdog()

# Abruf der Top 100 USDC-Futures-Paare nach Volumen
async def get_top_usdc_symbols_by_volume(limit=100):
    url = "https://fapi.binance.com/fapi/v1/ticker/24hr"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
            filtered = [
                d for d in data if d["symbol"].endswith("USDC") and float(d["quoteVolume"]) > 100000
            ]
            sorted_pairs = sorted(filtered, key=lambda x: float(x["quoteVolume"]), reverse=True)
            return [item["symbol"] for item in sorted_pairs[:limit]]

# Hauptloop
async def trade_task(symbol, client, executor):
    try:
        ohlcv = await client.fetch_ohlcv(symbol, "1h", limit=50)
        closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
        price = closes[-1]
        atr = calculate_atr(ohlcv, 14)
        ema = calculate_ema(ohlcv, 50)
        rsi = calculate_rsi(ohlcv, 14)
        bb_upper, bb_lower = calculate_bollinger_bands(ohlcv, 20, 2)

        strategy = engine.select_strategy(ohlcv)
        signal = strategy.generate_signal(ohlcv)
        market_state = engine.evaluate_market(ohlcv)

        # ML-Datensammlung: Immer protokollieren (auch wenn kein Trade ausgelöst wird)
        append_training_data(
            timestamp=datetime.utcnow().isoformat(),
            symbol=symbol,
            open_=ohlcv[-1][1],
            high=ohlcv[-1][2],
            low=ohlcv[-1][3],
            close=ohlcv[-1][4],
            volume=ohlcv[-1][5],
            rsi=rsi,
            ema=ema,
            atr=atr,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            market_state=market_state,
            strategy=strategy.__class__.__name__,
            signal=signal,
            result=None
        )

        if not signal:
            logger.info(f"[FILTER] {symbol}: Kein Signal.")
            return

        if cooldown.is_in_cooldown(symbol):
            logger.info(f"[COOLDOWN] {symbol}: aktiv – übersprungen.")
            return

        if not signal_filter.passes_filters(ohlcv):
            logger.info(f"[FILTER] {symbol}: Markt ungeeignet.")
            return

        sl, tp = strategy.sl_tp(price, atr)
        qty = risk_manager.calculate_position_size(entry_price=price, stop_loss=sl)

        if qty <= 0:
            logger.warning(f"[RISK] {symbol}: Ordergröße zu klein – übersprungen.")
            return

        # ==== ML-FILTER: Nur bei hohem ML-Score traden ====
        trade_features = {
            'open': ohlcv[-1][1],
            'high': ohlcv[-1][2],
            'low': ohlcv[-1][3],
            'close': ohlcv[-1][4],
            'volume': ohlcv[-1][5],
            'rsi': rsi,
            'ema': ema,
            'atr': atr,
            'bb_upper': bb_upper,
            'bb_lower': bb_lower,
            'market_state': market_state,
            'strategy': strategy.__class__.__name__,
            'signal': signal
        }
        ml_pred, ml_prob = predict_trade_signal(trade_features)
        logger.info(f"[ML] {symbol}: Wahrscheinlichkeit für Gewinn: {ml_prob:.2f}")
        if ml_prob <= 0.6:
            logger.info(f"[ML] {symbol}: Trade ausgelassen – Low-Confidence.")
            return
        # ==== ENDE ML-FILTER ====

        logger.info(f"[TRADE] {symbol}: {signal} @ {price:.2f} SL={sl:.2f} TP={tp:.2f} QTY={qty:.4f}")

        result = await executor.execute_trade(
            symbol=symbol,
            side=signal,
            quantity=qty,
            sl=sl,
            tp=tp,
            paper=PAPER
        )

        # Log für Trade
        log_trade(
            symbol=symbol,
            side=signal,
            entry_price=result["entry_price"],
            sl=sl,
            tp=tp,
            qty=qty,
            strategy=strategy.__class__.__name__
        )

        cooldown.update_cooldown(symbol)

        # ML-Log mit Ergebnis
        append_training_data(
            timestamp=datetime.utcnow().isoformat(),
            symbol=symbol,
            open_=ohlcv[-1][1],
            high=ohlcv[-1][2],
            low=ohlcv[-1][3],
            close=ohlcv[-1][4],
            volume=ohlcv[-1][5],
            rsi=rsi,
            ema=ema,
            atr=atr,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            market_state=market_state,
            strategy=strategy.__class__.__name__,
            signal=signal,
            result=result.get("pnl") if result else None
        )

    except Exception as e:
        logger.error(f"[{symbol}] Fehler im Loop: {e}")

async def trade_loop():
    global SYMBOLS
    client = await BinanceClient.create(
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
        testnet=os.getenv("USE_TESTNET", "True").lower() == "true"
    )
    executor = TradeExecutor(client)

    SYMBOLS = await get_top_usdc_symbols_by_volume(limit=25)  # Bei RAM-Engpässen hier verringern!

    logger.info(f"📊 Überwachte Paare: {', '.join(SYMBOLS[:10])} ...")

    try:
        while True:
            if drawdown_guard.loss_today_exceeded():
                logger.warning("🛑 Tagesverlustgrenze erreicht – Trading pausiert.")
                await asyncio.sleep(INTERVAL)
                continue

            tasks = [trade_task(symbol, client, executor) for symbol in SYMBOLS]
            await asyncio.gather(*tasks)

            try:
                current_prices = {symbol: await client.get_futures_price(symbol) for symbol in SYMBOLS}
                update_trade_pnls(current_prices=current_prices)
            except Exception as e:
                logger.warning(f"[PnL] Preisabruf fehlgeschlagen: {e}")

            logger.info(f"⏳ Nächster Zyklus in {INTERVAL} Sekunden...\n")
            await asyncio.sleep(INTERVAL)

    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(trade_loop())



### FILE: ./strategies/breakout.py
from strategies.indicators import calculate_atr

class BreakoutStrategy:
    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        highs = [row[2] for row in ohlcv[-21:]]
        lows = [row[3] for row in ohlcv[-21:]]
        price = closes[-1]

        # Buy-Breakout: schließt über dem lokalen Hoch der letzten 20 Kerzen, mit Volumenfilter
        if price > max(highs[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "BUY"
        # Sell-Breakout: schließt unter dem lokalen Tief der letzten 20 Kerzen
        elif price < min(lows[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "SELL"
        else:
            return None

    def sl_tp(self, price, atr):
        # Aggressiver SL/TP für echte Ausbrüche!
        sl = price - 2.0 * atr
        tp = price + 4.0 * atr
        return sl, tp

    def score(self, ohlcv, market_type):
        # Perfekt in klaren Trendphasen!
        if market_type == "trend":
            return 2
        return 0



### FILE: ./strategies/engine.py
from strategies.rsi_ema import RSIEMAStrategy
from strategies.breakout import BreakoutStrategy
from strategies.momentum import MomentumStrategy
from strategies.reversal import ReversalStrategy
from strategies.range_trading import RangeTradingStrategy
from strategies.volatility import VolatilityStrategy

class StrategyEngine:
    def __init__(self):
        self.strategies = [
            RSIEMAStrategy(),
            BreakoutStrategy(),
            MomentumStrategy(),
            ReversalStrategy(),
            RangeTradingStrategy(),
            VolatilityStrategy()
        ]

    def evaluate_market(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 21:
            return "sideways"
        change = abs(closes[-1] - closes[-20]) / closes[-20]
        if change > 0.03:
            return "trend"
        # Einfache Volatilitätsbestimmung
        atr = abs(max(closes[-20:]) - min(closes[-20:])) / closes[-20]
        if atr > 0.04:
            return "volatile"
        return "sideways"

    def select_strategy(self, ohlcv):
        market = self.evaluate_market(ohlcv)
        for strategy in self.strategies:
            if hasattr(strategy, "suits"):
                if strategy.suits(market):
                    return strategy
            # fallback für alte strategien ohne suits()
        return self.strategies[0]



### FILE: ./strategies/indicators.py
import numpy as np

def calculate_rsi(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period + 1:
        return 50.0
    deltas = np.diff(closes)
    gain = np.where(deltas > 0, deltas, 0).sum() / period
    loss = -np.where(deltas < 0, deltas, 0).sum() / period
    if loss == 0:
        return 100.0
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_ema(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return closes[-1] if closes else 0.0
    ema = np.mean(closes[-period:])
    multiplier = 2 / (period + 1)
    for price in closes[-period:]:
        ema = (price - ema) * multiplier + ema
    return ema

def calculate_atr(ohlcv, period=14):
    if len(ohlcv) < period + 1:
        return 0.0
    high = [float(row[2]) for row in ohlcv]
    low = [float(row[3]) for row in ohlcv]
    close = [float(row[4]) for row in ohlcv]
    tr = []
    for i in range(1, len(ohlcv)):
        tr.append(max(
            high[i] - low[i],
            abs(high[i] - close[i-1]),
            abs(low[i] - close[i-1])
        ))
    if len(tr) < period:
        return np.mean(tr) if tr else 0.0
    atr = np.mean(tr[-period:])
    return atr

def calculate_bollinger_bands(ohlcv, period=20, multiplier=2):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return (0.0, 0.0)
    moving_avg = np.mean(closes[-period:])
    std_dev = np.std(closes[-period:])
    upper_band = moving_avg + (std_dev * multiplier)
    lower_band = moving_avg - (std_dev * multiplier)
    return upper_band, lower_band



### FILE: ./strategies/momentum.py
from strategies.indicators import calculate_ema

class MomentumStrategy:
    def suits(self, market_type: str) -> bool:
        # Nur in klaren Trends sinnvoll!
        return market_type == "trend"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 11:
            return None
        # Momentum = aktueller Schluss minus vor 10 Perioden
        momentum = closes[-1] - closes[-10]
        if momentum > 0:
            return "BUY"
        elif momentum < 0:
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.2 * atr
        tp = price + 2.0 * atr
        return sl, tp



### FILE: ./strategies/range_trading.py
from strategies.indicators import calculate_ema

class RangeTradingStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 21:
            return None
        highs = [float(row[2]) for row in ohlcv[-21:]]
        lows = [float(row[3]) for row in ohlcv[-21:]]
        price = closes[-1]
        # Kauf am unteren Bereich, Verkauf am oberen Bereich der Range
        if price <= min(lows[:-1]) * 1.01:
            return "BUY"
        elif price >= max(highs[:-1]) * 0.99:
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 0.8 * atr
        tp = price + 1.6 * atr
        return sl, tp



### FILE: ./strategies/reversal.py
from strategies.indicators import calculate_rsi

class ReversalStrategy:
    def suits(self, market_type: str) -> bool:
        # Nur sinnvoll im Seitwärtsmarkt
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 15:
            return None
        rsi = calculate_rsi(ohlcv, 14)
        if rsi > 75:
            return "SELL"
        elif rsi < 25:
            return "BUY"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.3 * atr
        tp = price + 2.2 * atr
        return sl, tp



### FILE: ./strategies/rsi_ema.py
from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr

class RSIEMAStrategy:
    def __init__(self, rsi_period=14, ema_period=50):
        self.rsi_period = rsi_period
        self.ema_period = ema_period

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        rsi = calculate_rsi(ohlcv, self.rsi_period)
        ema = calculate_ema(ohlcv, self.ema_period)
        price = closes[-1]

        # Long wenn RSI unter 32 UND über EMA (bullisher Dip)
        if rsi < 32 and price > ema:
            return "BUY"
        # Short wenn RSI über 68 UND unter EMA (bearisher Spike)
        elif rsi > 68 and price < ema:
            return "SELL"
        else:
            return None

    def sl_tp(self, price, atr):
        sl = price - 1.5 * atr
        tp = price + 3.5 * atr
        return sl, tp

    def score(self, ohlcv, market_type):
        # Sehr gut in trendarmen oder schwankenden Märkten
        if market_type == "sideways":
            return 1
        return 0



### FILE: ./strategies/volatility.py
from strategies.indicators import calculate_atr, calculate_ema

class VolatilityStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "volatile"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 50:
            return None
        atr = calculate_atr(ohlcv, 14)
        ema50 = calculate_ema(ohlcv, 50)
        price = closes[-1]
        if atr > price * 0.02:  # Nur sehr volatile Märkte
            if price > ema50:
                return "BUY"
            elif price < ema50:
                return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 2.5 * atr
        tp = price + 5.0 * atr
        return sl, tp



### FILE: ./utils/backtester.py
# utils/backtester.py — Version 1.0.2

import os
import asyncio
import csv
import math
from datetime import datetime
from statistics import mean, pstdev
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.indicators import calculate_ema, calculate_rsi, ATR
from utils.logger import logger
from dotenv import load_dotenv


__version__ = "1.0.2"

class Backtester:
    def __init__(self, symbol: str, start: str, end: str,
                 granularity: str = '1h', initial_balance: float = 20.0):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.granularity = granularity
        self.initial_balance = initial_balance
        self.client = None
        self.executor = None
        self.reset()

    def reset(self):
        self.balance = self.initial_balance
        self.pos = None
        self.trades = []
        self.equity_curve = [self.initial_balance]

    async def run(self):
        # Lade API-Konfig aus .env
        load_dotenv()
        api_key = os.getenv("BINANCE_API_KEY")
        api_secret = os.getenv("BINANCE_API_SECRET")
        testnet = os.getenv("USE_TESTNET", "True").lower() == "true"

        # BinanceClient asynchron initialisieren
        self.client = await BinanceClient.create(api_key, api_secret, testnet)
        self.executor = TradeExecutor(self.client)

        logger.info(f"📊 Backtest für {self.symbol} gestartet…")
        ohlcv = await self.client.fetch_ohlcv(
            self.symbol, self.granularity,
            since=self._ts(self.start),
            until=self._ts(self.end)
        )

        for i in range(len(ohlcv)):
            ts, o, h, l, c, v = ohlcv[i]
            time = datetime.utcfromtimestamp(ts/1000)

            # Indikatoren berechnen
            window_ema = [row[4] for row in ohlcv[max(0, i-50):i+1]]
            window_rsi = [row[4] for row in ohlcv[max(0, i-15):i+1]]
            window_atr = ohlcv[max(0, i-15):i+1]
            ema = calculate_ema(window_ema, period=20)
            rsi = calculate_rsi(window_rsi, period=14)
            atr = calculate_atr(window_atr, period=14)

            # Entry-Signale
            if not self.pos:
                if c > ema and rsi < 30:
                    signal = 'BUY'
                elif c < ema and rsi > 70:
                    signal = 'SELL'
                else:
                    signal = None

                if signal:
                    qty = self.balance / c
                    res = await self.executor.execute_trade(
                        self.symbol, signal, qty,
                        atr_period=14, sl_multiplier=1.5, tp_multiplier=3.0,
                        martingale_factor=1.0, paper=True
                    )
                    self.pos = {
                        'entry_time': time,
                        'entry_price': res['entry_price'],
                        'sl': res['sl_price'],
                        'tp': res['tp_price'],
                        'qty': res['qty'],
                        'side': signal
                    }

            # Exit-Logik
            if self.pos:
                price = c
                side = self.pos['side']
                exit_trade = False
                if side == 'BUY' and (price <= self.pos['sl'] or price >= self.pos['tp']):
                    exit_trade = True
                elif side == 'SELL' and (price >= self.pos['sl'] or price <= self.pos['tp']):
                    exit_trade = True

                if exit_trade:
                    pnl = (price - self.pos['entry_price']) * self.pos['qty']
                    if side == 'SELL':
                        pnl *= -1
                    self.balance += pnl
                    self.trades.append({
                        'entry': self.pos['entry_price'],
                        'exit': price,
                        'pnl': pnl
                    })
                    self.equity_curve.append(self.balance)
                    logger.info(
                        f"[Backtest] {side} {self.symbol} Entry={self.pos['entry_price']:.2f} Exit={price:.2f} P&L={pnl:.4f} Bal={self.balance:.4f}"
                    )
                    self.pos = None

        stats = self._compute_metrics()
        self._save_results(stats)
        logger.info(f"📈 Backtest abgeschlossen — Endbalance: {self.balance:.2f} — Stats: {stats}")

    def _compute_metrics(self):
        returns = []
        peak = self.initial_balance
        max_dd = 0
        wins = 0

        for bal in self.equity_curve[1:]:
            ret = (bal - peak) / peak
            returns.append(ret)
            if bal > peak:
                peak = bal
            dd = (peak - bal) / peak
            max_dd = max(max_dd, dd)
            if ret > 0:
                wins += 1

        win_rate = wins / len(returns) if returns else 0
        avg_ret = mean(returns) if returns else 0
        std_ret = pstdev(returns) if len(returns) > 1 else 0.0001
        sharpe = (avg_ret / std_ret) * math.sqrt(8760) if std_ret else 0
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        return {
            'total_return': total_return,
            'max_drawdown': max_dd,
            'win_rate': win_rate,
            'sharpe_ratio': sharpe
        }

    def _save_results(self, stats: dict):
        base = f"backtest_{self.symbol}_{self.start}_{self.end}"
        with open(f"{base}.csv", 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=['entry', 'exit', 'pnl'])
            writer.writeheader()
            for t in self.trades:
                writer.writerow(t)
        with open(f"{base}_stats.txt", 'w') as f:
            for k, v in stats.items():
                f.write(f"{k}: {v}\n")

    @staticmethod
    def _ts(date_str: str) -> int:
        dt = datetime.fromisoformat(date_str)
        return int(dt.timestamp() * 1000)



### FILE: ./utils/cooldown_manager.py
# utils/cooldown_manager.py

from datetime import datetime, timedelta

class CooldownManager:
    def __init__(self, cooldown_minutes=30):
        self.cooldowns = {}  # symbol → datetime
        self.cooldown_duration = timedelta(minutes=cooldown_minutes)

    def is_in_cooldown(self, symbol: str) -> bool:
        now = datetime.utcnow()
        last = self.cooldowns.get(symbol)
        return last and (now - last) < self.cooldown_duration

    def update_cooldown(self, symbol: str):
        self.cooldowns[symbol] = datetime.utcnow()



### FILE: ./utils/drawdown_guard.py
# utils/drawdown_guard.py

from datetime import datetime
import pandas as pd

class DrawdownGuard:
    def __init__(self, csv_file="paper_trades.csv", start_balance=20.0, max_loss_pct=5.0):
        self.csv_file = csv_file
        self.start_balance = start_balance
        self.max_loss_pct = max_loss_pct

    def loss_today_exceeded(self) -> bool:
        try:
            df = pd.read_csv(self.csv_file)
            df = df[df["pnl"].notna()]
            today = datetime.utcnow().date()
            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df[df["timestamp"].dt.date == today]

            if df.empty:
                return False

            pnl_sum = df["pnl"].sum()
            loss_pct = -pnl_sum / self.start_balance * 100 if pnl_sum < 0 else 0

            return loss_pct >= self.max_loss_pct
        except Exception:
            return False  # Lieber weiter traden als fälschlich stoppen



### FILE: ./utils/equity_plot.py
# utils/equity_plot.py

import pandas as pd
import matplotlib.pyplot as plt
import os
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

def plot_equity_curve(csv_file=CSV_PATH, out_file="equity_curve.png"):
    df = pd.read_csv(csv_file)
    df["time"] = pd.to_datetime(df["time"])
    df = df.sort_values("time")

    # Equity berechnen
    equity = []
    balance = 20  # Startwert
    for _, row in df.iterrows():
        if pd.notna(row["pnl"]):
            balance += row["pnl"]
        equity.append(balance)

    df["equity"] = equity

    plt.figure(figsize=(10, 5))
    plt.plot(df["time"], df["equity"], label="Equity Curve", color="green")
    plt.title("Equity Curve (Paper-Trades)")
    plt.xlabel("Zeit")
    plt.ylabel("USDC")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_file), exist_ok=True)
    plt.savefig(out_file)
    plt.close()



### FILE: ./utils/logger.py
# utils/logger.py — Version 1.0.2

import logging
import os
import sys
from logging.handlers import RotatingFileHandler

LOG_DIR = "logs"
LOG_FILE = os.path.join(LOG_DIR, "bot.log")

def setup_logger(name="bot"):
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', "%Y-%m-%d %H:%M:%S")

    # File Handler
    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5*1024*1024, backupCount=2)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Console Handler (optional)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Prevent duplicate logs
    logger.propagate = False

    return logger

# Global Logger
logger = setup_logger()

# Capture unhandled exceptions
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception



### FILE: ./utils/market_classifier.py
# utils/market_classifier.py

import numpy as np
from strategies.indicators import calculate_ema, calculate_atr

def classify_market(ohlcv):
    """
    Klassifiziert den Markt als 'trend', 'sideways' oder 'volatile' basierend auf EMA, ATR und Preisdynamik.
    """
    closes = [row[4] for row in ohlcv]
    highs = [row[2] for row in ohlcv]
    lows = [row[3] for row in ohlcv]

    # Trendbestimmung über EMA-Slope und Abstand
    ema50 = calculate_ema(ohlcv, 50)
    ema200 = calculate_ema(ohlcv, 200)
    price = closes[-1]
    slope = ema50 - ema50 if len(closes) < 52 else (ema50 - calculate_ema(ohlcv[-52:], 50))

    # ATR (Volatilität)
    atr = calculate_atr(ohlcv, 14)
    price_range = max(highs[-20:]) - min(lows[-20:])
    vola_ratio = atr / price if price != 0 else 0

    # Dynamische Schwellen (tune nach Wunsch!)
    strong_trend = abs(ema50 - ema200) / price > 0.01 and abs(slope) > 0.05 * price  # mind. 1% EMA-Diff, steile Steigung
    very_volatile = vola_ratio > 0.025 or price_range / price > 0.05  # 2.5% ATR oder 5% Range in 20 Kerzen

    if strong_trend:
        return "trend"
    elif very_volatile:
        return "volatile"
    else:
        return "sideways"



### FILE: ./utils/risk_manager.py
# utils/risk_manager.py

class RiskManager:
    def __init__(self, initial_balance: float = 20.0, max_risk_per_trade: float = 0.02):
        self.balance = initial_balance
        self.risk_pct = max_risk_per_trade  # z. B. 2 %

    def update_balance(self, new_balance: float):
        self.balance = new_balance

    def calculate_position_size(self, entry_price: float, stop_loss: float) -> float:
        sl_distance = abs(entry_price - stop_loss)
        if sl_distance == 0:
            return 0.0  # keine sinnvolle Positionsgröße möglich
        risk_amount = self.balance * self.risk_pct
        qty = risk_amount / sl_distance
        return round(qty, 6)



### FILE: ./utils/signal_filter.py
# utils/signal_filter.py

from strategies.indicators import calculate_ema, calculate_atr

class SignalFilter:
    def __init__(self, volume_factor=1.2, atr_threshold=0.001, trend_strength=0.001):
        self.volume_factor = volume_factor       # z. B. 1.2x über 10er-Avg
        self.atr_threshold = atr_threshold       # z. B. mind. 0.1 % Bewegung
        self.trend_strength = trend_strength     # z. B. Preisabstand zu EMA20 > 0.1 %

    def passes_filters(self, ohlcv) -> bool:
        closes = [c[4] for c in ohlcv]
        highs = [c[2] for c in ohlcv]
        lows = [c[3] for c in ohlcv]
        volumes = [c[5] for c in ohlcv]

        # Trend-Erkennung
        ema = calculate_ema(ohlcv, 20)
        price = closes[-1]
        trend_diff = abs(price - ema) / ema
        if trend_diff < self.trend_strength:
            return False  # Kein klarer Trend

        # Volumen-Filter
        avg_vol = sum(volumes[-11:-1]) / 10
        if volumes[-1] < avg_vol * self.volume_factor:
            return False  # Kein Volumenimpuls

        # ATR-basierte Volatilitätsprüfung
        atr = calculate_atr(ohlcv, 14)
        if atr / price < self.atr_threshold:
            return False  # Markt zu ruhig

        return True  # Alles passt



### FILE: ./utils/strategy_watchdog.py
# utils/strategy_watchdog.py

import csv
import os
from datetime import datetime
from collections import defaultdict

WATCHDOG_FILE = "strategy_watchdog.csv"

class StrategyWatchdog:
    def __init__(self):
        self.stats = defaultdict(lambda: {"trades": 0, "wins": 0, "losses": 0})
        self._load_existing()

    def _load_existing(self):
        if not os.path.isfile(WATCHDOG_FILE):
            return
        with open(WATCHDOG_FILE, mode="r") as f:
            reader = csv.DictReader(f)
            for row in reader:
                strat = row["strategy"]
                self.stats[strat] = {
                    "trades": int(row["trades"]),
                    "wins": int(row["wins"]),
                    "losses": int(row["losses"])
                }

    def record_trade(self, strategy_name: str, pnl: float):
        stat = self.stats[strategy_name]
        stat["trades"] += 1
        if pnl > 0:
            stat["wins"] += 1
        else:
            stat["losses"] += 1
        self._save()

    def _save(self):
        with open(WATCHDOG_FILE, mode="w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["strategy", "trades", "wins", "losses"])
            for strat, s in self.stats.items():
                writer.writerow([strat, s["trades"], s["wins"], s["losses"]])



### FILE: ./utils/trade_logger.py
# utils/trade_logger.py

import csv
import os
from datetime import datetime

TRADE_LOG_FILE = "paper_trades.csv"

def log_trade(symbol, side, entry_price, sl, tp, qty, pnl=None, strategy=None):
    file_exists = os.path.isfile(TRADE_LOG_FILE)
    with open(TRADE_LOG_FILE, mode='a', newline='') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow([
                "timestamp", "symbol", "side", "entry_price",
                "stop_loss", "take_profit", "qty", "pnl"
            ])
        writer.writerow([
	    datetime.utcnow().isoformat(), symbol, side, entry_price,
    	sl, tp, qty, pnl if pnl is not None else "", strategy or ""
	])



### FILE: ./utils/trade_tracker.py
import pandas as pd
from datetime import datetime
from utils.trade_logger import log_trade

def update_trade_pnls(csv_file="paper_trades.csv", current_prices=None):
    expected_cols = ["time", "symbol", "side", "entry_price", "stop_loss", "take_profit", "qty", "pnl", "strategy"]
    df = pd.read_csv(csv_file, names=expected_cols, header=0)

    # Fehlende Spalten ergänzen (alte Zeilen/alte CSV)
    for col in expected_cols:
        if col not in df.columns:
            df[col] = None

    updated = False

    for idx, row in df[df["pnl"].isna()].iterrows():
        symbol = row["symbol"]
        price = current_prices.get(symbol)
        if price is None:
            continue

        side = row["side"]
        entry = row["entry_price"]
        sl = row["stop_loss"]
        tp = row["take_profit"]
        qty = row["qty"]

        pnl = None
        # Prüfen, ob SL oder TP erreicht wurde
        if side == "BUY" and (price <= sl or price >= tp):
            pnl = (price - entry) * qty
        elif side == "SELL" and (price >= sl or price <= tp):
            pnl = (entry - price) * qty

        # Nur wenn Trade geschlossen wurde:
        if pnl is not None:
            df.at[idx, "pnl"] = pnl
            updated = True

            # Optional: Watchdog informieren, falls Strategie geloggt wurde
            strategy_name = row.get("strategy", "Unknown")
            try:
                from utils.strategy_watchdog import StrategyWatchdog
                StrategyWatchdog().record_trade(strategy_name=strategy_name, pnl=pnl)
            except Exception as e:
                print(f"[Watchdog] Fehler bei Strategie-Tracking: {e}")

    if updated:
        df.to_csv(csv_file, index=False)



### FILE: ./bot.py
#!/usr/bin/env python3
# bot.py — Version 1.0.1

import os
import asyncio
from dotenv import load_dotenv
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from utils.backtester import Backtester
from utils.logger import logger

__version__ = "1.0.1"

def load_config():
    load_dotenv()
    return {
        "api_key": os.getenv("BINANCE_API_KEY"),
        "api_secret": os.getenv("BINANCE_API_SECRET"),
        "testnet": os.getenv("USE_TESTNET", "True").lower() == "true",
        "symbol": os.getenv("SYMBOL", "BTCUSDC"),
        "backtest_start": os.getenv("BACKTEST_START", "2025-01-01T00:00"),
        "backtest_end": os.getenv("BACKTEST_END", "2025-06-01T00:00"),
        "granularity": os.getenv("GRANULARITY", "1h"),
        "initial_balance": float(os.getenv("INITIAL_BALANCE", "20.0")),
        "trade_quantity": float(os.getenv("TRADE_QUANTITY", "0.001")),
        "paper_trading": os.getenv("PAPER_TRADING", "True").lower() == "true",
        "atr_period": int(os.getenv("ATR_PERIOD", "14")),
        "sl_multiplier": float(os.getenv("SL_MULTIPLIER", "1.5")),
        "tp_multiplier": float(os.getenv("TP_MULTIPLIER", "3.0")),
        "martingale_factor": float(os.getenv("MARTINGALE_FACTOR", "1.0")),
    }

async def main():
    cfg = load_config()
    logger.info(f"🚀 Starting Grok-FuturesBot v{__version__}")

    # 1) Backtest
    logger.info("🔍 Running backtest…")
    bt = Backtester(
        symbol=cfg["symbol"],
        start=cfg["backtest_start"],
        end=cfg["backtest_end"],
        granularity=cfg["granularity"],
        initial_balance=cfg["initial_balance"],
    )
    await bt.run()

    # 2) Live-/Paper-Trading Beispiel
    logger.info("💡 Starting live/paper trading example…")
    client = await BinanceClient.create(
        api_key=cfg["api_key"],
        api_secret=cfg["api_secret"],
        testnet=cfg["testnet"],
    )
    executor = TradeExecutor(client)
    result = await executor.execute_trade(
        symbol=cfg["symbol"],
        side="BUY",
        quantity=cfg["trade_quantity"],
        atr_period=cfg["atr_period"],
        sl_multiplier=cfg["sl_multiplier"],
        tp_multiplier=cfg["tp_multiplier"],
        martingale_factor=cfg["martingale_factor"],
        paper=cfg["paper_trading"],
    )
    logger.info(
        f"🎯 Trade result (paper={cfg['paper_trading']}): Entry={result['entry_price']}, SL={result['sl_price']}, TP={result['tp_price']}"
    )

if __name__ == "__main__":
    asyncio.run(main())



### FILE: ./core/client.py
# core/client.py — Version 1.0.2

import asyncio
import ccxt.async_support as ccxt
from binance import AsyncClient
from utils.logger import logger

class BinanceClient:
    def __init__(self, client: AsyncClient):
        self.client = client

    @classmethod
    async def create(cls, api_key: str, api_secret: str, testnet: bool = False):
        logger.info(f"🔌 Verbinde mit Binance (testnet={testnet})...")
        client = await AsyncClient.create(
            api_key=api_key,
            api_secret=api_secret,
            testnet=testnet
        )
        return cls(client)

    async def get_futures_price(self, symbol: str) -> float:
        ticker = await self.client.futures_symbol_ticker(symbol=symbol)
        return float(ticker["price"])

    async def fetch_ohlcv(self, symbol: str, timeframe: str, since: int = None, limit: int = None, until: int = None):
        exchange = ccxt.binance({
            'enableRateLimit': True,
            'options': {
                'defaultType': 'future'
            }
        })
        if since and until:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since)
            ohlcv = [c for c in ohlcv if c[0] <= until]
        else:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
        await exchange.close()
        return ohlcv

    async def futures_change_leverage(self, symbol: str, leverage: int):
        """
        Setzt das Leverage für ein Futures-Symbol.
        """
        try:
            result = await self.client.futures_change_leverage(symbol=symbol, leverage=leverage)
            logger.info(f"[LEVERAGE] {symbol}: Leverage wurde auf {leverage}x gesetzt. Antwort: {result}")
            return result
        except Exception as e:
            logger.error(f"[LEVERAGE] Fehler beim Setzen des Leverage für {symbol}: {e}")
            raise

    async def close(self):
        await self.client.close_connection()



### FILE: ./core/trade_executor.py
from utils.logger import logger
from strategies.indicators import calculate_atr
from binance.enums import *

SIDE_Buy = "Buy"

class TradeExecutor:
    def __init__(self, client, base_currency: str = "USDC"):
        self.client = client
        self.base_currency = base_currency

    async def execute_trade(
        self,
        symbol: str,
        side: str,
        quantity: float,
        sl: float = None,
        tp: float = None,
        atr_period: int = 14,
        sl_multiplier: float = 1.5,
        tp_multiplier: float = 3.0,
        martingale_factor: float = 1.0,
        paper: bool = True
    ):
        qty = quantity * martingale_factor
        logger.info(f"Placing {side} order for {symbol} qty={qty:.6f} (martingale={martingale_factor})")

        # Preis ermitteln
        if paper:
            price = await self.client.get_futures_price(symbol)
            logger.info(f"(Paper) Order simulated at {price}")
        else:
            order = await self.client.client.futures_create_order(
                symbol=symbol,
                side=side,
                type=FUTURE_ORDER_TYPE_MARKET,
                quantity=qty
            )
            price = float(order["avgPrice"])
            logger.info(f"Order executed at price={price}")

        # SL/TP berechnen wenn nicht manuell übergeben
        if sl is None or tp is None:
            ohlcv = await self.client.fetch_ohlcv(symbol, timeframe='1h', limit=atr_period + 1)
            atr = calculate_atr(ohlcv, period=atr_period)
            sl, tp = self._compute_sl_tp(price, atr, side, sl_multiplier, tp_multiplier)

        return {
            "entry_price": price,
            "sl_price": sl,
            "tp_price": tp,
            "qty": qty
        }

    def _compute_sl_tp(self, entry: float, atr: float, side: str,
                       sl_mult: float, tp_mult: float):
        if side == SIDE_BUY:
            sl = entry - atr * sl_mult
            tp = entry + atr * tp_mult
        else:
            sl = entry + atr * sl_mult
            tp = entry - atr * tp_mult
        return sl, tp



### FILE: ./daily_report.py
import os
import sys
import pandas as pd
from utils.email_notify import send_email
from datetime import date

# Passe den Pfad ggf. an!
df = pd.read_csv('/home/idppadm/trading-bot/ml/training_data.csv')

# Nur echte Paper-Trades (wie Dashboard):
df_trades = df[(df['signal'].notna()) & (df['result'].notna()) & (df['type'] == "paper")]

today = str(date.today())
df_today = df_trades[df_trades['timestamp'].str.startswith(today)]

if not df_today.empty:
    n_trades = len(df_today)
    n_wins = (df_today['result'] == 1).sum()
    n_losses = (df_today['result'] == 0).sum()
    winrate = 100 * n_wins / n_trades if n_trades else 0

    body = f"""Trading-Bot Tagesreport {today}

Trades: {n_trades}
Wins: {n_wins}
Losses: {n_losses}
Winrate: {winrate:.1f}%

Die letzten 5 Trades:
{df_today.tail(5).to_string(index=False)}
"""
else:
    body = f"Trading-Bot Tagesreport {today}\n\nHeute wurden keine Trades ausgeführt."

send_email(
    subject=f"TradingBot Tagesreport {today}",
    body=body
)



### FILE: ./dashboard/app.py
from flask import Flask, render_template, send_file
import os
import sys
import pandas as pd
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.equity_plot import plot_equity_curve
from utils.trade_logger import log_trade 
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

app = Flask(__name__)

@app.route("/")
def index():
    # Equity-Kurve aktualisieren
    plot_equity_curve(CSV_PATH, "dashboard/static/equity_curve.png")

    # Daten aus CSV laden
    df = pd.read_csv(CSV_PATH)
    df_closed = df[df["pnl"].notna()]
    balance = 20.0 + df_closed["pnl"].sum()
    winrate = (df_closed["pnl"] > 0).mean() * 100 if not df_closed.empty else 0

    return render_template("index.html", 
        balance=round(balance, 2),
        total_trades=len(df),
        winrate=round(winrate, 1),
        trades=df.tail(10).to_dict(orient="records")
    )

@app.route("/chart")
def chart():
    return send_file("static/equity_curve.png", mimetype='image/png')

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)



### FILE: ./ml/analyze_backtest.py
import os
import sys
import pandas as pd
from datetime import datetime
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from ml.collect_training_data import append_training_data

# Beispiel: Backtest-Resultate laden und loggen
def analyze_backtest(backtest_csv_path="ml/backtest_results.csv"):
    df = pd.read_csv(backtest_csv_path)
    print(f"Analysiere {len(df)} Backtest-Trades aus {backtest_csv_path}")

    # Beispielhafte Spaltennamen anpassen!
    for idx, row in df.iterrows():
        append_training_data(
            timestamp=row.get("timestamp", datetime.utcnow().isoformat()),
            symbol=row.get("symbol", ""),
            open_=row.get("open", ""),
            high=row.get("high", ""),
            low=row.get("low", ""),
            close=row.get("close", ""),
            volume=row.get("volume", ""),
            rsi=row.get("rsi", ""),
            ema=row.get("ema", ""),
            atr=row.get("atr", ""),
            bb_upper=row.get("bb_upper", ""),
            bb_lower=row.get("bb_lower", ""),
            market_state=row.get("market_state", ""),
            strategy=row.get("strategy", ""),
            signal=row.get("signal", ""),
            result=row.get("result", ""),
            type="backtest"
        )
    print("Alle Backtest-Trades wurden ins Training-CSV geschrieben.")

if __name__ == "__main__":
    analyze_backtest()



### FILE: ./ml/backtest_data_import.py
import os
import csv
import time
from datetime import datetime
import ccxt
from tqdm import tqdm
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from strategies.indicators import calculate_ema, calculate_rsi, calculate_atr, calculate_bollinger_bands
from strategies.engine import StrategyEngine

# Konfiguration
EXCHANGE = ccxt.binance({
    'rateLimit': 1200,
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})

OUTPUT_FILE = "ml/training_data_backtest.csv"
SYMBOLS = ["BTC/USDC", "ETH/USDC", "SOL/USDC"]  # Beliebig erweiterbar
TIMEFRAME = "1h"
START_DATE = "2024-01-01T00:00:00Z"  # YYYY-MM-DDTHH:MM:SSZ
END_DATE = "2024-06-30T00:00:00Z"

# Helper
def parse_iso8601(date_str):
    return int(EXCHANGE.parse8601(date_str))

def ohlcv_to_dict(symbol, ohlcv, strategy, market_state):
    # ohlcv: [timestamp, open, high, low, close, volume]
    close = float(ohlcv[4])
    ema = calculate_ema([ohlcv], 1)     # Für Einzelkerze = Kerzenwert
    rsi = calculate_rsi([ohlcv], 1)
    atr = calculate_atr([ohlcv], 1)
    bb_upper, bb_lower = calculate_bollinger_bands([ohlcv], 1)
    return {
        "timestamp": datetime.utcfromtimestamp(ohlcv[0]/1000).isoformat(),
        "symbol": symbol,
        "open": ohlcv[1],
        "high": ohlcv[2],
        "low": ohlcv[3],
        "close": ohlcv[4],
        "volume": ohlcv[5],
        "ema": ema,
        "rsi": rsi,
        "atr": atr,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "market_state": market_state,
        "strategy": strategy,
        "signal": "",    # Noch leer (optional für späteren Backtest/ML-Label)
        "result": ""
    }

def fetch_all_ohlcv(symbol, timeframe, since, until):
    all_candles = []
    limit = 1000
    now = since
    pbar = tqdm(desc=f"Lade {symbol}", total=(until-since)//(60*60*1000))
    while now < until:
        candles = EXCHANGE.fetch_ohlcv(symbol, timeframe, since=now, limit=limit)
        if not candles:
            break
        for c in candles:
            if c[0] > until:
                break
            all_candles.append(c)
        now = candles[-1][0] + 1
        pbar.update(len(candles))
        time.sleep(0.1)
    pbar.close()
    return all_candles

def main():
    # Setup
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, "w", newline='') as f:
        fieldnames = [
            "timestamp", "symbol", "open", "high", "low", "close", "volume",
            "ema", "rsi", "atr", "bb_upper", "bb_lower",
            "market_state", "strategy", "signal", "result"
        ]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()

        engine = StrategyEngine()
        for symbol in SYMBOLS:
            since = parse_iso8601(START_DATE)
            until = parse_iso8601(END_DATE)
            ohlcv_data = fetch_all_ohlcv(symbol, TIMEFRAME, since, until)
            # Sliding-Window für Indikatoren und Strategieauswahl:
            window = []
            for row in tqdm(ohlcv_data, desc=f"Verarbeite {symbol}"):
                window.append(row)
                if len(window) > 50:
                    window = window[-50:]  # nur die letzten 50 Kerzen
                # Marktzustand und Strategie wählen:
                market_state = engine.evaluate_market(window) if len(window) >= 20 else ""
                strategy = engine.select_strategy(window).__class__.__name__ if len(window) >= 20 else ""
                writer.writerow(
                    ohlcv_to_dict(symbol, row, strategy, market_state)
                )

if __name__ == "__main__":
    main()



### FILE: ./ml/backtest_engine.py
import sys
import os
import asyncio
import pandas as pd

# Damit die Importe klappen, egal von wo du startest:
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import ccxt.async_support as ccxt

from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr, calculate_bollinger_bands
from strategies.rsi_ema import RSIEMAStrategy
from strategies.momentum import MomentumStrategy
from strategies.volatility import VolatilityStrategy
from strategies.breakout import BreakoutStrategy
from strategies.reversal import ReversalStrategy

STRATEGIES = [
    ("rsi_ema", RSIEMAStrategy()),
    ("momentum", MomentumStrategy()),
    ("volatility", VolatilityStrategy()),
    ("breakout", BreakoutStrategy()),
    ("reversal", ReversalStrategy())
]

async def fetch_ohlcv_ccxt(symbol, timeframe="1h", since=None, limit=1000):
    exchange = ccxt.binance({
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })
    ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
    await exchange.close()
    return ohlcv

def simulate_trade(entry, side, sl, tp, ohlcv_next):
    for row in ohlcv_next:
        price = float(row[4])
        if side == "BUY":
            if price <= sl:
                return sl, (sl - entry)
            elif price >= tp:
                return tp, (tp - entry)
        elif side == "SELL":
            if price >= sl:
                return sl, (entry - sl)
            elif price <= tp:
                return tp, (entry - tp)
    return price, (price - entry) if side == "BUY" else (entry - price)

def run_backtest(symbol, ohlcv, out_csv="ml/backtest_results.csv", lookahead=10):
    results = []
    for i in range(50, len(ohlcv) - lookahead):
        sub_ohlcv = ohlcv[:i]
        future_ohlcv = ohlcv[i:i+lookahead]
        price = float(ohlcv[i][4])
        atr = calculate_atr(sub_ohlcv, 14)
        for strat_name, strat in STRATEGIES:
            signal = strat.generate_signal(sub_ohlcv)
            if signal:
                sl, tp = strat.sl_tp(price, atr)
                exit_price, pnl = simulate_trade(price, signal, sl, tp, future_ohlcv)
                results.append({
                    "timestamp": ohlcv[i][0],
                    "symbol": symbol,
                    "strategy": strat_name,
                    "side": signal,
                    "entry": price,
                    "sl": sl,
                    "tp": tp,
                    "exit": exit_price,
                    "pnl": pnl
                })
                
    out_dir = os.path.dirname(out_csv)
    if out_dir and not os.path.exists(out_dir):
        os.makedirs(out_dir)
            
    pd.DataFrame(results).to_csv(out_csv, index=False)
    print(f"Backtest für {symbol} abgeschlossen – {len(results)} Trades.")

async def main(symbol="BTCUSDT", timeframe="1h", candles=1000, out_csv="ml/backtest_results.csv"):
    print(f"Lade OHLCV für {symbol}, Intervall {timeframe}, Anzahl {candles} ...")
    ohlcv = await fetch_ohlcv_ccxt(symbol, timeframe=timeframe, limit=candles)
    run_backtest(symbol, ohlcv, out_csv=out_csv)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--symbol", default="BTCUSDT", help="Symbol, z.B. BTCUSDT")
    parser.add_argument("--timeframe", default="1h", help="Kerzenintervall, z.B. 1h, 15m, 5m")
    parser.add_argument("--candles", type=int, default=1000, help="Anzahl Kerzen")
    parser.add_argument("--out", default="ml/backtest_results.csv", help="Ziel-Datei")
    args = parser.parse_args()
    asyncio.run(main(symbol=args.symbol, timeframe=args.timeframe, candles=args.candles, out_csv=args.out))



### FILE: ./ml/collect_training_data.py
import csv
import os
from threading import Lock

file_lock = Lock()

def append_training_data(
    timestamp,
    symbol,
    open_,
    high,
    low,
    close,
    volume,
    rsi,
    ema,
    atr,
    bb_upper,
    bb_lower,
    market_state,
    strategy,
    signal,
    result,
    type="live",
    filename="ml/training_data.csv"
):
    """
    Loggt einen Datensatz für das ML-Training.
    """
    fieldnames = [
        "timestamp", "symbol", "open", "high", "low", "close", "volume", "rsi", "ema", "atr",
        "bb_upper", "bb_lower", "market_state", "strategy", "signal", "result", "type"
    ]
    file_exists = os.path.isfile(filename)
    data = {
        "timestamp": timestamp,
        "symbol": symbol,
        "open": open_,
        "high": high,
        "low": low,
        "close": close,
        "volume": volume,
        "rsi": rsi,
        "ema": ema,
        "atr": atr,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "market_state": market_state,
        "strategy": strategy,
        "signal": signal,
        "result": result,
        "type": type
    }
    with file_lock:
        with open(filename, mode="a", newline="") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            if not file_exists:
                writer.writeheader()
            writer.writerow(data)



### FILE: ./ml/feature_engineering_ml.py
import os
import sys
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split, cross_val_score

# Daten laden
df = pd.read_csv("ml/training_data.csv")

# ------- FLEXIBLE FILTERUNG -------
# Wähle hier, was du analysieren willst:
# df = df[df['type'] == "paper"]           # Nur Paper-Trades
# df = df[df['type'] == "backtest"]        # Nur Backtests
# df = df[df['type'] == "live"]            # Nur Live-Trades
# df = df[df['type'].isin(["paper", "live"])]  # Nur Paper + Live
filter_type = "paper"   # <--- Passe an (paper, backtest, live)
df = df[df['type'] == filter_type]

# Nur echte Trades: Signal & Result gesetzt!
df_trades = df[(df['signal'].notna()) & (df['result'].notna())].copy()

# ---------- FEATURE ENGINEERING ----------
df_trades['timestamp'] = pd.to_datetime(df_trades['timestamp'], errors='coerce')
df_trades['hour'] = df_trades['timestamp'].dt.hour
df_trades['weekday'] = df_trades['timestamp'].dt.weekday
df_trades['close_change'] = df_trades['close'].pct_change()
df_trades['high_low_range'] = (df_trades['high'] - df_trades['low']) / df_trades['close']
df_trades['atr_relative'] = df_trades['atr'] / df_trades['close']
df_trades['ema_slope_5'] = df_trades['ema'].diff(5)
df_trades['volatility_10'] = df_trades['close'].rolling(10).std()
df_trades['above_ema'] = (df_trades['close'] > df_trades['ema']).astype(int)
df_trades['rsi_change'] = df_trades['rsi'].diff()
df_trades['volume_change'] = df_trades['volume'].pct_change()
df_trades['rolling_max_close_5'] = df_trades['close'].rolling(5).max()
df_trades['rolling_min_close_5'] = df_trades['close'].rolling(5).min()
df_trades = df_trades.dropna().reset_index(drop=True)

# ---------- FEATURE SELECTION ----------
exclude_cols = ['timestamp', 'symbol', 'result', 'strategy', 'signal', 'type']
feature_cols = [col for col in df_trades.columns if col not in exclude_cols]
X = df_trades[feature_cols]
y = df_trades['result']

clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X, y)
importances = clf.feature_importances_
imp_df = pd.DataFrame({'feature': feature_cols, 'importance': importances}).sort_values('importance', ascending=False)
print("\n[Feature Importance]")
print(imp_df)
top_features = imp_df['feature'].head(10).tolist()
print("\n[Top 10 Features fürs Training]:", top_features)
X = df_trades[top_features]

# ---------- MODEL TRAINING & VALIDATION ----------
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)
score = clf.score(X_test, y_test)
print(f"\nRandomForest Accuracy: {score:.4f}")

cv_scores = cross_val_score(clf, X, y, cv=5)
print(f"RandomForest Cross-Validation Accuracy: {cv_scores.mean():.4f} ± {cv_scores.std():.4f}")

# Modell speichern
import joblib
joblib.dump(clf, "ml/best_trading_model.pkl")
print("Bestes Modell gespeichert als ml/best_trading_model.pkl")



### FILE: ./ml/ml_predict.py
# ml/ml_predict.py
import joblib
import pandas as pd

# Modell laden (Pfad ggf. anpassen)
ml_model = joblib.load('ml/best_trading_model.pkl')

FEATURES = [
    'open', 'high', 'low', 'close', 'volume',
    'rsi', 'ema', 'atr', 'bb_upper', 'bb_lower',
    'market_state', 'strategy', 'signal'
]

def predict_trade_signal(trade_dict):
    df = pd.DataFrame([trade_dict])
    # Kategorische Features umcodieren
    for col in ['market_state', 'strategy', 'signal']:
        if col in df.columns and df[col].dtype == 'object':
            df[col] = df[col].astype('category').cat.codes
    # Fehlende Features füllen
    for f in FEATURES:
        if f not in df.columns:
            df[f] = 0
    X = df[FEATURES]
    prediction = ml_model.predict(X)[0]
    probability = ml_model.predict_proba(X)[0][1]
    return prediction, probability



### FILE: ./multi_backtest.py
import asyncio
from utils.backtester import Backtester

symbol_list = ["BTCUSDC", "ETHUSDC", "BNBUSDC", "SOLUSDC"]
start = "2025-01-01T00:00"
end = "2025-06-01T00:00"
granularity = "1h"
initial_balance = 20.0

async def run_backtests():
    tasks = []
    for symbol in symbol_list:
        bt = Backtester(
            symbol=symbol,
            start=start,
            end=end,
            granularity=granularity,
            initial_balance=initial_balance
        )
        tasks.append(bt.run())
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(run_backtests())



### FILE: ./paper_loop.py
import os
import sys
import asyncio
from dotenv import load_dotenv
from datetime import datetime
import aiohttp

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.engine import StrategyEngine
from strategies.indicators import (
    calculate_atr, calculate_ema, calculate_rsi, calculate_bollinger_bands
)
from utils.logger import logger
from utils.trade_logger import log_trade
from utils.trade_tracker import update_trade_pnls
from utils.risk_manager import RiskManager
from utils.cooldown_manager import CooldownManager
from utils.signal_filter import SignalFilter
from utils.drawdown_guard import DrawdownGuard
from utils.strategy_watchdog import StrategyWatchdog
from utils.email_notify import send_email
from ml.collect_training_data import append_training_data

# Einstellungen
load_dotenv()
PAPER = True
INTERVAL = 10
START_BALANCE = 20.0
SYMBOLS = []

# Bot-Komponenten initialisieren
engine = StrategyEngine()
risk_manager = RiskManager(initial_balance=START_BALANCE, max_risk_per_trade=0.02)
cooldown = CooldownManager(cooldown_minutes=30)
signal_filter = SignalFilter()
drawdown_guard = DrawdownGuard(start_balance=START_BALANCE, max_loss_pct=5.0)
watchdog = StrategyWatchdog()

# Abruf der Top 100 USDC-Futures-Paare nach Volumen
async def get_top_usdc_symbols_by_volume(limit=100):
    url = "https://fapi.binance.com/fapi/v1/ticker/24hr"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
            filtered = [
                d for d in data if d["symbol"].endswith("USDC") and float(d["quoteVolume"]) > 100000
            ]
            sorted_pairs = sorted(filtered, key=lambda x: float(x["quoteVolume"]), reverse=True)
            return [item["symbol"] for item in sorted_pairs[:limit]]

# Hauptloop für ein Symbol
async def trade_task(symbol, client, executor):
    try:
        ohlcv = await client.fetch_ohlcv(symbol, "1h", limit=50)
        closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
        price = closes[-1]
        atr = calculate_atr(ohlcv, 14)
        ema = calculate_ema(ohlcv, 50)
        rsi = calculate_rsi(ohlcv, 14)
        bb_upper, bb_lower = calculate_bollinger_bands(ohlcv, 20, 2)

        strategy = engine.select_strategy(ohlcv)
        signal = strategy.generate_signal(ohlcv)
        market_state = engine.evaluate_market(ohlcv)

        # ML-Logging: Immer protokollieren (auch wenn kein Trade ausgelöst wird)
        append_training_data(
            timestamp=datetime.utcnow().isoformat(),
            symbol=symbol,
            open_=ohlcv[-1][1],
            high=ohlcv[-1][2],
            low=ohlcv[-1][3],
            close=ohlcv[-1][4],
            volume=ohlcv[-1][5],
            rsi=rsi,
            ema=ema,
            atr=atr,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            market_state=market_state,
            strategy=strategy.__class__.__name__,
            signal=signal,
            result=None,
            type="paper"
        )

        if not signal:
            logger.info(f"[FILTER] {symbol}: Kein Signal.")
            return

        if cooldown.is_in_cooldown(symbol):
            logger.info(f"[COOLDOWN] {symbol}: aktiv – übersprungen.")
            return

        if not signal_filter.passes_filters(ohlcv):
            logger.info(f"[FILTER] {symbol}: Markt ungeeignet.")
            return

        sl, tp = strategy.sl_tp(price, atr)
        qty = risk_manager.calculate_position_size(entry_price=price, stop_loss=sl)

        if qty <= 0:
            logger.warning(f"[RISK] {symbol}: Ordergröße zu klein – übersprungen.")
            return

        logger.info(f"[TRADE] {symbol}: {signal} @ {price:.2f} SL={sl:.2f} TP={tp:.2f} QTY={qty:.4f}")

        result = await executor.execute_trade(
            symbol=symbol,
            side=signal,
            quantity=qty,
            sl=sl,
            tp=tp,
            paper=PAPER
        )

        log_trade(
            symbol=symbol,
            side=signal,
            entry_price=result["entry_price"],
            sl=sl,
            tp=tp,
            qty=qty,
            strategy=strategy.__class__.__name__
        )

        cooldown.update_cooldown(symbol)

        # ML-Logging: Ergebnis protokollieren (nur bei echtem Trade)
        append_training_data(
            timestamp=datetime.utcnow().isoformat(),
            symbol=symbol,
            open_=ohlcv[-1][1],
            high=ohlcv[-1][2],
            low=ohlcv[-1][3],
            close=ohlcv[-1][4],
            volume=ohlcv[-1][5],
            rsi=rsi,
            ema=ema,
            atr=atr,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            market_state=market_state,
            strategy=strategy.__class__.__name__,
            signal=signal,
            result=result.get("pnl") if result else None,
            type="paper"
        )

    except Exception as e:
        logger.error(f"[{symbol}] Fehler im Loop: {e}")
        # Sende nur relevante Fehler als Mail (keine exchangeInfo-API-Fehler)
        if "exchangeInfo" not in str(e):
            send_email(
                subject=f"TradingBot ERROR [{symbol}]",
                body=f"Fehler im Trading-Bot für {symbol}:\n{e}"
            )

# Trade-Loop für alle Symbole
async def trade_loop():
    global SYMBOLS
    client = await BinanceClient.create(
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
        testnet=os.getenv("USE_TESTNET", "True").lower() == "true"
    )
    executor = TradeExecutor(client)

    SYMBOLS = await get_top_usdc_symbols_by_volume(limit=25)  # Bei RAM-Engpässen hier verringern!

    logger.info(f"📊 Überwachte Paare: {', '.join(SYMBOLS[:10])} ...")

    try:
        while True:
            if drawdown_guard.loss_today_exceeded():
                logger.warning("🛑 Tagesverlustgrenze erreicht – Trading pausiert.")
                await asyncio.sleep(INTERVAL)
                continue

            tasks = [trade_task(symbol, client, executor) for symbol in SYMBOLS]
            await asyncio.gather(*tasks)

            try:
                current_prices = {symbol: await client.get_futures_price(symbol) for symbol in SYMBOLS}
                update_trade_pnls(current_prices=current_prices)
            except Exception as e:
                logger.warning(f"[PnL] Preisabruf fehlgeschlagen: {e}")

            logger.info(f"⏳ Nächster Zyklus in {INTERVAL} Sekunden...\n")
            await asyncio.sleep(INTERVAL)

    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(trade_loop())



### FILE: ./strategies/breakout.py
from strategies.indicators import calculate_atr

class BreakoutStrategy:
    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        highs = [row[2] for row in ohlcv[-21:]]
        lows = [row[3] for row in ohlcv[-21:]]
        price = closes[-1]

        # Buy-Breakout: schließt über dem lokalen Hoch der letzten 20 Kerzen, mit Volumenfilter
        if price > max(highs[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "BUY"
        # Sell-Breakout: schließt unter dem lokalen Tief der letzten 20 Kerzen
        elif price < min(lows[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "SELL"
        else:
            return None

    def sl_tp(self, price, atr):
        # Aggressiver SL/TP für echte Ausbrüche!
        sl = price - 2.0 * atr
        tp = price + 4.0 * atr
        return sl, tp

    def score(self, ohlcv, market_type):
        # Perfekt in klaren Trendphasen!
        if market_type == "trend":
            return 2
        return 0



### FILE: ./strategies/engine.py
from strategies.rsi_ema import RSIEMAStrategy
from strategies.breakout import BreakoutStrategy
from strategies.momentum import MomentumStrategy
from strategies.reversal import ReversalStrategy
from strategies.range_trading import RangeTradingStrategy
from strategies.volatility import VolatilityStrategy

class StrategyEngine:
    def __init__(self):
        self.strategies = [
            RSIEMAStrategy(),
            BreakoutStrategy(),
            MomentumStrategy(),
            ReversalStrategy(),
            RangeTradingStrategy(),
            VolatilityStrategy()
        ]

    def evaluate_market(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 21:
            return "sideways"
        change = abs(closes[-1] - closes[-20]) / closes[-20]
        if change > 0.03:
            return "trend"
        # Einfache Volatilitätsbestimmung
        atr = abs(max(closes[-20:]) - min(closes[-20:])) / closes[-20]
        if atr > 0.04:
            return "volatile"
        return "sideways"

    def select_strategy(self, ohlcv):
        market = self.evaluate_market(ohlcv)
        for strategy in self.strategies:
            if hasattr(strategy, "suits"):
                if strategy.suits(market):
                    return strategy
            # fallback für alte strategien ohne suits()
        return self.strategies[0]



### FILE: ./strategies/indicators.py
import numpy as np

def calculate_rsi(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period + 1:
        return 50.0
    deltas = np.diff(closes)
    gain = np.where(deltas > 0, deltas, 0).sum() / period
    loss = -np.where(deltas < 0, deltas, 0).sum() / period
    if loss == 0:
        return 100.0
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_ema(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return closes[-1] if closes else 0.0
    ema = np.mean(closes[-period:])
    multiplier = 2 / (period + 1)
    for price in closes[-period:]:
        ema = (price - ema) * multiplier + ema
    return ema

def calculate_atr(ohlcv, period=14):
    if len(ohlcv) < period + 1:
        return 0.0
    high = [float(row[2]) for row in ohlcv]
    low = [float(row[3]) for row in ohlcv]
    close = [float(row[4]) for row in ohlcv]
    tr = []
    for i in range(1, len(ohlcv)):
        tr.append(max(
            high[i] - low[i],
            abs(high[i] - close[i-1]),
            abs(low[i] - close[i-1])
        ))
    if len(tr) < period:
        return np.mean(tr) if tr else 0.0
    atr = np.mean(tr[-period:])
    return atr

def calculate_bollinger_bands(ohlcv, period=20, multiplier=2):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return (0.0, 0.0)
    moving_avg = np.mean(closes[-period:])
    std_dev = np.std(closes[-period:])
    upper_band = moving_avg + (std_dev * multiplier)
    lower_band = moving_avg - (std_dev * multiplier)
    return upper_band, lower_band



### FILE: ./strategies/momentum.py
from strategies.indicators import calculate_ema

class MomentumStrategy:
    def suits(self, market_type: str) -> bool:
        # Nur in klaren Trends sinnvoll!
        return market_type == "trend"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 11:
            return None
        # Momentum = aktueller Schluss minus vor 10 Perioden
        momentum = closes[-1] - closes[-10]
        if momentum > 0:
            return "BUY"
        elif momentum < 0:
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.2 * atr
        tp = price + 2.0 * atr
        return sl, tp



### FILE: ./strategies/range_trading.py
from strategies.indicators import calculate_ema

class RangeTradingStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 21:
            return None
        highs = [float(row[2]) for row in ohlcv[-21:]]
        lows = [float(row[3]) for row in ohlcv[-21:]]
        price = closes[-1]
        # Kauf am unteren Bereich, Verkauf am oberen Bereich der Range
        if price <= min(lows[:-1]) * 1.01:
            return "BUY"
        elif price >= max(highs[:-1]) * 0.99:
            return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 0.8 * atr
        tp = price + 1.6 * atr
        return sl, tp



### FILE: ./strategies/reversal.py
from strategies.indicators import calculate_rsi

class ReversalStrategy:
    def suits(self, market_type: str) -> bool:
        # Nur sinnvoll im Seitwärtsmarkt
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 15:
            return None
        rsi = calculate_rsi(ohlcv, 14)
        if rsi > 75:
            return "SELL"
        elif rsi < 25:
            return "BUY"
        return None

    def sl_tp(self, price, atr):
        sl = price - 1.3 * atr
        tp = price + 2.2 * atr
        return sl, tp



### FILE: ./strategies/rsi_ema.py
from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr

class RSIEMAStrategy:
    def __init__(self, rsi_period=14, ema_period=50):
        self.rsi_period = rsi_period
        self.ema_period = ema_period

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        rsi = calculate_rsi(ohlcv, self.rsi_period)
        ema = calculate_ema(ohlcv, self.ema_period)
        price = closes[-1]

        # Long wenn RSI unter 32 UND über EMA (bullisher Dip)
        if rsi < 32 and price > ema:
            return "BUY"
        # Short wenn RSI über 68 UND unter EMA (bearisher Spike)
        elif rsi > 68 and price < ema:
            return "SELL"
        else:
            return None

    def sl_tp(self, price, atr):
        sl = price - 1.5 * atr
        tp = price + 3.5 * atr
        return sl, tp

    def score(self, ohlcv, market_type):
        # Sehr gut in trendarmen oder schwankenden Märkten
        if market_type == "sideways":
            return 1
        return 0



### FILE: ./strategies/volatility.py
from strategies.indicators import calculate_atr, calculate_ema

class VolatilityStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "volatile"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 50:
            return None
        atr = calculate_atr(ohlcv, 14)
        ema50 = calculate_ema(ohlcv, 50)
        price = closes[-1]
        if atr > price * 0.02:  # Nur sehr volatile Märkte
            if price > ema50:
                return "BUY"
            elif price < ema50:
                return "SELL"
        return None

    def sl_tp(self, price, atr):
        sl = price - 2.5 * atr
        tp = price + 5.0 * atr
        return sl, tp



### FILE: ./utils/backtester.py
# utils/backtester.py — Version 1.0.2

import os
import asyncio
import csv
import math
from datetime import datetime
from statistics import mean, pstdev
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.indicators import calculate_ema, calculate_rsi, ATR
from utils.logger import logger
from dotenv import load_dotenv


__version__ = "1.0.2"

class Backtester:
    def __init__(self, symbol: str, start: str, end: str,
                 granularity: str = '1h', initial_balance: float = 20.0):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.granularity = granularity
        self.initial_balance = initial_balance
        self.client = None
        self.executor = None
        self.reset()

    def reset(self):
        self.balance = self.initial_balance
        self.pos = None
        self.trades = []
        self.equity_curve = [self.initial_balance]

    async def run(self):
        # Lade API-Konfig aus .env
        load_dotenv()
        api_key = os.getenv("BINANCE_API_KEY")
        api_secret = os.getenv("BINANCE_API_SECRET")
        testnet = os.getenv("USE_TESTNET", "True").lower() == "true"

        # BinanceClient asynchron initialisieren
        self.client = await BinanceClient.create(api_key, api_secret, testnet)
        self.executor = TradeExecutor(self.client)

        logger.info(f"📊 Backtest für {self.symbol} gestartet…")
        ohlcv = await self.client.fetch_ohlcv(
            self.symbol, self.granularity,
            since=self._ts(self.start),
            until=self._ts(self.end)
        )

        for i in range(len(ohlcv)):
            ts, o, h, l, c, v = ohlcv[i]
            time = datetime.utcfromtimestamp(ts/1000)

            # Indikatoren berechnen
            window_ema = [row[4] for row in ohlcv[max(0, i-50):i+1]]
            window_rsi = [row[4] for row in ohlcv[max(0, i-15):i+1]]
            window_atr = ohlcv[max(0, i-15):i+1]
            ema = calculate_ema(window_ema, period=20)
            rsi = calculate_rsi(window_rsi, period=14)
            atr = calculate_atr(window_atr, period=14)

            # Entry-Signale
            if not self.pos:
                if c > ema and rsi < 30:
                    signal = 'BUY'
                elif c < ema and rsi > 70:
                    signal = 'SELL'
                else:
                    signal = None

                if signal:
                    qty = self.balance / c
                    res = await self.executor.execute_trade(
                        self.symbol, signal, qty,
                        atr_period=14, sl_multiplier=1.5, tp_multiplier=3.0,
                        martingale_factor=1.0, paper=True
                    )
                    self.pos = {
                        'entry_time': time,
                        'entry_price': res['entry_price'],
                        'sl': res['sl_price'],
                        'tp': res['tp_price'],
                        'qty': res['qty'],
                        'side': signal
                    }

            # Exit-Logik
            if self.pos:
                price = c
                side = self.pos['side']
                exit_trade = False
                if side == 'BUY' and (price <= self.pos['sl'] or price >= self.pos['tp']):
                    exit_trade = True
                elif side == 'SELL' and (price >= self.pos['sl'] or price <= self.pos['tp']):
                    exit_trade = True

                if exit_trade:
                    pnl = (price - self.pos['entry_price']) * self.pos['qty']
                    if side == 'SELL':
                        pnl *= -1
                    self.balance += pnl
                    self.trades.append({
                        'entry': self.pos['entry_price'],
                        'exit': price,
                        'pnl': pnl
                    })
                    self.equity_curve.append(self.balance)
                    logger.info(
                        f"[Backtest] {side} {self.symbol} Entry={self.pos['entry_price']:.2f} Exit={price:.2f} P&L={pnl:.4f} Bal={self.balance:.4f}"
                    )
                    self.pos = None

        stats = self._compute_metrics()
        self._save_results(stats)
        logger.info(f"📈 Backtest abgeschlossen — Endbalance: {self.balance:.2f} — Stats: {stats}")

    def _compute_metrics(self):
        returns = []
        peak = self.initial_balance
        max_dd = 0
        wins = 0

        for bal in self.equity_curve[1:]:
            ret = (bal - peak) / peak
            returns.append(ret)
            if bal > peak:
                peak = bal
            dd = (peak - bal) / peak
            max_dd = max(max_dd, dd)
            if ret > 0:
                wins += 1

        win_rate = wins / len(returns) if returns else 0
        avg_ret = mean(returns) if returns else 0
        std_ret = pstdev(returns) if len(returns) > 1 else 0.0001
        sharpe = (avg_ret / std_ret) * math.sqrt(8760) if std_ret else 0
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        return {
            'total_return': total_return,
            'max_drawdown': max_dd,
            'win_rate': win_rate,
            'sharpe_ratio': sharpe
        }

    def _save_results(self, stats: dict):
        base = f"backtest_{self.symbol}_{self.start}_{self.end}"
        with open(f"{base}.csv", 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=['entry', 'exit', 'pnl'])
            writer.writeheader()
            for t in self.trades:
                writer.writerow(t)
        with open(f"{base}_stats.txt", 'w') as f:
            for k, v in stats.items():
                f.write(f"{k}: {v}\n")

    @staticmethod
    def _ts(date_str: str) -> int:
        dt = datetime.fromisoformat(date_str)
        return int(dt.timestamp() * 1000)



### FILE: ./utils/cooldown_manager.py
# utils/cooldown_manager.py

from datetime import datetime, timedelta

class CooldownManager:
    def __init__(self, cooldown_minutes=30):
        self.cooldowns = {}  # symbol → datetime
        self.cooldown_duration = timedelta(minutes=cooldown_minutes)

    def is_in_cooldown(self, symbol: str) -> bool:
        now = datetime.utcnow()
        last = self.cooldowns.get(symbol)
        return last and (now - last) < self.cooldown_duration

    def update_cooldown(self, symbol: str):
        self.cooldowns[symbol] = datetime.utcnow()



### FILE: ./utils/drawdown_guard.py
# utils/drawdown_guard.py

from datetime import datetime
import pandas as pd

class DrawdownGuard:
    def __init__(self, csv_file="paper_trades.csv", start_balance=20.0, max_loss_pct=5.0):
        self.csv_file = csv_file
        self.start_balance = start_balance
        self.max_loss_pct = max_loss_pct

    def loss_today_exceeded(self) -> bool:
        try:
            df = pd.read_csv(self.csv_file)
            df = df[df["pnl"].notna()]
            today = datetime.utcnow().date()
            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df[df["timestamp"].dt.date == today]

            if df.empty:
                return False

            pnl_sum = df["pnl"].sum()
            loss_pct = -pnl_sum / self.start_balance * 100 if pnl_sum < 0 else 0

            return loss_pct >= self.max_loss_pct
        except Exception:
            return False  # Lieber weiter traden als fälschlich stoppen



### FILE: ./utils/email_notify.py
import os
import smtplib
from email.message import EmailMessage
from dotenv import load_dotenv

load_dotenv()

EMAIL_HOST = os.getenv("EMAIL_HOST")
EMAIL_PORT = int(os.getenv("EMAIL_PORT", 587))
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASS = os.getenv("EMAIL_PASS")
EMAIL_TO   = os.getenv("EMAIL_TO")

def send_email(subject, body):
    msg = EmailMessage()
    msg['Subject'] = subject
    msg['From'] = EMAIL_USER
    msg['To'] = EMAIL_TO
    msg.set_content(body)

    try:
        with smtplib.SMTP(EMAIL_HOST, EMAIL_PORT) as smtp:
            smtp.starttls()
            smtp.login(EMAIL_USER, EMAIL_PASS)
            smtp.send_message(msg)
        return True
    except Exception as e:
        print(f"[EMAIL] Fehler beim Versand: {e}")
        return False



### FILE: ./utils/equity_plot.py
# utils/equity_plot.py

import pandas as pd
import matplotlib.pyplot as plt
import os
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

def plot_equity_curve(csv_file=CSV_PATH, out_file="equity_curve.png"):
    df = pd.read_csv(csv_file)
    df["time"] = pd.to_datetime(df["time"])
    df = df.sort_values("time")

    # Equity berechnen
    equity = []
    balance = 20  # Startwert
    for _, row in df.iterrows():
        if pd.notna(row["pnl"]):
            balance += row["pnl"]
        equity.append(balance)

    df["equity"] = equity

    plt.figure(figsize=(10, 5))
    plt.plot(df["time"], df["equity"], label="Equity Curve", color="green")
    plt.title("Equity Curve (Paper-Trades)")
    plt.xlabel("Zeit")
    plt.ylabel("USDC")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_file), exist_ok=True)
    plt.savefig(out_file)
    plt.close()



### FILE: ./utils/logger.py
# utils/logger.py — Version 1.0.2

import logging
import os
import sys
from logging.handlers import RotatingFileHandler

LOG_DIR = "logs"
LOG_FILE = os.path.join(LOG_DIR, "bot.log")

def setup_logger(name="bot"):
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', "%Y-%m-%d %H:%M:%S")

    # File Handler
    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5*1024*1024, backupCount=2)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Console Handler (optional)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Prevent duplicate logs
    logger.propagate = False

    return logger

# Global Logger
logger = setup_logger()

# Capture unhandled exceptions
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception



### FILE: ./utils/market_classifier.py
# utils/market_classifier.py

import numpy as np
from strategies.indicators import calculate_ema, calculate_atr

def classify_market(ohlcv):
    """
    Klassifiziert den Markt als 'trend', 'sideways' oder 'volatile' basierend auf EMA, ATR und Preisdynamik.
    """
    closes = [row[4] for row in ohlcv]
    highs = [row[2] for row in ohlcv]
    lows = [row[3] for row in ohlcv]

    # Trendbestimmung über EMA-Slope und Abstand
    ema50 = calculate_ema(ohlcv, 50)
    ema200 = calculate_ema(ohlcv, 200)
    price = closes[-1]
    slope = ema50 - ema50 if len(closes) < 52 else (ema50 - calculate_ema(ohlcv[-52:], 50))

    # ATR (Volatilität)
    atr = calculate_atr(ohlcv, 14)
    price_range = max(highs[-20:]) - min(lows[-20:])
    vola_ratio = atr / price if price != 0 else 0

    # Dynamische Schwellen (tune nach Wunsch!)
    strong_trend = abs(ema50 - ema200) / price > 0.01 and abs(slope) > 0.05 * price  # mind. 1% EMA-Diff, steile Steigung
    very_volatile = vola_ratio > 0.025 or price_range / price > 0.05  # 2.5% ATR oder 5% Range in 20 Kerzen

    if strong_trend:
        return "trend"
    elif very_volatile:
        return "volatile"
    else:
        return "sideways"



### FILE: ./utils/risk_manager.py
# utils/risk_manager.py

class RiskManager:
    def __init__(self, initial_balance: float = 20.0, max_risk_per_trade: float = 0.02):
        self.balance = initial_balance
        self.risk_pct = max_risk_per_trade  # z. B. 2 %

    def update_balance(self, new_balance: float):
        self.balance = new_balance

    def calculate_position_size(self, entry_price: float, stop_loss: float) -> float:
        sl_distance = abs(entry_price - stop_loss)
        if sl_distance == 0:
            return 0.0  # keine sinnvolle Positionsgröße möglich
        risk_amount = self.balance * self.risk_pct
        qty = risk_amount / sl_distance
        return round(qty, 6)



### FILE: ./utils/signal_filter.py
# utils/signal_filter.py

from strategies.indicators import calculate_ema, calculate_atr

class SignalFilter:
    def __init__(self, volume_factor=1.2, atr_threshold=0.001, trend_strength=0.001):
        self.volume_factor = volume_factor       # z. B. 1.2x über 10er-Avg
        self.atr_threshold = atr_threshold       # z. B. mind. 0.1 % Bewegung
        self.trend_strength = trend_strength     # z. B. Preisabstand zu EMA20 > 0.1 %

    def passes_filters(self, ohlcv) -> bool:
        closes = [c[4] for c in ohlcv]
        highs = [c[2] for c in ohlcv]
        lows = [c[3] for c in ohlcv]
        volumes = [c[5] for c in ohlcv]

        # Trend-Erkennung
        ema = calculate_ema(ohlcv, 20)
        price = closes[-1]
        trend_diff = abs(price - ema) / ema
        if trend_diff < self.trend_strength:
            return False  # Kein klarer Trend

        # Volumen-Filter
        avg_vol = sum(volumes[-11:-1]) / 10
        if volumes[-1] < avg_vol * self.volume_factor:
            return False  # Kein Volumenimpuls

        # ATR-basierte Volatilitätsprüfung
        atr = calculate_atr(ohlcv, 14)
        if atr / price < self.atr_threshold:
            return False  # Markt zu ruhig

        return True  # Alles passt



### FILE: ./utils/strategy_watchdog.py
# utils/strategy_watchdog.py

import csv
import os
from datetime import datetime
from collections import defaultdict

WATCHDOG_FILE = "strategy_watchdog.csv"

class StrategyWatchdog:
    def __init__(self):
        self.stats = defaultdict(lambda: {"trades": 0, "wins": 0, "losses": 0})
        self._load_existing()

    def _load_existing(self):
        if not os.path.isfile(WATCHDOG_FILE):
            return
        with open(WATCHDOG_FILE, mode="r") as f:
            reader = csv.DictReader(f)
            for row in reader:
                strat = row["strategy"]
                self.stats[strat] = {
                    "trades": int(row["trades"]),
                    "wins": int(row["wins"]),
                    "losses": int(row["losses"])
                }

    def record_trade(self, strategy_name: str, pnl: float):
        stat = self.stats[strategy_name]
        stat["trades"] += 1
        if pnl > 0:
            stat["wins"] += 1
        else:
            stat["losses"] += 1
        self._save()

    def _save(self):
        with open(WATCHDOG_FILE, mode="w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["strategy", "trades", "wins", "losses"])
            for strat, s in self.stats.items():
                writer.writerow([strat, s["trades"], s["wins"], s["losses"]])



### FILE: ./utils/trade_logger.py
# utils/trade_logger.py

import csv
import os
from datetime import datetime

TRADE_LOG_FILE = "paper_trades.csv"

def log_trade(symbol, side, entry_price, sl, tp, qty, pnl=None, strategy=None):
    file_exists = os.path.isfile(TRADE_LOG_FILE)
    with open(TRADE_LOG_FILE, mode='a', newline='') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow([
                "timestamp", "symbol", "side", "entry_price",
                "stop_loss", "take_profit", "qty", "pnl"
            ])
        writer.writerow([
	    datetime.utcnow().isoformat(), symbol, side, entry_price,
    	sl, tp, qty, pnl if pnl is not None else "", strategy or ""
	])



### FILE: ./utils/trade_tracker.py
import pandas as pd
from datetime import datetime
from utils.trade_logger import log_trade

def update_trade_pnls(csv_file="paper_trades.csv", current_prices=None):
    expected_cols = ["time", "symbol", "side", "entry_price", "stop_loss", "take_profit", "qty", "pnl", "strategy"]
    df = pd.read_csv(csv_file, names=expected_cols, header=0)

    # Fehlende Spalten ergänzen (alte Zeilen/alte CSV)
    for col in expected_cols:
        if col not in df.columns:
            df[col] = None

    updated = False

    for idx, row in df[df["pnl"].isna()].iterrows():
        symbol = row["symbol"]
        price = current_prices.get(symbol)
        if price is None:
            continue

        side = row["side"]
        entry = row["entry_price"]
        sl = row["stop_loss"]
        tp = row["take_profit"]
        qty = row["qty"]

        pnl = None
        # Prüfen, ob SL oder TP erreicht wurde
        if side == "BUY" and (price <= sl or price >= tp):
            pnl = (price - entry) * qty
        elif side == "SELL" and (price >= sl or price <= tp):
            pnl = (entry - price) * qty

        # Nur wenn Trade geschlossen wurde:
        if pnl is not None:
            df.at[idx, "pnl"] = pnl
            updated = True

            # Optional: Watchdog informieren, falls Strategie geloggt wurde
            strategy_name = row.get("strategy", "Unknown")
            try:
                from utils.strategy_watchdog import StrategyWatchdog
                StrategyWatchdog().record_trade(strategy_name=strategy_name, pnl=pnl)
            except Exception as e:
                print(f"[Watchdog] Fehler bei Strategie-Tracking: {e}")

    if updated:
        df.to_csv(csv_file, index=False)



### FILE: ./bot.py
#!/usr/bin/env python3
# bot.py — Version 1.0.1

import os
import asyncio
from dotenv import load_dotenv
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from utils.backtester import Backtester
from utils.logger import logger

__version__ = "1.0.1"

def load_config():
    load_dotenv()
    return {
        "api_key": os.getenv("BINANCE_API_KEY"),
        "api_secret": os.getenv("BINANCE_API_SECRET"),
        "testnet": os.getenv("USE_TESTNET", "True").lower() == "true",
        "symbol": os.getenv("SYMBOL", "BTCUSDC"),
        "backtest_start": os.getenv("BACKTEST_START", "2025-01-01T00:00"),
        "backtest_end": os.getenv("BACKTEST_END", "2025-06-01T00:00"),
        "granularity": os.getenv("GRANULARITY", "1h"),
        "initial_balance": float(os.getenv("INITIAL_BALANCE", "20.0")),
        "trade_quantity": float(os.getenv("TRADE_QUANTITY", "0.001")),
        "paper_trading": os.getenv("PAPER_TRADING", "True").lower() == "true",
        "atr_period": int(os.getenv("ATR_PERIOD", "14")),
        "sl_multiplier": float(os.getenv("SL_MULTIPLIER", "1.5")),
        "tp_multiplier": float(os.getenv("TP_MULTIPLIER", "3.0")),
        "martingale_factor": float(os.getenv("MARTINGALE_FACTOR", "1.0")),
    }

async def main():
    cfg = load_config()
    logger.info(f"🚀 Starting Grok-FuturesBot v{__version__}")

    # 1) Backtest
    logger.info("🔍 Running backtest…")
    bt = Backtester(
        symbol=cfg["symbol"],
        start=cfg["backtest_start"],
        end=cfg["backtest_end"],
        granularity=cfg["granularity"],
        initial_balance=cfg["initial_balance"],
    )
    await bt.run()

    # 2) Live-/Paper-Trading Beispiel
    logger.info("💡 Starting live/paper trading example…")
    client = await BinanceClient.create(
        api_key=cfg["api_key"],
        api_secret=cfg["api_secret"],
        testnet=cfg["testnet"],
    )
    executor = TradeExecutor(client)
    result = await executor.execute_trade(
        symbol=cfg["symbol"],
        side="BUY",
        quantity=cfg["trade_quantity"],
        atr_period=cfg["atr_period"],
        sl_multiplier=cfg["sl_multiplier"],
        tp_multiplier=cfg["tp_multiplier"],
        martingale_factor=cfg["martingale_factor"],
        paper=cfg["paper_trading"],
    )
    logger.info(
        f"🎯 Trade result (paper={cfg['paper_trading']}): Entry={result['entry_price']}, SL={result['sl_price']}, TP={result['tp_price']}"
    )

if __name__ == "__main__":
    asyncio.run(main())



### FILE: ./core/client.py
# core/client.py — Version 1.0.2

import asyncio
import ccxt.async_support as ccxt
from binance import AsyncClient
from utils.logger import logger

class BinanceClient:
    def __init__(self, client: AsyncClient):
        self.client = client

    @classmethod
    async def create(cls, api_key: str, api_secret: str, testnet: bool = False):
        logger.info(f"🔌 Verbinde mit Binance (testnet={testnet})...")
        client = await AsyncClient.create(
            api_key=api_key,
            api_secret=api_secret,
            testnet=testnet
        )
        return cls(client)

    async def get_futures_price(self, symbol: str) -> float:
        ticker = await self.client.futures_symbol_ticker(symbol=symbol)
        return float(ticker["price"])

    async def fetch_ohlcv(self, symbol: str, timeframe: str, since: int = None, limit: int = None, until: int = None):
        exchange = ccxt.binance({
            'enableRateLimit': True,
            'options': {
                'defaultType': 'future'
            }
        })
        if since and until:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since)
            ohlcv = [c for c in ohlcv if c[0] <= until]
        else:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
        await exchange.close()
        return ohlcv

    async def futures_change_leverage(self, symbol: str, leverage: int):
        """
        Setzt das Leverage für ein Futures-Symbol.
        """
        try:
            result = await self.client.futures_change_leverage(symbol=symbol, leverage=leverage)
            logger.info(f"[LEVERAGE] {symbol}: Leverage wurde auf {leverage}x gesetzt. Antwort: {result}")
            return result
        except Exception as e:
            logger.error(f"[LEVERAGE] Fehler beim Setzen des Leverage für {symbol}: {e}")
            raise

    async def close(self):
        await self.client.close_connection()



### FILE: ./core/trade_executor.py
from utils.logger import logger
from strategies.indicators import calculate_atr
from binance.enums import *

SIDE_Buy = "Buy"

class TradeExecutor:
    def __init__(self, client, base_currency: str = "USDC"):
        self.client = client
        self.base_currency = base_currency

    async def execute_trade(
        self,
        symbol: str,
        side: str,
        quantity: float,
        sl: float = None,
        tp: float = None,
        atr_period: int = 14,
        sl_multiplier: float = 1.5,
        tp_multiplier: float = 3.0,
        martingale_factor: float = 1.0,
        paper: bool = True
    ):
        qty = quantity * martingale_factor
        logger.info(f"Placing {side} order for {symbol} qty={qty:.6f} (martingale={martingale_factor})")

        # Preis ermitteln
        if paper:
            price = await self.client.get_futures_price(symbol)
            logger.info(f"(Paper) Order simulated at {price}")
        else:
            order = await self.client.client.futures_create_order(
                symbol=symbol,
                side=side,
                type=FUTURE_ORDER_TYPE_MARKET,
                quantity=qty
            )
            price = float(order["avgPrice"])
            logger.info(f"Order executed at price={price}")

        # SL/TP berechnen wenn nicht manuell übergeben
        if sl is None or tp is None:
            ohlcv = await self.client.fetch_ohlcv(symbol, timeframe='1h', limit=atr_period + 1)
            atr = calculate_atr(ohlcv, period=atr_period)
            sl, tp = self._compute_sl_tp(price, atr, side, sl_multiplier, tp_multiplier)

        return {
            "entry_price": price,
            "sl_price": sl,
            "tp_price": tp,
            "qty": qty
        }

    def _compute_sl_tp(self, entry: float, atr: float, side: str,
                       sl_mult: float, tp_mult: float):
        if side == SIDE_BUY:
            sl = entry - atr * sl_mult
            tp = entry + atr * tp_mult
        else:
            sl = entry + atr * sl_mult
            tp = entry - atr * tp_mult
        return sl, tp



### FILE: ./daily_report.py
import pandas as pd
from utils.email_notify import send_email
from datetime import date

df = pd.read_csv('/home/idppadm/trading-bot/ml/training_data.csv')
df_trades = df[(df['signal'].notna()) & (df['result'].notna()) & (df['type'] == "paper")]

today = str(date.today())
df_today = df_trades[df_trades['timestamp'].str.startswith(today)]

if not df_today.empty:
    n_trades = len(df_today)
    n_wins = (df_today['result'].astype(float) > 0).sum()
    n_losses = (df_today['result'].astype(float) <= 0).sum()
    winrate = 100 * n_wins / n_trades if n_trades else 0

    body = f"""Trading-Bot Tagesreport {today}

Trades: {n_trades}
Wins: {n_wins}
Losses: {n_losses}
Winrate: {winrate:.1f}%

Die letzten 5 Trades:
{df_today.tail(5).to_string(index=False)}
"""
else:
    body = f"Trading-Bot Tagesreport {today}\n\nHeute wurden keine Trades ausgeführt."

send_email(
    subject=f"TradingBot Tagesreport {today}",
    body=body
)



### FILE: ./dashboard/app.py
from flask import Flask, render_template, send_file
import os
import sys
import pandas as pd
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.equity_plot import plot_equity_curve
from utils.trade_logger import log_trade 
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))
from utils.strategy_leaderboard import StrategyLeaderboard

app = Flask(__name__)

@app.route("/")
def index():
    # Equity-Kurve aktualisieren
    plot_equity_curve(CSV_PATH, "dashboard/dashboard/static/equity_curve.png")

    # Daten aus CSV laden
    df = pd.read_csv(CSV_PATH)
    df_closed = df[df["pnl"].notna()]
    balance = 20.0 + df_closed["pnl"].sum()
    winrate = (df_closed["pnl"] > 0).mean() * 100 if not df_closed.empty else 0

    return render_template("index.html", 
        balance=round(balance, 2),
        total_trades=len(df),
        winrate=round(winrate, 1),
        trades=df.tail(10).to_dict(orient="records")
    )

@app.route("/leaderboard")
def leaderboard():
    lb = StrategyLeaderboard()
    _, stats = lb.compute_leaderboard()
    # stats ist ein DataFrame
    return render_template("leaderboard.html", stats=stats.to_dict(orient="records"))
    
@app.route("/chart")
def chart():
    return send_file("static/equity_curve.png", mimetype='image/png')

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)



### FILE: ./ml/analyze_backtest.py
import os
import sys
import pandas as pd
from datetime import datetime
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from ml.collect_training_data import append_training_data

def analyze_backtest(backtest_csv_path="ml/backtest_results.csv"):
    df = pd.read_csv(backtest_csv_path)
    print(f"Analysiere {len(df)} Backtest-Trades aus {backtest_csv_path}")

    for idx, row in df.iterrows():
        append_training_data(
            timestamp=row.get("timestamp", datetime.utcnow().isoformat()),
            symbol=row.get("symbol", ""),
            open_=row.get("open", ""),
            high=row.get("high", ""),
            low=row.get("low", ""),
            close=row.get("close", ""),
            volume=row.get("volume", ""),
            rsi=row.get("rsi", ""),
            ema=row.get("ema", ""),
            atr=row.get("atr", ""),
            bb_upper=row.get("bb_upper", ""),
            bb_lower=row.get("bb_lower", ""),
            market_state=row.get("market_state", ""),
            strategy=row.get("strategy", ""),
            signal=row.get("signal", ""),
            result=row.get("result", ""),
            type="backtest"
        )
    print("Alle Backtest-Trades wurden ins Training-CSV geschrieben.")

if __name__ == "__main__":
    analyze_backtest()



### FILE: ./ml/backtest_data_import.py
import os
import csv
import time
from datetime import datetime
import ccxt
from tqdm import tqdm
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from strategies.indicators import calculate_ema, calculate_rsi, calculate_atr, calculate_bollinger_bands
from strategies.engine import StrategyEngine

# Konfiguration
EXCHANGE = ccxt.binance({
    'rateLimit': 1200,
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})

OUTPUT_FILE = "ml/training_data_backtest.csv"
SYMBOLS = ["BTC/USDC", "ETH/USDC", "SOL/USDC"]  # Beliebig erweiterbar
TIMEFRAME = "1h"
START_DATE = "2024-01-01T00:00:00Z"  # YYYY-MM-DDTHH:MM:SSZ
END_DATE = "2024-06-30T00:00:00Z"

# Helper
def parse_iso8601(date_str):
    return int(EXCHANGE.parse8601(date_str))

def ohlcv_to_dict(symbol, ohlcv, strategy, market_state):
    # ohlcv: [timestamp, open, high, low, close, volume]
    close = float(ohlcv[4])
    ema = calculate_ema([ohlcv], 1)     # Für Einzelkerze = Kerzenwert
    rsi = calculate_rsi([ohlcv], 1)
    atr = calculate_atr([ohlcv], 1)
    bb_upper, bb_lower = calculate_bollinger_bands([ohlcv], 1)
    return {
        "timestamp": datetime.utcfromtimestamp(ohlcv[0]/1000).isoformat(),
        "symbol": symbol,
        "open": ohlcv[1],
        "high": ohlcv[2],
        "low": ohlcv[3],
        "close": ohlcv[4],
        "volume": ohlcv[5],
        "ema": ema,
        "rsi": rsi,
        "atr": atr,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "market_state": market_state,
        "strategy": strategy,
        "signal": "",    # Noch leer (optional für späteren Backtest/ML-Label)
        "result": ""
    }

def fetch_all_ohlcv(symbol, timeframe, since, until):
    all_candles = []
    limit = 1000
    now = since
    pbar = tqdm(desc=f"Lade {symbol}", total=(until-since)//(60*60*1000))
    while now < until:
        candles = EXCHANGE.fetch_ohlcv(symbol, timeframe, since=now, limit=limit)
        if not candles:
            break
        for c in candles:
            if c[0] > until:
                break
            all_candles.append(c)
        now = candles[-1][0] + 1
        pbar.update(len(candles))
        time.sleep(0.1)
    pbar.close()
    return all_candles

def main():
    # Setup
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, "w", newline='') as f:
        fieldnames = [
            "timestamp", "symbol", "open", "high", "low", "close", "volume",
            "ema", "rsi", "atr", "bb_upper", "bb_lower",
            "market_state", "strategy", "signal", "result"
        ]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()

        engine = StrategyEngine()
        for symbol in SYMBOLS:
            since = parse_iso8601(START_DATE)
            until = parse_iso8601(END_DATE)
            ohlcv_data = fetch_all_ohlcv(symbol, TIMEFRAME, since, until)
            # Sliding-Window für Indikatoren und Strategieauswahl:
            window = []
            for row in tqdm(ohlcv_data, desc=f"Verarbeite {symbol}"):
                window.append(row)
                if len(window) > 50:
                    window = window[-50:]  # nur die letzten 50 Kerzen
                # Marktzustand und Strategie wählen:
                market_state = engine.evaluate_market(window) if len(window) >= 20 else ""
                strategy = engine.select_strategy(window).__class__.__name__ if len(window) >= 20 else ""
                writer.writerow(
                    ohlcv_to_dict(symbol, row, strategy, market_state)
                )

if __name__ == "__main__":
    main()



### FILE: ./ml/backtest_engine.py
import sys
import os
import asyncio
import pandas as pd

# Damit die Importe klappen, egal von wo du startest:
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import ccxt.async_support as ccxt

from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr, calculate_bollinger_bands
from strategies.rsi_ema import RSIEMAStrategy
from strategies.momentum import MomentumStrategy
from strategies.volatility import VolatilityStrategy
from strategies.breakout import BreakoutStrategy
from strategies.reversal import ReversalStrategy

STRATEGIES = [
    ("rsi_ema", RSIEMAStrategy()),
    ("momentum", MomentumStrategy()),
    ("volatility", VolatilityStrategy()),
    ("breakout", BreakoutStrategy()),
    ("reversal", ReversalStrategy())
]

async def fetch_ohlcv_ccxt(symbol, timeframe="1h", since=None, limit=1000):
    exchange = ccxt.binance({
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })
    ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
    await exchange.close()
    return ohlcv

def simulate_trade(entry, side, sl, tp, ohlcv_next):
    for row in ohlcv_next:
        price = float(row[4])
        if side == "BUY":
            if price <= sl:
                return sl, (sl - entry)
            elif price >= tp:
                return tp, (tp - entry)
        elif side == "SELL":
            if price >= sl:
                return sl, (entry - sl)
            elif price <= tp:
                return tp, (entry - tp)
    return price, (price - entry) if side == "BUY" else (entry - price)

def run_backtest(symbol, ohlcv, out_csv="ml/backtest_results.csv", lookahead=10):
    results = []
    for i in range(50, len(ohlcv) - lookahead):
        sub_ohlcv = ohlcv[:i]
        future_ohlcv = ohlcv[i:i+lookahead]
        price = float(ohlcv[i][4])
        atr = calculate_atr(sub_ohlcv, 14)
        for strat_name, strat in STRATEGIES:
            signal = strat.generate_signal(sub_ohlcv)
            if signal:
                sl, tp = strat.sl_tp(price, atr)
                exit_price, pnl = simulate_trade(price, signal, sl, tp, future_ohlcv)
                results.append({
                    "timestamp": ohlcv[i][0],
                    "symbol": symbol,
                    "strategy": strat_name,
                    "side": signal,
                    "entry": price,
                    "sl": sl,
                    "tp": tp,
                    "exit": exit_price,
                    "pnl": pnl
                })
                
    out_dir = os.path.dirname(out_csv)
    if out_dir and not os.path.exists(out_dir):
        os.makedirs(out_dir)
            
    pd.DataFrame(results).to_csv(out_csv, index=False)
    print(f"Backtest für {symbol} abgeschlossen – {len(results)} Trades.")

async def main(symbol="BTCUSDT", timeframe="1h", candles=1000, out_csv="ml/backtest_results.csv"):
    print(f"Lade OHLCV für {symbol}, Intervall {timeframe}, Anzahl {candles} ...")
    ohlcv = await fetch_ohlcv_ccxt(symbol, timeframe=timeframe, limit=candles)
    run_backtest(symbol, ohlcv, out_csv=out_csv)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--symbol", default="BTCUSDT", help="Symbol, z.B. BTCUSDT")
    parser.add_argument("--timeframe", default="1h", help="Kerzenintervall, z.B. 1h, 15m, 5m")
    parser.add_argument("--candles", type=int, default=1000, help="Anzahl Kerzen")
    parser.add_argument("--out", default="ml/backtest_results.csv", help="Ziel-Datei")
    args = parser.parse_args()
    asyncio.run(main(symbol=args.symbol, timeframe=args.timeframe, candles=args.candles, out_csv=args.out))



### FILE: ./ml/collect_training_data.py
import csv
import os
from threading import Lock

file_lock = Lock()

def append_training_data(
    timestamp,
    symbol,
    open_,
    high,
    low,
    close,
    volume,
    rsi,
    ema,
    atr,
    bb_upper,
    bb_lower,
    market_state,
    strategy,
    signal,
    result,
    type="live",
    filename="ml/training_data.csv"
):
    """
    Loggt einen Datensatz für das ML-Training.
    """
    fieldnames = [
        "timestamp", "symbol", "open", "high", "low", "close", "volume", "rsi", "ema", "atr",
        "bb_upper", "bb_lower", "market_state", "strategy", "signal", "result", "type"
    ]
    file_exists = os.path.isfile(filename)
    data = {
        "timestamp": timestamp,
        "symbol": symbol,
        "open": open_,
        "high": high,
        "low": low,
        "close": close,
        "volume": volume,
        "rsi": rsi,
        "ema": ema,
        "atr": atr,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "market_state": market_state,
        "strategy": strategy,
        "signal": signal,
        "result": result,
        "type": type
    }
    with file_lock:
        with open(filename, mode="a", newline="") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            if not file_exists:
                writer.writeheader()
            writer.writerow(data)



### FILE: ./ml/feature_engineering_ml.py
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split, cross_val_score
import joblib

df = pd.read_csv("ml/training_data.csv")

# Filter einstellen
filter_type = "paper"   # z.B. "paper", "backtest", "live"
df = df[df['type'] == filter_type]

df_trades = df[(df['signal'].notna()) & (df['result'].notna())].copy()
# Korrektes Label: Gewinn (>0) = 1, Verlust (<=0) = 0
df_trades['target'] = (df_trades['result'].astype(float) > 0).astype(int)

df_trades['timestamp'] = pd.to_datetime(df_trades['timestamp'], errors='coerce')
df_trades['hour'] = df_trades['timestamp'].dt.hour
df_trades['weekday'] = df_trades['timestamp'].dt.weekday
df_trades['close_change'] = df_trades['close'].pct_change()
df_trades['high_low_range'] = (df_trades['high'] - df_trades['low']) / df_trades['close']
df_trades['atr_relative'] = df_trades['atr'] / df_trades['close']
df_trades['ema_slope_5'] = df_trades['ema'].diff(5)
df_trades['volatility_10'] = df_trades['close'].rolling(10).std()
df_trades['above_ema'] = (df_trades['close'] > df_trades['ema']).astype(int)
df_trades['rsi_change'] = df_trades['rsi'].diff()
df_trades['volume_change'] = df_trades['volume'].pct_change()
df_trades['rolling_max_close_5'] = df_trades['close'].rolling(5).max()
df_trades['rolling_min_close_5'] = df_trades['close'].rolling(5).min()
df_trades = df_trades.dropna().reset_index(drop=True)

exclude_cols = ['timestamp', 'symbol', 'result', 'strategy', 'signal', 'type', 'target']
feature_cols = [col for col in df_trades.columns if col not in exclude_cols]
X = df_trades[feature_cols]
y = df_trades['target']

clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X, y)
importances = clf.feature_importances_
imp_df = pd.DataFrame({'feature': feature_cols, 'importance': importances}).sort_values('importance', ascending=False)
print("\n[Feature Importance]")
print(imp_df)
top_features = imp_df['feature'].head(10).tolist()
print("\n[Top 10 Features fürs Training]:", top_features)
X = df_trades[top_features]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)
score = clf.score(X_test, y_test)
print(f"\nRandomForest Accuracy: {score:.4f}")

cv_scores = cross_val_score(clf, X, y, cv=5)
print(f"RandomForest Cross-Validation Accuracy: {cv_scores.mean():.4f} ± {cv_scores.std():.4f}")

joblib.dump(clf, "ml/best_trading_model.pkl")
print("Bestes Modell gespeichert als ml/best_trading_model.pkl")



### FILE: ./ml/ml_predict.py
# ml/ml_predict.py
import joblib
import pandas as pd

# Modell laden (Pfad ggf. anpassen)
ml_model = joblib.load('ml/best_trading_model.pkl')

FEATURES = [
    'open', 'high', 'low', 'close', 'volume',
    'rsi', 'ema', 'atr', 'bb_upper', 'bb_lower',
    'market_state', 'strategy', 'signal'
]

def predict_trade_signal(trade_dict):
    df = pd.DataFrame([trade_dict])
    # Kategorische Features umcodieren
    for col in ['market_state', 'strategy', 'signal']:
        if col in df.columns and df[col].dtype == 'object':
            df[col] = df[col].astype('category').cat.codes
    # Fehlende Features füllen
    for f in FEATURES:
        if f not in df.columns:
            df[f] = 0
    X = df[FEATURES]
    prediction = ml_model.predict(X)[0]
    probability = ml_model.predict_proba(X)[0][1]
    return prediction, probability



### FILE: ./multi_backtest.py
import asyncio
from utils.backtester import Backtester

symbol_list = ["BTCUSDC", "ETHUSDC", "BNBUSDC", "SOLUSDC"]
start = "2025-01-01T00:00"
end = "2025-06-01T00:00"
granularity = "1h"
initial_balance = 20.0

async def run_backtests():
    tasks = []
    for symbol in symbol_list:
        bt = Backtester(
            symbol=symbol,
            start=start,
            end=end,
            granularity=granularity,
            initial_balance=initial_balance
        )
        tasks.append(bt.run())
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(run_backtests())



### FILE: ./paper_loop.py
import os
import sys
import asyncio
from dotenv import load_dotenv
from datetime import datetime
import aiohttp
import pandas as pd

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.engine import StrategyEngine
from strategies.indicators import calculate_atr, calculate_ema, calculate_rsi, calculate_bollinger_bands
from utils.logger import logger
from utils.trade_logger import log_trade
from utils.trade_tracker import update_trade_pnls
from utils.risk_manager import RiskManager
from utils.cooldown_manager import CooldownManager
from utils.signal_filter import SignalFilter
from utils.drawdown_guard import DrawdownGuard
from utils.strategy_watchdog import StrategyWatchdog
from utils.email_notify import send_email
from ml.collect_training_data import append_training_data

# Einstellungen
load_dotenv()
PAPER = True
INTERVAL = 10
START_BALANCE = 20.0
LEVERAGE = 5    # Hier Leverage anpassen!

SYMBOLS = []

engine = StrategyEngine()
risk_manager = RiskManager(
    initial_balance=START_BALANCE,
    max_risk_per_trade=0.02,
    leverage=LEVERAGE
)
cooldown = CooldownManager(cooldown_minutes=30)
signal_filter = SignalFilter()
drawdown_guard = DrawdownGuard(start_balance=START_BALANCE, max_loss_pct=5.0)
watchdog = StrategyWatchdog()

def has_open_trade(symbol, trades_csv="paper_trades.csv"):
    if not os.path.isfile(trades_csv):
        return False
    df = pd.read_csv(trades_csv)
    df = df[df['symbol'] == symbol]
    open_trades = df[df['pnl'].isnull() | (df['pnl'] == "")]
    return not open_trades.empty

async def get_top_usdc_symbols_by_volume(limit=100):
    url = "https://fapi.binance.com/fapi/v1/ticker/24hr"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
            filtered = [
                d for d in data if d["symbol"].endswith("USDC") and float(d["quoteVolume"]) > 100000
            ]
            sorted_pairs = sorted(filtered, key=lambda x: float(x["quoteVolume"]), reverse=True)
            return [item["symbol"] for item in sorted_pairs[:limit]]

async def trade_task(symbol, client, executor):
    try:
        if has_open_trade(symbol):
            logger.info(f"[POSITION] {symbol}: Offene Position vorhanden – neuer Trade übersprungen.")
            return

        ohlcv = await client.fetch_ohlcv(symbol, "1h", limit=50)
        closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
        price = closes[-1]
        atr = calculate_atr(ohlcv, 14)
        ema = calculate_ema(ohlcv, 50)
        rsi = calculate_rsi(ohlcv, 14)
        bb_upper, bb_lower = calculate_bollinger_bands(ohlcv, 20, 2)

        strategy = engine.select_strategy(ohlcv)
        signal = strategy.generate_signal(ohlcv)
        market_state = engine.evaluate_market(ohlcv)

        append_training_data(
            timestamp=datetime.utcnow().isoformat(),
            symbol=symbol,
            open_=ohlcv[-1][1],
            high=ohlcv[-1][2],
            low=ohlcv[-1][3],
            close=ohlcv[-1][4],
            volume=ohlcv[-1][5],
            rsi=rsi,
            ema=ema,
            atr=atr,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            market_state=market_state,
            strategy=strategy.__class__.__name__,
            signal=signal,
            result=None,
            type="paper"
        )

        if not signal:
            logger.info(f"[FILTER] {symbol}: Kein Signal.")
            return

        if cooldown.is_in_cooldown(symbol):
            logger.info(f"[COOLDOWN] {symbol}: aktiv – übersprungen.")
            return

        if not signal_filter.passes_filters(ohlcv):
            logger.info(f"[FILTER] {symbol}: Markt ungeeignet.")
            return

        sl, tp = strategy.sl_tp(price, atr, signal, market_state, atr / price)  # Neue SL/TP-Logik
        qty = risk_manager.calculate_position_size(entry_price=price, stop_loss=sl)

        if qty <= 0 or qty > 10000:
            logger.warning(f"[RISK] {symbol}: Ordergröße zu klein/groß – übersprungen.")
            return

        logger.info(f"[TRADE] {symbol}: {signal} @ {price:.4f} SL={sl:.4f} TP={tp:.4f} QTY={qty:.4f} Leverage={risk_manager.leverage}")

        result = await executor.execute_trade(
            symbol=symbol,
            side=signal,
            quantity=qty,
            sl=sl,
            tp=tp,
            paper=PAPER
        )

        log_trade(
            symbol=symbol,
            side=signal,
            entry_price=result["entry_price"],
            sl=sl,
            tp=tp,
            qty=qty,
            strategy=strategy.__class__.__name__,
            leverage=risk_manager.leverage
        )

        cooldown.update_cooldown(symbol)

        append_training_data(
            timestamp=datetime.utcnow().isoformat(),
            symbol=symbol,
            open_=ohlcv[-1][1],
            high=ohlcv[-1][2],
            low=ohlcv[-1][3],
            close=ohlcv[-1][4],
            volume=ohlcv[-1][5],
            rsi=rsi,
            ema=ema,
            atr=atr,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            market_state=market_state,
            strategy=strategy.__class__.__name__,
            signal=signal,
            result=result.get("pnl") if result else None,
            type="paper"
        )

    except Exception as e:
        logger.error(f"[{symbol}] Fehler im Loop: {e}")
        if "exchangeInfo" not in str(e):
            send_email(
                subject=f"TradingBot ERROR [{symbol}]",
                body=f"Fehler im Trading-Bot für {symbol}:\n{e}"
            )

async def trade_loop():
    global SYMBOLS
    client = await BinanceClient.create(
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
        testnet=os.getenv("USE_TESTNET", "True").lower() == "true"
    )
    executor = TradeExecutor(client)

    try:
        SYMBOLS = await get_top_usdc_symbols_by_volume(limit=25)
        logger.info(f"📊 Überwachte Paare: {', '.join(SYMBOLS[:10])} ...")
        while True:
            if drawdown_guard.loss_today_exceeded():
                logger.warning("🛑 Tagesverlustgrenze erreicht – Trading pausiert.")
                await asyncio.sleep(INTERVAL)
                continue

            tasks = [trade_task(symbol, client, executor) for symbol in SYMBOLS]
            await asyncio.gather(*tasks)

            try:
                current_prices = {symbol: await client.get_futures_price(symbol) for symbol in SYMBOLS}
                atr_lookup = {}  # Optional: dict {symbol: atr}
                for symbol in SYMBOLS:
                    ohlcv = await client.fetch_ohlcv(symbol, "1h", limit=50)
                    atr_lookup[symbol] = calculate_atr(ohlcv, 14)
                update_trade_pnls(current_prices=current_prices, atr_lookup=atr_lookup)
            except Exception as e:
                logger.warning(f"[PnL] Preisabruf fehlgeschlagen: {e}")

            logger.info(f"⏳ Nächster Zyklus in {INTERVAL} Sekunden...\n")
            await asyncio.sleep(INTERVAL)
    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(trade_loop())



### FILE: ./strategies/breakout.py
from strategies.indicators import calculate_atr

class BreakoutStrategy:
    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        highs = [row[2] for row in ohlcv[-21:]]
        lows = [row[3] for row in ohlcv[-21:]]
        price = closes[-1]

        # Buy-Breakout: schließt über dem lokalen Hoch der letzten 20 Kerzen, mit Volumenfilter
        if price > max(highs[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "BUY"
        # Sell-Breakout: schließt unter dem lokalen Tief der letzten 20 Kerzen
        elif price < min(lows[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "SELL"
        else:
            return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "trend":
            sl_mult = 1.5 if volatility < 0.01 else 2.5
            tp_mult = 3.5 if volatility < 0.01 else 7.0
        elif market_state == "sideways":
            sl_mult = 1.0
            tp_mult = 1.2
        else:  # volatile
            sl_mult = 3.0
            tp_mult = 6.0
        return sl_mult, tp_mult

    def score(self, ohlcv, market_type):
        # Perfekt in klaren Trendphasen!
        if market_type == "trend":
            return 2
        return 0



### FILE: ./strategies/engine.py
from strategies.rsi_ema import RSIEMAStrategy
from strategies.breakout import BreakoutStrategy
from strategies.momentum import MomentumStrategy
from strategies.reversal import ReversalStrategy
from strategies.range_trading import RangeTradingStrategy
from strategies.volatility import VolatilityStrategy
from utils.strategy_leaderboard import StrategyLeaderboard

class StrategyEngine:
    def __init__(self):
        self.strategies = [
            RSIEMAStrategy(),
            BreakoutStrategy(),
            MomentumStrategy(),
            ReversalStrategy(),
            RangeTradingStrategy(),
            VolatilityStrategy()
        ]
        self.leaderboard = StrategyLeaderboard()

    def evaluate_market(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 21:
            return "sideways"
        change = abs(closes[-1] - closes[-20]) / closes[-20]
        if change > 0.03:
            return "trend"
        # Einfache Volatilitätsbestimmung
        atr = abs(max(closes[-20:]) - min(closes[-20:])) / closes[-20]
        if atr > 0.04:
            return "volatile"
        return "sideways"

    def select_strategy(self, ohlcv):
        # Führe Leaderboard-Check durch
        enabled_strats, _ = self.leaderboard.compute_leaderboard(min_trades=10, top_n=2)

        market = self.evaluate_market(ohlcv)
        candidates = []
        for strategy in self.strategies:
            s_name = strategy.__class__.__name__
            if enabled_strats and s_name not in enabled_strats:
                continue  # Nur Top-Strategien verwenden!
            if hasattr(strategy, "suits"):
                if strategy.suits(market):
                    candidates.append(strategy)
            else:
                candidates.append(strategy)

        if candidates:
            return candidates[0]  # oder z.B. random.choice(candidates)
        # Fallback (falls Leaderboard leer): erste Strategie
        return self.strategies[0]



### FILE: ./strategies/indicators.py
import numpy as np

def calculate_rsi(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period + 1:
        return 50.0
    deltas = np.diff(closes)
    gain = np.where(deltas > 0, deltas, 0).sum() / period
    loss = -np.where(deltas < 0, deltas, 0).sum() / period
    if loss == 0:
        return 100.0
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_ema(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return closes[-1] if closes else 0.0
    ema = np.mean(closes[-period:])
    multiplier = 2 / (period + 1)
    for price in closes[-period:]:
        ema = (price - ema) * multiplier + ema
    return ema

def calculate_atr(ohlcv, period=14):
    if len(ohlcv) < period + 1:
        return 0.0
    high = [float(row[2]) for row in ohlcv]
    low = [float(row[3]) for row in ohlcv]
    close = [float(row[4]) for row in ohlcv]
    tr = []
    for i in range(1, len(ohlcv)):
        tr.append(max(
            high[i] - low[i],
            abs(high[i] - close[i-1]),
            abs(low[i] - close[i-1])
        ))
    if len(tr) < period:
        return np.mean(tr) if tr else 0.0
    atr = np.mean(tr[-period:])
    return atr

def calculate_bollinger_bands(ohlcv, period=20, multiplier=2):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return (0.0, 0.0)
    moving_avg = np.mean(closes[-period:])
    std_dev = np.std(closes[-period:])
    upper_band = moving_avg + (std_dev * multiplier)
    lower_band = moving_avg - (std_dev * multiplier)
    return upper_band, lower_band



### FILE: ./strategies/momentum.py
from strategies.indicators import calculate_ema

class MomentumStrategy:
    def suits(self, market_type: str) -> bool:
        # Nur in klaren Trends sinnvoll!
        return market_type == "trend"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 11:
            return None
        # Momentum = aktueller Schluss minus vor 10 Perioden
        momentum = closes[-1] - closes[-10]
        if momentum > 0:
            return "BUY"
        elif momentum < 0:
            return "SELL"
        return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "trend":
            sl_mult = 1.2 if volatility < 0.01 else 2.0
            tp_mult = 2.0 if volatility < 0.01 else 4.0
        elif market_state == "sideways":
            sl_mult = 0.8
            tp_mult = 1.2
        else:  # volatile
            sl_mult = 2.0
            tp_mult = 5.0
        return sl_mult, tp_mult



### FILE: ./strategies/range_trading.py
from strategies.indicators import calculate_ema

class RangeTradingStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 21:
            return None
        highs = [float(row[2]) for row in ohlcv[-21:]]
        lows = [float(row[3]) for row in ohlcv[-21:]]
        price = closes[-1]
        # Kauf am unteren Bereich, Verkauf am oberen Bereich der Range
        if price <= min(lows[:-1]) * 1.01:
            return "BUY"
        elif price >= max(highs[:-1]) * 0.99:
            return "SELL"
        return None

    
    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "sideways":
            sl_mult = 0.6
            tp_mult = 1.0
        elif market_state == "trend":
            sl_mult = 1.0
            tp_mult = 1.5
        else:  # volatile
            sl_mult = 1.5
            tp_mult = 3.0
        return sl_mult, tp_mult




### FILE: ./strategies/reversal.py
from strategies.indicators import calculate_rsi

class ReversalStrategy:
    def suits(self, market_type: str) -> bool:
        # Nur sinnvoll im Seitwärtsmarkt
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 15:
            return None
        rsi = calculate_rsi(ohlcv, 14)
        if rsi > 75:
            return "SELL"
        elif rsi < 25:
            return "BUY"
        return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "sideways":
            sl_mult = 0.8
            tp_mult = 1.3
        elif market_state == "trend":
            sl_mult = 1.3
            tp_mult = 1.7
        else:  # volatile
            sl_mult = 1.8
            tp_mult = 3.0
        return sl_mult, tp_mult



### FILE: ./strategies/rsi_ema.py
from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr

class RSIEMAStrategy:
    def __init__(self, rsi_period=14, ema_period=50):
        self.rsi_period = rsi_period
        self.ema_period = ema_period

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        rsi = calculate_rsi(ohlcv, self.rsi_period)
        ema = calculate_ema(ohlcv, self.ema_period)
        price = closes[-1]

        # Long wenn RSI unter 32 UND über EMA (bullisher Dip)
        if rsi < 32 and price > ema:
            return "BUY"
        # Short wenn RSI über 68 UND unter EMA (bearisher Spike)
        elif rsi > 68 and price < ema:
            return "SELL"
        else:
            return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:  # SELL
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "trend":
            sl_mult = 1.2 if volatility < 0.01 else 2.0
            tp_mult = 2.5 if volatility < 0.01 else 5.0
        elif market_state == "sideways":
            sl_mult = 0.7
            tp_mult = 1.0
        else:  # volatile
            sl_mult = 2.5
            tp_mult = 5.0
        return sl_mult, tp_mult

    def score(self, ohlcv, market_type):
        # Sehr gut in trendarmen oder schwankenden Märkten
        if market_type == "sideways":
            return 1
        return 0



### FILE: ./strategies/volatility.py
from strategies.indicators import calculate_atr, calculate_ema

class VolatilityStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "volatile"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 50:
            return None
        atr = calculate_atr(ohlcv, 14)
        ema50 = calculate_ema(ohlcv, 50)
        price = closes[-1]
        if atr > price * 0.02:  # Nur sehr volatile Märkte
            if price > ema50:
                return "BUY"
            elif price < ema50:
                return "SELL"
        return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "volatile":
            sl_mult = 3.0
            tp_mult = 6.0
        elif market_state == "trend":
            sl_mult = 2.0
            tp_mult = 4.0
        else:  # sideways
            sl_mult = 1.2
            tp_mult = 1.6
        return sl_mult, tp_mult



### FILE: ./utils/backtester.py
# utils/backtester.py — Version 1.0.2

import os
import asyncio
import csv
import math
from datetime import datetime
from statistics import mean, pstdev
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.indicators import calculate_ema, calculate_rsi, ATR
from utils.logger import logger
from dotenv import load_dotenv


__version__ = "1.0.2"

class Backtester:
    def __init__(self, symbol: str, start: str, end: str,
                 granularity: str = '1h', initial_balance: float = 20.0):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.granularity = granularity
        self.initial_balance = initial_balance
        self.client = None
        self.executor = None
        self.reset()

    def reset(self):
        self.balance = self.initial_balance
        self.pos = None
        self.trades = []
        self.equity_curve = [self.initial_balance]

    async def run(self):
        # Lade API-Konfig aus .env
        load_dotenv()
        api_key = os.getenv("BINANCE_API_KEY")
        api_secret = os.getenv("BINANCE_API_SECRET")
        testnet = os.getenv("USE_TESTNET", "True").lower() == "true"

        # BinanceClient asynchron initialisieren
        self.client = await BinanceClient.create(api_key, api_secret, testnet)
        self.executor = TradeExecutor(self.client)

        logger.info(f"📊 Backtest für {self.symbol} gestartet…")
        ohlcv = await self.client.fetch_ohlcv(
            self.symbol, self.granularity,
            since=self._ts(self.start),
            until=self._ts(self.end)
        )

        for i in range(len(ohlcv)):
            ts, o, h, l, c, v = ohlcv[i]
            time = datetime.utcfromtimestamp(ts/1000)

            # Indikatoren berechnen
            window_ema = [row[4] for row in ohlcv[max(0, i-50):i+1]]
            window_rsi = [row[4] for row in ohlcv[max(0, i-15):i+1]]
            window_atr = ohlcv[max(0, i-15):i+1]
            ema = calculate_ema(window_ema, period=20)
            rsi = calculate_rsi(window_rsi, period=14)
            atr = calculate_atr(window_atr, period=14)

            # Entry-Signale
            if not self.pos:
                if c > ema and rsi < 30:
                    signal = 'BUY'
                elif c < ema and rsi > 70:
                    signal = 'SELL'
                else:
                    signal = None

                if signal:
                    qty = self.balance / c
                    res = await self.executor.execute_trade(
                        self.symbol, signal, qty,
                        atr_period=14, sl_multiplier=1.5, tp_multiplier=3.0,
                        martingale_factor=1.0, paper=True
                    )
                    self.pos = {
                        'entry_time': time,
                        'entry_price': res['entry_price'],
                        'sl': res['sl_price'],
                        'tp': res['tp_price'],
                        'qty': res['qty'],
                        'side': signal
                    }

            # Exit-Logik
            if self.pos:
                price = c
                side = self.pos['side']
                exit_trade = False
                if side == 'BUY' and (price <= self.pos['sl'] or price >= self.pos['tp']):
                    exit_trade = True
                elif side == 'SELL' and (price >= self.pos['sl'] or price <= self.pos['tp']):
                    exit_trade = True

                if exit_trade:
                    pnl = (price - self.pos['entry_price']) * self.pos['qty']
                    if side == 'SELL':
                        pnl *= -1
                    self.balance += pnl
                    self.trades.append({
                        'entry': self.pos['entry_price'],
                        'exit': price,
                        'pnl': pnl
                    })
                    self.equity_curve.append(self.balance)
                    logger.info(
                        f"[Backtest] {side} {self.symbol} Entry={self.pos['entry_price']:.2f} Exit={price:.2f} P&L={pnl:.4f} Bal={self.balance:.4f}"
                    )
                    self.pos = None

        stats = self._compute_metrics()
        self._save_results(stats)
        logger.info(f"📈 Backtest abgeschlossen — Endbalance: {self.balance:.2f} — Stats: {stats}")

    def _compute_metrics(self):
        returns = []
        peak = self.initial_balance
        max_dd = 0
        wins = 0

        for bal in self.equity_curve[1:]:
            ret = (bal - peak) / peak
            returns.append(ret)
            if bal > peak:
                peak = bal
            dd = (peak - bal) / peak
            max_dd = max(max_dd, dd)
            if ret > 0:
                wins += 1

        win_rate = wins / len(returns) if returns else 0
        avg_ret = mean(returns) if returns else 0
        std_ret = pstdev(returns) if len(returns) > 1 else 0.0001
        sharpe = (avg_ret / std_ret) * math.sqrt(8760) if std_ret else 0
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        return {
            'total_return': total_return,
            'max_drawdown': max_dd,
            'win_rate': win_rate,
            'sharpe_ratio': sharpe
        }

    def _save_results(self, stats: dict):
        base = f"backtest_{self.symbol}_{self.start}_{self.end}"
        with open(f"{base}.csv", 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=['entry', 'exit', 'pnl'])
            writer.writeheader()
            for t in self.trades:
                writer.writerow(t)
        with open(f"{base}_stats.txt", 'w') as f:
            for k, v in stats.items():
                f.write(f"{k}: {v}\n")

    @staticmethod
    def _ts(date_str: str) -> int:
        dt = datetime.fromisoformat(date_str)
        return int(dt.timestamp() * 1000)



### FILE: ./utils/cooldown_manager.py
# utils/cooldown_manager.py

from datetime import datetime, timedelta

class CooldownManager:
    def __init__(self, cooldown_minutes=30):
        self.cooldowns = {}  # symbol → datetime
        self.cooldown_duration = timedelta(minutes=cooldown_minutes)

    def is_in_cooldown(self, symbol: str) -> bool:
        now = datetime.utcnow()
        last = self.cooldowns.get(symbol)
        return last and (now - last) < self.cooldown_duration

    def update_cooldown(self, symbol: str):
        self.cooldowns[symbol] = datetime.utcnow()



### FILE: ./utils/drawdown_guard.py
# utils/drawdown_guard.py

from datetime import datetime
import pandas as pd

class DrawdownGuard:
    def __init__(self, csv_file="paper_trades.csv", start_balance=20.0, max_loss_pct=5.0):
        self.csv_file = csv_file
        self.start_balance = start_balance
        self.max_loss_pct = max_loss_pct

    def loss_today_exceeded(self) -> bool:
        try:
            df = pd.read_csv(self.csv_file)
            df = df[df["pnl"].notna()]
            today = datetime.utcnow().date()
            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df[df["timestamp"].dt.date == today]

            if df.empty:
                return False

            pnl_sum = df["pnl"].sum()
            loss_pct = -pnl_sum / self.start_balance * 100 if pnl_sum < 0 else 0

            return loss_pct >= self.max_loss_pct
        except Exception:
            return False  # Lieber weiter traden als fälschlich stoppen



### FILE: ./utils/email_notify.py
import os
import smtplib
from email.message import EmailMessage
from dotenv import load_dotenv

load_dotenv()

EMAIL_HOST = os.getenv("EMAIL_HOST")
EMAIL_PORT = int(os.getenv("EMAIL_PORT", 587))
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASS = os.getenv("EMAIL_PASS")
EMAIL_TO   = os.getenv("EMAIL_TO")

def send_email(subject, body):
    msg = EmailMessage()
    msg['Subject'] = subject
    msg['From'] = EMAIL_USER
    msg['To'] = EMAIL_TO
    msg.set_content(body)

    try:
        with smtplib.SMTP(EMAIL_HOST, EMAIL_PORT) as smtp:
            smtp.starttls()
            smtp.login(EMAIL_USER, EMAIL_PASS)
            smtp.send_message(msg)
        return True
    except Exception as e:
        print(f"[EMAIL] Fehler beim Versand: {e}")
        return False



### FILE: ./utils/equity_plot.py
# utils/equity_plot.py

import pandas as pd
import matplotlib.pyplot as plt
import os
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))

def plot_equity_curve(csv_file=CSV_PATH, out_file="equity_curve.png"):
    df = pd.read_csv(csv_file)
    df["time"] = pd.to_datetime(df["time"])
    df = df.sort_values("time")

    # Equity berechnen
    equity = []
    balance = 20  # Startwert
    for _, row in df.iterrows():
        if pd.notna(row["pnl"]):
            balance += row["pnl"]
        equity.append(balance)

    df["equity"] = equity

    plt.figure(figsize=(10, 5))
    plt.plot(df["time"], df["equity"], label="Equity Curve", color="green")
    plt.title("Equity Curve (Paper-Trades)")
    plt.xlabel("Zeit")
    plt.ylabel("USDC")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_file), exist_ok=True)
    plt.savefig(out_file)
    plt.close()



### FILE: ./utils/logger.py
# utils/logger.py — Version 1.0.2

import logging
import os
import sys
from logging.handlers import RotatingFileHandler

LOG_DIR = "logs"
LOG_FILE = os.path.join(LOG_DIR, "bot.log")

def setup_logger(name="bot"):
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', "%Y-%m-%d %H:%M:%S")

    # File Handler
    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5*1024*1024, backupCount=2)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Console Handler (optional)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Prevent duplicate logs
    logger.propagate = False

    return logger

# Global Logger
logger = setup_logger()

# Capture unhandled exceptions
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception



### FILE: ./utils/market_classifier.py
# utils/market_classifier.py

import numpy as np
from strategies.indicators import calculate_ema, calculate_atr

def classify_market(ohlcv):
    """
    Klassifiziert den Markt als 'trend', 'sideways' oder 'volatile' basierend auf EMA, ATR und Preisdynamik.
    """
    closes = [row[4] for row in ohlcv]
    highs = [row[2] for row in ohlcv]
    lows = [row[3] for row in ohlcv]

    # Trendbestimmung über EMA-Slope und Abstand
    ema50 = calculate_ema(ohlcv, 50)
    ema200 = calculate_ema(ohlcv, 200)
    price = closes[-1]
    slope = ema50 - ema50 if len(closes) < 52 else (ema50 - calculate_ema(ohlcv[-52:], 50))

    # ATR (Volatilität)
    atr = calculate_atr(ohlcv, 14)
    price_range = max(highs[-20:]) - min(lows[-20:])
    vola_ratio = atr / price if price != 0 else 0

    # Dynamische Schwellen (tune nach Wunsch!)
    strong_trend = abs(ema50 - ema200) / price > 0.01 and abs(slope) > 0.05 * price  # mind. 1% EMA-Diff, steile Steigung
    very_volatile = vola_ratio > 0.025 or price_range / price > 0.05  # 2.5% ATR oder 5% Range in 20 Kerzen

    if strong_trend:
        return "trend"
    elif very_volatile:
        return "volatile"
    else:
        return "sideways"



### FILE: ./utils/risk_manager.py
# utils/risk_manager.py

class RiskManager:
    def __init__(self, initial_balance, max_risk_per_trade=0.02, leverage=5):
        self.balance = initial_balance
        self.max_risk_per_trade = max_risk_per_trade
        self.leverage = leverage

    def update_balance(self, new_balance):
        self.balance = new_balance

    def calculate_position_size(self, entry_price, stop_loss):
        risk_amount = self.balance * self.max_risk_per_trade
        sl_distance = abs(entry_price - stop_loss)
        if sl_distance == 0:
            return 0
        qty = (risk_amount * self.leverage) / sl_distance
        return qty



### FILE: ./utils/signal_filter.py
# utils/signal_filter.py

from strategies.indicators import calculate_ema, calculate_atr

class SignalFilter:
    def __init__(self, volume_factor=1.2, atr_threshold=0.001, trend_strength=0.001):
        self.volume_factor = volume_factor       # z. B. 1.2x über 10er-Avg
        self.atr_threshold = atr_threshold       # z. B. mind. 0.1 % Bewegung
        self.trend_strength = trend_strength     # z. B. Preisabstand zu EMA20 > 0.1 %

    def passes_filters(self, ohlcv) -> bool:
        closes = [c[4] for c in ohlcv]
        highs = [c[2] for c in ohlcv]
        lows = [c[3] for c in ohlcv]
        volumes = [c[5] for c in ohlcv]

        # Trend-Erkennung
        ema = calculate_ema(ohlcv, 20)
        price = closes[-1]
        trend_diff = abs(price - ema) / ema
        if trend_diff < self.trend_strength:
            return False  # Kein klarer Trend

        # Volumen-Filter
        avg_vol = sum(volumes[-11:-1]) / 10
        if volumes[-1] < avg_vol * self.volume_factor:
            return False  # Kein Volumenimpuls

        # ATR-basierte Volatilitätsprüfung
        atr = calculate_atr(ohlcv, 14)
        if atr / price < self.atr_threshold:
            return False  # Markt zu ruhig

        return True  # Alles passt



### FILE: ./utils/strategy_leaderboard.py
import pandas as pd
import os

class StrategyLeaderboard:
    def __init__(self, trades_csv="paper_trades.csv"):
        self.trades_csv = trades_csv

    def compute_leaderboard(self, min_trades=10, top_n=2):
        if not os.path.isfile(self.trades_csv):
            return []

        df = pd.read_csv(self.trades_csv)
        # Nur abgeschlossene Trades zählen
        df = df[df['pnl'].notnull()]
        if 'strategy' not in df.columns:
            return []

        stats = (
            df.groupby('strategy')
              .agg(trades=('pnl', 'count'),
                   wins=('pnl', lambda x: (x > 0).sum()),
                   losses=('pnl', lambda x: (x < 0).sum()),
                   winrate=('pnl', lambda x: round(100 * (x > 0).sum() / len(x), 2)),
                   total_pnl=('pnl', 'sum'),
                   avg_pnl=('pnl', 'mean'))
              .reset_index()
        )
        # Nur Strategien mit genug Trades
        stats = stats[stats['trades'] >= min_trades]
        # Sortiere nach Total-PnL (kannst du auch nach Winrate ändern)
        stats = stats.sort_values("total_pnl", ascending=False)
        # Wähle die besten N aus
        top_strategies = stats.head(top_n)["strategy"].tolist()
        return top_strategies, stats

    def is_strategy_enabled(self, strategy, min_trades=10, top_n=2):
        enabled_strats, _ = self.compute_leaderboard(min_trades=min_trades, top_n=top_n)
        return strategy in enabled_strats



### FILE: ./utils/strategy_watchdog.py
# utils/strategy_watchdog.py

import csv
import os
from datetime import datetime
from collections import defaultdict

WATCHDOG_FILE = "strategy_watchdog.csv"

class StrategyWatchdog:
    def __init__(self):
        self.stats = defaultdict(lambda: {"trades": 0, "wins": 0, "losses": 0})
        self._load_existing()

    def _load_existing(self):
        if not os.path.isfile(WATCHDOG_FILE):
            return
        with open(WATCHDOG_FILE, mode="r") as f:
            reader = csv.DictReader(f)
            for row in reader:
                strat = row["strategy"]
                self.stats[strat] = {
                    "trades": int(row["trades"]),
                    "wins": int(row["wins"]),
                    "losses": int(row["losses"])
                }

    def record_trade(self, strategy_name: str, pnl: float):
        stat = self.stats[strategy_name]
        stat["trades"] += 1
        if pnl > 0:
            stat["wins"] += 1
        else:
            stat["losses"] += 1
        self._save()

    def _save(self):
        with open(WATCHDOG_FILE, mode="w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["strategy", "trades", "wins", "losses"])
            for strat, s in self.stats.items():
                writer.writerow([strat, s["trades"], s["wins"], s["losses"]])



### FILE: ./utils/trade_logger.py
import csv
import os
from datetime import datetime

TRADE_LOG_FILE = "paper_trades.csv"

def log_trade(
    symbol, side, entry_price, sl, tp, qty, strategy, leverage,
    pnl=None, exit_price=None, exit_reason=None
):
    file_exists = os.path.isfile(TRADE_LOG_FILE)
    with open(TRADE_LOG_FILE, mode='a', newline='') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow([
                "timestamp", "symbol", "side", "entry_price",
                "sl", "tp", "qty", "strategy", "leverage",
                "current_sl", "pnl", "exit_price", "exit_reason"
            ])
        writer.writerow([
            datetime.utcnow().isoformat(), symbol, side, entry_price,
            sl, tp, qty, strategy, leverage,
            sl,                         # initial: current_sl = sl
            pnl if pnl is not None else "",
            exit_price if exit_price is not None else "",
            exit_reason if exit_reason is not None else ""
        ])



### FILE: ./utils/trade_tracker.py
import pandas as pd
import os

def update_trade_pnls(current_prices, trades_csv="paper_trades.csv", atr_lookup=None):
    """
    Aktualisiert PnL und setzt Trailing Stop für offene Trades.
    current_prices: dict {symbol: aktueller Preis}
    atr_lookup: dict {symbol: ATR}, falls du aktuelle ATRs brauchst (optional)
    """
    if not os.path.isfile(trades_csv):
        return

    df = pd.read_csv(trades_csv)
    updated = False
    for idx, row in df[df['pnl'].isnull()].iterrows():
        symbol = row['symbol']
        side = row['side']
        entry = float(row['entry_price'])
        sl = float(row.get('current_sl', row['sl'] if 'sl' in row else row['stop_loss']))
        tp = float(row.get('tp', row['take_profit'])) if 'tp' in row else float(row['take_profit'])
        atr = float(atr_lookup[symbol]) if atr_lookup and symbol in atr_lookup else abs(entry * 0.01)
        qty = float(row['qty'])

        price = float(current_prices.get(symbol, entry))
        # Trailing-Stop-Abstand (z. B. 1.5 × ATR)
        trail_dist = 1.5 * atr

        # Trailing für BUY
        if side == "BUY":
            new_sl = max(sl, price - trail_dist)
        else:  # SELL
            new_sl = min(sl, price + trail_dist)

        # Nur bei SL-Verbesserung updaten
        if new_sl != sl:
            df.at[idx, 'current_sl'] = new_sl
            updated = True

        pnl = None
        exit_reason = None

        # TP/SL/Trailing prüfen
        if side == "BUY":
            if price <= new_sl:
                pnl = (price - entry) * qty
                exit_reason = "trailing_stop"
            elif price >= tp:
                pnl = (tp - entry) * qty
                exit_reason = "take_profit"
        else:
            if price >= new_sl:
                pnl = (entry - price) * qty
                exit_reason = "trailing_stop"
            elif price <= tp:
                pnl = (entry - tp) * qty
                exit_reason = "take_profit"

        if pnl is not None:
            df.at[idx, 'pnl'] = pnl
            df.at[idx, 'exit_price'] = price
            df.at[idx, 'exit_reason'] = exit_reason
            updated = True

            # Optional: Strategie-Watchdog informieren
            strategy_name = row.get("strategy", "Unknown")
            try:
                from utils.strategy_watchdog import StrategyWatchdog
                StrategyWatchdog().record_trade(strategy_name=strategy_name, pnl=pnl)
            except Exception as e:
                print(f"[Watchdog] Fehler bei Strategie-Tracking: {e}")

    if updated:
        df.to_csv(trades_csv, index=False)



