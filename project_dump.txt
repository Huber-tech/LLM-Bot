### FILE: ./bot.py
#!/usr/bin/env python3
# bot.py — Version 1.0.1

import os
import asyncio
from dotenv import load_dotenv
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from utils.backtester import Backtester
from utils.logger import logger

__version__ = "1.0.1"

def load_config():
    load_dotenv()
    return {
        "api_key": os.getenv("BINANCE_API_KEY"),
        "api_secret": os.getenv("BINANCE_API_SECRET"),
        "testnet": os.getenv("USE_TESTNET", "True").lower() == "true",
        "symbol": os.getenv("SYMBOL", "BTCUSDC"),
        "backtest_start": os.getenv("BACKTEST_START", "2025-01-01T00:00"),
        "backtest_end": os.getenv("BACKTEST_END", "2025-06-01T00:00"),
        "granularity": os.getenv("GRANULARITY", "1h"),
        "initial_balance": float(os.getenv("INITIAL_BALANCE", "20.0")),
        "trade_quantity": float(os.getenv("TRADE_QUANTITY", "0.001")),
        "paper_trading": os.getenv("PAPER_TRADING", "True").lower() == "true",
        "atr_period": int(os.getenv("ATR_PERIOD", "14")),
        "sl_multiplier": float(os.getenv("SL_MULTIPLIER", "1.5")),
        "tp_multiplier": float(os.getenv("TP_MULTIPLIER", "3.0")),
        "martingale_factor": float(os.getenv("MARTINGALE_FACTOR", "1.0")),
    }

async def main():
    cfg = load_config()
    logger.info(f"🚀 Starting Grok-FuturesBot v{__version__}")

    # 1) Backtest
    logger.info("🔍 Running backtest…")
    bt = Backtester(
        symbol=cfg["symbol"],
        start=cfg["backtest_start"],
        end=cfg["backtest_end"],
        granularity=cfg["granularity"],
        initial_balance=cfg["initial_balance"],
    )
    await bt.run()

    # 2) Live-/Paper-Trading Beispiel
    logger.info("💡 Starting live/paper trading example…")
    client = await BinanceClient.create(
        api_key=cfg["api_key"],
        api_secret=cfg["api_secret"],
        testnet=cfg["testnet"],
    )
    executor = TradeExecutor(client)
    result = await executor.execute_trade(
        symbol=cfg["symbol"],
        side="BUY",
        quantity=cfg["trade_quantity"],
        atr_period=cfg["atr_period"],
        sl_multiplier=cfg["sl_multiplier"],
        tp_multiplier=cfg["tp_multiplier"],
        martingale_factor=cfg["martingale_factor"],
        paper=cfg["paper_trading"],
    )
    logger.info(
        f"🎯 Trade result (paper={cfg['paper_trading']}): Entry={result['entry_price']}, SL={result['sl_price']}, TP={result['tp_price']}"
    )

if __name__ == "__main__":
    asyncio.run(main())



### FILE: ./core/client.py
# core/client.py — Version 1.0.2

import asyncio
import ccxt.async_support as ccxt
from binance import AsyncClient
from utils.logger import logger

class BinanceClient:
    def __init__(self, client: AsyncClient):
        self.client = client

    @classmethod
    async def create(cls, api_key: str, api_secret: str, testnet: bool = False):
        logger.info(f"🔌 Verbinde mit Binance (testnet={testnet})...")
        client = await AsyncClient.create(
            api_key=api_key,
            api_secret=api_secret,
            testnet=testnet
        )
        return cls(client)

    async def get_futures_price(self, symbol: str) -> float:
        ticker = await self.client.futures_symbol_ticker(symbol=symbol)
        return float(ticker["price"])

    async def fetch_ohlcv(self, symbol: str, timeframe: str, since: int = None, limit: int = None, until: int = None):
        exchange = ccxt.binance({
            'enableRateLimit': True,
            'options': {
                'defaultType': 'future'
            }
        })
        if since and until:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since)
            ohlcv = [c for c in ohlcv if c[0] <= until]
        else:
            ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, since=since, limit=limit)
        await exchange.close()
        return ohlcv

    async def futures_change_leverage(self, symbol: str, leverage: int):
        """
        Setzt das Leverage für ein Futures-Symbol.
        """
        try:
            result = await self.client.futures_change_leverage(symbol=symbol, leverage=leverage)
            logger.info(f"[LEVERAGE] {symbol}: Leverage wurde auf {leverage}x gesetzt. Antwort: {result}")
            return result
        except Exception as e:
            logger.error(f"[LEVERAGE] Fehler beim Setzen des Leverage für {symbol}: {e}")
            raise

    async def close(self):
        await self.client.close_connection()



### FILE: ./core/trade_executor.py
from utils.logger import logger
from strategies.indicators import calculate_atr
from binance.enums import *

SIDE_Buy = "Buy"

class TradeExecutor:
    def __init__(self, client, base_currency: str = "USDC"):
        self.client = client
        self.base_currency = base_currency

    async def execute_trade(
        self,
        symbol: str,
        side: str,
        quantity: float,
        sl: float = None,
        tp: float = None,
        atr_period: int = 14,
        sl_multiplier: float = 1.5,
        tp_multiplier: float = 3.0,
        martingale_factor: float = 1.0,
        paper: bool = True,
        custom_price=None
    ):
        qty = quantity * martingale_factor
        logger.info(f"Placing {side} order for {symbol} qty={qty:.6f} (martingale={martingale_factor})")

        # Preis ermitteln
        if paper:
            price = await self.client.get_futures_price(symbol)
            logger.info(f"(Paper) Order simulated at {price}")
        else:
            order = await self.client.client.futures_create_order(
                symbol=symbol,
                side=side,
                type=FUTURE_ORDER_TYPE_MARKET,
                quantity=qty
            )
            price = float(order["avgPrice"])
            logger.info(f"Order executed at price={price}")

        # SL/TP berechnen wenn nicht manuell übergeben
        if sl is None or tp is None:
            ohlcv = await self.client.fetch_ohlcv(symbol, timeframe='1h', limit=atr_period + 1)
            atr = calculate_atr(ohlcv, period=atr_period)
            sl, tp = self._compute_sl_tp(price, atr, side, sl_multiplier, tp_multiplier)

        return {
            "entry_price": price,
            "sl_price": sl,
            "tp_price": tp,
            "qty": qty
        }

    def _compute_sl_tp(self, entry: float, atr: float, side: str,
                       sl_mult: float, tp_mult: float):
        if side == SIDE_BUY:
            sl = entry - atr * sl_mult
            tp = entry + atr * tp_mult
        else:
            sl = entry + atr * sl_mult
            tp = entry - atr * tp_mult
        return sl, tp



### FILE: ./daily_report.py
import pandas as pd
from utils.email_notify import send_email
from datetime import date

df = pd.read_csv('/home/idppadm/trading-bot/paper_trades.csv')
def send_daily_report():
    # PASSE DEN PFAD AN falls nötig
    df = pd.read_csv("paper_trades.csv")
    today = datetime.utcnow().date()
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df_today = df[df['timestamp'].dt.date == today]
    df_closed = df_today[df_today['pnl'].notna()]

    trades = len(df_closed)
    wins = (df_closed['pnl'] > 0).sum()
    losses = (df_closed['pnl'] < 0).sum()
    winrate = 100 * wins / trades if trades > 0 else 0

    msg = f"""Trading-Bot Tagesreport {today}

Trades: {trades}
Wins: {wins}
Losses: {losses}
Winrate: {winrate:.1f}%

Die letzten 5 Trades:
{df_closed.tail(5).to_string(index=False)}
"""
    send_email("Tagesreport Trading-Bot", msg)

if __name__ == "__main__":
    send_daily_report()


### FILE: ./dashboard/app.py
from flask import Flask, render_template, send_file
import os
import sys
import pandas as pd
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.equity_plot import plot_equity_curve
from utils.trade_logger import log_trade
CSV_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'paper_trades.csv'))
from utils.strategy_leaderboard import StrategyLeaderboard
from dotenv import load_dotenv

load_dotenv()
app = Flask(__name__)
START_BALANCE = float(os.getenv("START_BALANCE", "20.0"))

@app.route("/")
def index():
    if not os.path.isfile(CSV_PATH) or os.path.getsize(CSV_PATH) == 0:
        balance = START_BALANCE
        winrate = 0.0
        total_trades = 0
        trades = []
    else:
        df = pd.read_csv(CSV_PATH)
        df_closed = df[df["pnl"].notna()]
        balance = START_BALANCE + df_closed["pnl"].sum()
        winrate = (df_closed["pnl"] > 0).mean() * 100 if len(df_closed) else 0.0
        total_trades = len(df)
        trades = df.tail(10).to_dict(orient="records")
    # Equity-Kurve aktualisieren
    plot_equity_curve(CSV_PATH, "dashboard/static/equity_curve.png", start_balance=START_BALANCE)
    return render_template(
        "index.html",
        balance=balance,
        winrate=winrate,
        total_trades=total_trades,
        trades=trades,
        equity_curve_path="static/equity_curve.png"
    )

@app.route("/leaderboard")
def leaderboard():
    lb = StrategyLeaderboard()
    _, stats = lb.compute_leaderboard()
    return render_template("leaderboard.html", stats=stats.to_dict(orient="records"))

@app.route("/chart")
def chart():
    return send_file("static/equity_curve.png", mimetype='image/png')

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)



### FILE: ./ml/analyze_backtest.py
import os
import sys
import pandas as pd
from datetime import datetime


from collect_training_data import append_training_data

def analyze_backtest(backtest_csv_path="backtest_results.csv"):
    df = pd.read_csv(backtest_csv_path)
    print(f"Analysiere {len(df)} Backtest-Trades aus {backtest_csv_path}")

    for idx, row in df.iterrows():
        append_training_data(
            timestamp=row.get("timestamp", datetime.utcnow().isoformat()),
            symbol=row.get("symbol", ""),
            open_=row.get("open", ""),
            high=row.get("high", ""),
            low=row.get("low", ""),
            close=row.get("close", ""),
            volume=row.get("volume", ""),
            rsi=row.get("rsi", ""),
            ema=row.get("ema", ""),
            atr=row.get("atr", ""),
            bb_upper=row.get("bb_upper", ""),
            bb_lower=row.get("bb_lower", ""),
            market_state=row.get("market_state", ""),
            strategy=row.get("strategy", ""),
            signal=row.get("signal", ""),
            result=row.get("result", ""),
            type="backtest"
        )
    print("Alle Backtest-Trades wurden ins Training-CSV geschrieben.")

if __name__ == "__main__":
    analyze_backtest()



### FILE: ./ml/backtest_data_import.py
import os
import csv
import time
from datetime import datetime
import ccxt
from tqdm import tqdm
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from strategies.indicators import calculate_ema, calculate_rsi, calculate_atr, calculate_bollinger_bands
from strategies.engine import StrategyEngine

# Konfiguration
EXCHANGE = ccxt.binance({
    'rateLimit': 1200,
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})

OUTPUT_FILE = "ml/training_data_backtest.csv"
SYMBOLS = ["BTC/USDC", "ETH/USDC", "SOL/USDC"]  # Beliebig erweiterbar
TIMEFRAME = "1h"
START_DATE = "2024-01-01T00:00:00Z"  # YYYY-MM-DDTHH:MM:SSZ
END_DATE = "2024-06-30T00:00:00Z"

# Helper
def parse_iso8601(date_str):
    return int(EXCHANGE.parse8601(date_str))

def ohlcv_to_dict(symbol, ohlcv, strategy, market_state):
    # ohlcv: [timestamp, open, high, low, close, volume]
    close = float(ohlcv[4])
    ema = calculate_ema([ohlcv], 1)     # Für Einzelkerze = Kerzenwert
    rsi = calculate_rsi([ohlcv], 1)
    atr = calculate_atr([ohlcv], 1)
    bb_upper, bb_lower = calculate_bollinger_bands([ohlcv], 1)
    return {
        "timestamp": datetime.utcfromtimestamp(ohlcv[0]/1000).isoformat(),
        "symbol": symbol,
        "open": ohlcv[1],
        "high": ohlcv[2],
        "low": ohlcv[3],
        "close": ohlcv[4],
        "volume": ohlcv[5],
        "ema": ema,
        "rsi": rsi,
        "atr": atr,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "market_state": market_state,
        "strategy": strategy,
        "signal": "",    # Noch leer (optional für späteren Backtest/ML-Label)
        "result": ""
    }

def fetch_all_ohlcv(symbol, timeframe, since, until):
    all_candles = []
    limit = 1000
    now = since
    pbar = tqdm(desc=f"Lade {symbol}", total=(until-since)//(60*60*1000))
    while now < until:
        candles = EXCHANGE.fetch_ohlcv(symbol, timeframe, since=now, limit=limit)
        if not candles:
            break
        for c in candles:
            if c[0] > until:
                break
            all_candles.append(c)
        now = candles[-1][0] + 1
        pbar.update(len(candles))
        time.sleep(0.1)
    pbar.close()
    return all_candles

def main():
    # Setup
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, "w", newline='') as f:
        fieldnames = [
            "timestamp", "symbol", "open", "high", "low", "close", "volume",
            "ema", "rsi", "atr", "bb_upper", "bb_lower",
            "market_state", "strategy", "signal", "result"
        ]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()

        engine = StrategyEngine()
        for symbol in SYMBOLS:
            since = parse_iso8601(START_DATE)
            until = parse_iso8601(END_DATE)
            ohlcv_data = fetch_all_ohlcv(symbol, TIMEFRAME, since, until)
            # Sliding-Window für Indikatoren und Strategieauswahl:
            window = []
            for row in tqdm(ohlcv_data, desc=f"Verarbeite {symbol}"):
                window.append(row)
                if len(window) > 50:
                    window = window[-50:]  # nur die letzten 50 Kerzen
                # Marktzustand und Strategie wählen:
                market_state = engine.evaluate_market(window) if len(window) >= 20 else ""
                strategy = engine.select_strategy(window).__class__.__name__ if len(window) >= 20 else ""
                writer.writerow(
                    ohlcv_to_dict(symbol, row, strategy, market_state)
                )

if __name__ == "__main__":
    main()



### FILE: ./ml/backtest_engine.py
import argparse
import pandas as pd
import ccxt
import os
from datetime import datetime, timedelta
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from strategies.engine import StrategyEngine
from strategies.rsi_ema import RSIEMAStrategy
from strategies.breakout import BreakoutStrategy
from strategies.momentum import MomentumStrategy
from strategies.reversal import ReversalStrategy
from strategies.range_trading import RangeTradingStrategy
from strategies.volatility import VolatilityStrategy


def fetch_ohlcv(symbol, timeframe='1h', limit=1000):
    import ccxt
    exchange = ccxt.binance()
    exchange.load_markets()  # <-- das ist die magische Zeile!
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp','open','high','low','close','volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    return df


def get_market_state(engine, ohlcv):
    # Nutze die Engine wie im Paper Loop für Marktklassifizierung
    ohlcv_list = ohlcv[['timestamp','open','high','low','close','volume']].values.tolist()
    return engine.evaluate_market(ohlcv_list)

def run_backtest(symbol, ohlcv, out_csv="backtest_results.csv", initial_balance=20.0):
    strategies = [
        RSIEMAStrategy(),
        BreakoutStrategy(),
        MomentumStrategy(),
        ReversalStrategy(),
        RangeTradingStrategy(),
        VolatilityStrategy()
    ]
    engine = StrategyEngine()
    balance = initial_balance
    trades = []
    position = None

    for i in range(50, len(ohlcv)):  # 50, damit Indikatoren stabil sind
        window = ohlcv.iloc[i-50:i]
        price = window['close'].iloc[-1]
        atr = window['high'].max() - window['low'].min()  # grober ATR Ersatz
        market_state = get_market_state(engine, window)
        # Wähle die Strategie mit Engine
        strat = engine.select_strategy(window[['timestamp','open','high','low','close','volume']].values.tolist())
        # Signal bestimmen
        try:
            signal = strat.generate_signal(window[['timestamp','open','high','low','close','volume']].values.tolist())
            print(f"{i=} {strat.__class__.__name__} signal={signal}")

        except Exception as e:
            print(f"Fehler in Signal-Generierung bei {strat.__class__.__name__}: {e}")
            continue

        # Wenn kein Signal, nächsten Durchlauf
        if not signal:
            continue

        # StopLoss/TakeProfit flexibel abrufen (mit Fallback für alte Signatur)
        side = signal
        volatility = atr / price if price > 0 else 0
        try:
            sl, tp = strat.sl_tp(price, atr, side, market_state, volatility)
        except TypeError:
            try:
                sl, tp = strat.sl_tp(price, atr, side)
            except TypeError:
                sl, tp = strat.sl_tp(price, atr)

        qty = 1  # Für Backtest einfach mit 1 Einheit traden, du kannst hier dynamisch machen!
        entry_price = price
        exit_price = None
        pnl = None

        # Simpler TP/SL Ausstieg im nächsten Candle
        future_window = ohlcv.iloc[i+1:i+10] if (i+10) < len(ohlcv) else ohlcv.iloc[i+1:]
        for idx, futrow in future_window.iterrows():
            high = futrow['high']
            low = futrow['low']
            if side == "BUY":
                if high >= tp:
                    exit_price = tp
                    break
                elif low <= sl:
                    exit_price = sl
                    break
            elif side == "SELL":
                if low <= tp:
                    exit_price = tp
                    break
                elif high >= sl:
                    exit_price = sl
                    break

        if exit_price is None:
            # Wenn weder TP noch SL erreicht, zum Schlusskurs aussteigen
            exit_price = future_window['close'].iloc[-1]

        if side == "BUY":
            pnl = (exit_price - entry_price) * qty
        elif side == "SELL":
            pnl = (entry_price - exit_price) * qty
        else:
            pnl = 0

        trade = {
            'timestamp': window['timestamp'].iloc[-1],
            'symbol': symbol,
            'side': side,
            'entry_price': entry_price,
            'stop_loss': sl,
            'take_profit': tp,
            'qty': qty,
            'exit_price': exit_price,
            'pnl': pnl,
            'strategy': strat.__class__.__name__,
            'market_state': market_state
        }
        trades.append(trade)
        balance += pnl

    df_trades = pd.DataFrame(trades)
    df_trades.to_csv(out_csv, index=False)
    print(f"Backtest abgeschlossen. Ergebnisse in {out_csv} gespeichert.")

def main(symbol="BTCUSDT", timeframe="1h", candles=1000, out_csv="backtest_results.csv"):
    print(f"Lade OHLCV für {symbol}, Intervall {timeframe}, Anzahl {candles} ...")
    ohlcv = fetch_ohlcv(symbol, timeframe, limit=candles)
    run_backtest(symbol, ohlcv, out_csv=out_csv)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--symbol", type=str, default="BTCUSDT")
    parser.add_argument("--timeframe", type=str, default="1h")
    parser.add_argument("--candles", type=int, default=1000)
    parser.add_argument("--out", type=str, default="backtest_results.csv")
    args = parser.parse_args()

    main(symbol=args.symbol, timeframe=args.timeframe, candles=args.candles, out_csv=args.out)



### FILE: ./ml/collect_training_data.py
import csv
import os
from threading import Lock

file_lock = Lock()

def append_training_data(
    timestamp,
    symbol,
    open_,
    high,
    low,
    close,
    volume,
    rsi,
    ema,
    atr,
    bb_upper,
    bb_lower,
    market_state,
    strategy,
    signal,
    result,
    type="live",
    filename="ml/training_data.csv"
):
    """
    Loggt einen Datensatz für das ML-Training.
    """
    fieldnames = [
        "timestamp", "symbol", "open", "high", "low", "close", "volume", "rsi", "ema", "atr",
        "bb_upper", "bb_lower", "market_state", "strategy", "signal", "result", "type"
    ]
    file_exists = os.path.isfile(filename)
    data = {
        "timestamp": timestamp,
        "symbol": symbol,
        "open": open_,
        "high": high,
        "low": low,
        "close": close,
        "volume": volume,
        "rsi": rsi,
        "ema": ema,
        "atr": atr,
        "bb_upper": bb_upper,
        "bb_lower": bb_lower,
        "market_state": market_state,
        "strategy": strategy,
        "signal": signal,
        "result": result,
        "type": type
    }
    with file_lock:
        with open(filename, mode="a", newline="") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            if not file_exists:
                writer.writeheader()
            writer.writerow(data)



### FILE: ./ml/feature_engineering_ml.py
import pandas as pd
import os

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import classification_report, confusion_matrix

# Optional: ML-Logging-Flag (siehe Punkt 6)
ML_LOGGING = os.getenv("ENABLE_TRAINING_DATA", "true").lower() == "true"

CSV_FILE = "training_data.csv"
df = pd.read_csv(CSV_FILE)
filter_type = os.getenv("FEAT_TYPE", "paper")
df = df[df["type"] == filter_type]

# Nur Trades mit Signal und Result
df_trades = df[df["signal"].notna() & df["result"].notna()]

# Feature Engineering
df_trades["high_low_range"] = (df_trades["high"] - df_trades["low"]) / df_trades["close"]
df_trades["atr_relative"] = df_trades["atr"] / df_trades["close"]
df_trades["hour"] = pd.to_datetime(df_trades["timestamp"]).dt.hour
df_trades["weekday"] = pd.to_datetime(df_trades["timestamp"]).dt.weekday

features = [
    "open", "high", "low", "close", "volume", "rsi", "ema",
    "atr", "bb_upper", "bb_lower", "high_low_range", "atr_relative", "hour", "weekday"
]
X = df_trades[features]
y = (df_trades["result"] > 0).astype(int)  # 1 = Gewinn, 0 = Verlust

# ML-Train/Test-Split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Modelltraining
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)

# Ergebnis-Report
print(classification_report(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))

# Cross-Validation
cv_scores = cross_val_score(clf, X, y, cv=5)
print(f"Cross-Validation Accuracy: {cv_scores.mean():.4f} ± {cv_scores.std():.4f}")

# Features speichern
df_trades[features + ["result"]].to_csv("ml/training_features.csv", index=False)
print("Feature-Engineering & Modelltraining abgeschlossen. Features gespeichert in ml/training_features.csv.")



### FILE: ./ml/ml_predict.py
# ml/ml_predict.py
import joblib
import pandas as pd
import os
BASE_PATH = os.path.dirname(os.path.abspath(__file__))
MODEL_PATH = os.path.join(BASE_PATH, "best_trading_model.pkl")
ml_model = joblib.load(MODEL_PATH)

# Modell laden (Pfad ggf. anpassen)
#ml_model = joblib.load('ml/best_trading_model.pkl')

FEATURES = [
    'open', 'high', 'low', 'close', 'volume',
    'rsi', 'ema', 'atr', 'bb_upper', 'bb_lower',
    'market_state', 'strategy', 'signal'
]

def predict_trade_signal(trade_dict):
    df = pd.DataFrame([trade_dict])
    # Kategorische Features umcodieren
    for col in ['market_state', 'strategy', 'signal']:
        if col in df.columns and df[col].dtype == 'object':
            df[col] = df[col].astype('category').cat.codes
    # Fehlende Features füllen
    for f in FEATURES:
        if f not in df.columns:
            df[f] = 0
    X = df[FEATURES]
    prediction = ml_model.predict(X)[0]
    probability = ml_model.predict_proba(X)[0][1]
    return prediction, probability



### FILE: ./multi_backtest.py
import asyncio
from utils.backtester import Backtester

symbol_list = ["BTCUSDC", "ETHUSDC", "BNBUSDC", "SOLUSDC"]
start = "2025-01-01T00:00"
end = "2025-06-01T00:00"
granularity = "1h"
initial_balance = 20.0

async def run_backtests():
    tasks = []
    for symbol in symbol_list:
        bt = Backtester(
            symbol=symbol,
            start=start,
            end=end,
            granularity=granularity,
            initial_balance=initial_balance
        )
        tasks.append(bt.run())
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(run_backtests())



### FILE: ./paper_loop.py
import os
import sys
import asyncio
from dotenv import load_dotenv
from datetime import datetime
import aiohttp
import pandas as pd

# Pfad für Modulimporte setzen
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.engine import StrategyEngine
from strategies.indicators import calculate_atr, calculate_ema, calculate_rsi, calculate_bollinger_bands
from utils.logger import logger
from utils.trade_logger import log_trade
from utils.trade_tracker import update_trade_pnls
from utils.risk_manager import RiskManager
from utils.cooldown_manager import CooldownManager
from utils.signal_filter import SignalFilter
from utils.drawdown_guard import DrawdownGuard
from utils.strategy_watchdog import StrategyWatchdog
from utils.email_notify import send_email
from ml.collect_training_data import append_training_data
from utils.trailing_stop import update_trailing_stops
from utils.grid_manager import GridManager
from utils.reentry_manager import ReEntryManager
from utils.strategy_blocklist import StrategyBlocklist
from utils.equity_protector import EquityProtector
try:
    from ml.ml_predict import predict_trade_signal
except ImportError:
    predict_trade_signal = None

load_dotenv()
ML_LOGGING = os.getenv("ENABLE_TRAINING_DATA", "true").lower() == "true"

# SYSTEM-SETUP
grid = GridManager()
reentry = ReEntryManager()
blocklist = StrategyBlocklist()
equity_protect = EquityProtector()
PAPER = True
INTERVAL = 10
START_BALANCE = float(os.getenv("START_BALANCE", "20.0") or 20.0)
LEVERAGE = 5
SYMBOLS = []

engine = StrategyEngine()
risk_manager = RiskManager(initial_balance=START_BALANCE, max_risk_per_trade=0.02, leverage=LEVERAGE)
cooldown = CooldownManager(cooldown_minutes=30)
signal_filter = SignalFilter()
drawdown_guard = DrawdownGuard(start_balance=START_BALANCE, max_loss_pct=5.0)
watchdog = StrategyWatchdog()

def has_open_trade(symbol, trades_csv="paper_trades.csv"):
    if not os.path.isfile(trades_csv):
        return False
    df = pd.read_csv(trades_csv)
    df_symbol = df[df["symbol"] == symbol]
    open_trades = df_symbol[df_symbol["pnl"].isnull() | (df_symbol["pnl"] == "")]
    return not open_trades.empty

async def get_top_usdc_symbols_by_volume(limit=100):
    url = "https://fapi.binance.com/fapi/v1/ticker/24hr"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
            # Filter auf Paare mit USDC und ausreichendem Volumen
            filtered = [d for d in data if d["symbol"].endswith("USDC") and float(d["quoteVolume"]) > 100000]
            sorted_pairs = sorted(filtered, key=lambda x: float(x["quoteVolume"]), reverse=True)
            return [item["symbol"] for item in sorted_pairs[:limit]]

async def execute_grid_recovery(symbol, signal, price, qty, sl, tp, executor):
    """Startet das Grid-Trading (Recovery) nach einem Verlust-Trade."""
    try:
        levels = 3
        grid_prices = grid.generate_grid_orders(price, side=signal)
        for level_price in grid_prices:
            recovery_qty = qty / levels
            logger.info(f"[GRID] {symbol}: Recovery-Level {signal} @ {level_price:.2f}, QTY={recovery_qty:.4f}")
            await executor.execute_trade(
                symbol=symbol,
                side=signal,
                quantity=recovery_qty,
                sl=sl,
                tp=tp,
                paper=PAPER,
                custom_price=level_price
            )
    except Exception as e:
        logger.warning(f"[GRID] {symbol}: Grid-Ausführung fehlgeschlagen: {e}")

async def trade_task(symbol, client, executor):
    try:
        if has_open_trade(symbol):
            logger.info(f"[POSITION] {symbol}: Offene Position vorhanden – übersprungen.")
            return
        if not reentry.can_reenter(symbol):
            logger.info(f"[REENTRY] {symbol}: Cooldown nach Verlust aktiv – übersprungen.")
            return
        # Marktdaten abrufen und Indikatoren berechnen
        ohlcv = await client.fetch_ohlcv(symbol, "1h", limit=50)
        closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
        price = closes[-1]
        atr = calculate_atr(ohlcv, 14)
        ema = calculate_ema(ohlcv, 50)
        rsi = calculate_rsi(ohlcv, 14)
        bb_upper, bb_lower = calculate_bollinger_bands(ohlcv, 20, 2)
        # Strategie auswählen und Signal generieren
        strategy = engine.select_strategy(ohlcv)
        strategy_name = strategy.__class__.__name__
        if blocklist.is_blocked(strategy_name):
            logger.info(f"[BLOCKED] {symbol}: {strategy_name} gesperrt – übersprungen.")
            return
        signal = strategy.generate_signal(ohlcv)
        market_state = engine.evaluate_market(ohlcv)
        # Bei hoher Volatilität Grid-Trading statt Single-Trade
        if market_state == "volatile" and signal in ["BUY", "SELL"] and not has_open_trade(symbol):
            sl, tp = strategy.sl_tp(price, atr, signal, market_state, atr / price)
            qty = risk_manager.calculate_position_size(entry_price=price, stop_loss=sl)
            if qty > 0:
                logger.warning(f"[GRID-MODE] {symbol}: Volatilität erkannt – starte Grid-Trading.")
                await execute_grid_recovery(symbol, signal, price, qty, sl, tp, executor)
                return
        # Optional: ML-Trainingdaten protokollieren
        if ML_LOGGING:
            append_training_data(
                timestamp=datetime.utcnow().isoformat(),
                symbol=symbol,
                open_=ohlcv[-1][1], high=ohlcv[-1][2], low=ohlcv[-1][3], close=ohlcv[-1][4],
                volume=ohlcv[-1][5], rsi=rsi, ema=ema, atr=atr, bb_upper=bb_upper, bb_lower=bb_lower,
                market_state=market_state, strategy=strategy_name, signal=signal,
                result=None, type="paper"
            )
        if not signal:
            logger.info(f"[FILTER] {symbol}: Kein Signal.")
            return
        if cooldown.is_in_cooldown(symbol):
            logger.info(f"[COOLDOWN] {symbol}: aktiv – übersprungen.")
            return
        if not signal_filter.passes_filters(ohlcv):
            logger.info(f"[FILTER] {symbol}: Markt ungeeignet – übersprungen.")
            return
        # ML-Prediction prüfen, ob Trade übersprungen werden soll
        if predict_trade_signal:
            features = {
                "open": float(ohlcv[-1][1]), "high": float(ohlcv[-1][2]), "low": float(ohlcv[-1][3]), "close": float(ohlcv[-1][4]), "volume": float(ohlcv[-1][5]),
                "rsi": rsi, "ema": ema, "atr": atr, "bb_upper": bb_upper, "bb_lower": bb_lower,
                "market_state": market_state, "strategy": strategy_name, "signal": signal
            }
            try:
                pred, prob = predict_trade_signal(features)
            except Exception:
                pred, prob = None, 0.0
            if pred == 0:
                logger.info(f"[ML] {symbol}: Modell prognostiziert Verlust (Wahrscheinlichkeit {prob*100:.1f}%) – Trade übersprungen.")
                return
        # Stop-Loss, Take-Profit und Positionsgröße berechnen
        sl, tp = strategy.sl_tp(price, atr, signal, market_state, atr / price)
        qty = risk_manager.calculate_position_size(entry_price=price, stop_loss=sl)
        if equity_protect.should_reduce_risk():
            qty *= 0.5
        if qty <= 0 or qty > 10000:
            logger.warning(f"[RISK] {symbol}: Ordergröße unzulässig – übersprungen.")
            return
        logger.info(f"[TRADE] {symbol}: {signal} @ {price:.4f} SL={sl:.4f} TP={tp:.4f} QTY={qty:.4f} Leverage={risk_manager.leverage}")
        result = await executor.execute_trade(symbol=symbol, side=signal, quantity=qty, sl=sl, tp=tp, paper=PAPER)
        # Trade im Log (CSV) erfassen
        log_trade(symbol=symbol, side=signal, entry_price=result["entry_price"], stop_loss=sl, take_profit=tp, qty=qty, strategy=strategy_name, leverage=risk_manager.leverage)
        cooldown.update_cooldown(symbol)
        # Hinweis: Grid-Recovery bei Verlust erfolgt nach Trade-Abschluss (siehe update_trade_pnls)
        if ML_LOGGING:
            append_training_data(
                timestamp=datetime.utcnow().isoformat(),
                symbol=symbol,
                open_=ohlcv[-1][1], high=ohlcv[-1][2], low=ohlcv[-1][3], close=ohlcv[-1][4],
                volume=ohlcv[-1][5], rsi=rsi, ema=ema, atr=atr, bb_upper=bb_upper, bb_lower=bb_lower,
                market_state=market_state, strategy=strategy_name, signal=signal,
                result=(result.get("pnl") if result else None), type="paper"
            )
    except Exception as e:
        logger.error(f"[{symbol}] Fehler im Trade: {e}")
        if "exchangeInfo" not in str(e):
            send_email(subject=f"TradingBot ERROR [{symbol}]", body=f"Fehler im Trading-Bot für {symbol}:\n{e}")

async def trade_loop():
    global SYMBOLS
    client = await BinanceClient.create(
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
        testnet=os.getenv("USE_TESTNET", "True").lower() == "true"
    )
    executor = TradeExecutor(client)
    try:
        SYMBOLS = await get_top_usdc_symbols_by_volume(limit=25)
        logger.info(f"📊 Überwachte Paare: {', '.join(SYMBOLS[:10])} ...")
        while True:
            if drawdown_guard.loss_today_exceeded():
                logger.warning("🛑 Tagesverlustgrenze erreicht – pausiert.")
                await asyncio.sleep(INTERVAL)
                continue
            # Parallel Trade-Tasks für alle Symbole starten
            tasks = [trade_task(symbol, client, executor) for symbol in SYMBOLS]
            await asyncio.gather(*tasks)
            try:
                # Preise und ATR für aktive Symbole abrufen
                current_prices = {symbol: await client.get_futures_price(symbol) for symbol in SYMBOLS}
                atr_lookup = {symbol: calculate_atr(await client.fetch_ohlcv(symbol, "1h", limit=50), 14) for symbol in SYMBOLS}
                # Trailing-Stops und PnL-Updates durchführen
                update_trailing_stops("paper_trades.csv", current_prices)
                closed_losses = update_trade_pnls(current_prices=current_prices, atr_lookup=atr_lookup)
                # Grid-Recovery für alle geschlossenen Verlust-Trades anstoßen
                for (sym, side, entry_price, qty, sl, tp) in closed_losses:
                    reentry.register_loss(sym)
                    logger.warning(f"[LOSS] {sym}: Trade mit Verlust geschlossen – starte Grid-Recovery.")
                    await execute_grid_recovery(sym, side, entry_price, qty, sl, tp, executor)
                # Kontostand nach abgeschlossenen Trades aktualisieren
                df_all = pd.read_csv("paper_trades.csv")
                total_closed_pnl = df_all[df_all["pnl"].notna()]["pnl"].sum()
                current_balance = risk_manager.initial_balance + total_closed_pnl
                risk_manager.update_balance(current_balance)
            except Exception as e:
                logger.warning(f"[PnL] Fehler beim Preisabruf: {e}")
            logger.info(f"⏳ Nächster Zyklus in {INTERVAL} Sekunden...\n")
            await asyncio.sleep(INTERVAL)
    finally:
        await client.close()



### FILE: ./strategies/breakout.py
from strategies.indicators import calculate_atr

class BreakoutStrategy:
    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        highs = [row[2] for row in ohlcv[-21:]]
        lows = [row[3] for row in ohlcv[-21:]]
        price = closes[-1]

        # Buy-Breakout: schließt über dem lokalen Hoch der letzten 20 Kerzen, mit Volumenfilter
        if price > max(highs[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "BUY"
        # Sell-Breakout: schließt unter dem lokalen Tief der letzten 20 Kerzen
        elif price < min(lows[:-1]) and ohlcv[-1][5] > sum([row[5] for row in ohlcv[-11:-1]])/10:
            return "SELL"
        else:
            return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "trend":
            sl_mult = 1.5 if volatility < 0.01 else 2.5
            tp_mult = 3.5 if volatility < 0.01 else 7.0
        elif market_state == "sideways":
            sl_mult = 1.0
            tp_mult = 1.2
        else:  # volatile
            sl_mult = 3.0
            tp_mult = 6.0
        return sl_mult, tp_mult

    def score(self, ohlcv, market_type):
        # Perfekt in klaren Trendphasen!
        if market_type == "trend":
            return 2
        return 0



### FILE: ./strategies/engine.py
from strategies.rsi_ema import RSIEMAStrategy
from strategies.breakout import BreakoutStrategy
from strategies.momentum import MomentumStrategy
from strategies.reversal import ReversalStrategy
from strategies.range_trading import RangeTradingStrategy
from strategies.volatility import VolatilityStrategy
from utils.strategy_leaderboard import StrategyLeaderboard
from strategies.indicators import calculate_atr, calculate_ema, calculate_rsi, calculate_bollinger_bands
try:
    from ml.ml_predict import predict_trade_signal
except ImportError:
    predict_trade_signal = None

class StrategyEngine:
    def __init__(self):
        self.leaderboard = StrategyLeaderboard()
        self.strategies = [
            RSIEMAStrategy(),
            BreakoutStrategy(),
            MomentumStrategy(),
            ReversalStrategy(),
            RangeTradingStrategy(),
            VolatilityStrategy()
        ]

    def evaluate_market(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 21:
            return "sideways"
        change = abs(closes[-1] - closes[-20]) / closes[-20]
        if change > 0.03:
            return "trend"
        atr = abs(max(closes[-20:]) - min(closes[-20:])) / closes[-20]
        if atr > 0.04:
            return "volatile"
        return "sideways"

    def select_strategy(self, ohlcv):
        # Ermittle Top-Strategien aus Leaderboard (mit ausreichend Trades)
        enabled_strats, _ = self.leaderboard.compute_leaderboard(min_trades=10, top_n=2)
        market = self.evaluate_market(ohlcv)
        candidates = []
        for strategy in self.strategies:
            s_name = strategy.__class__.__name__
            if enabled_strats and s_name not in enabled_strats:
                continue
            if hasattr(strategy, "suits") and strategy.suits(market):
                candidates.append(strategy)
        # ML-Vorhersage zur Strategiewahl (übersteuert Auswahl, falls Modell vorhanden)
        if candidates and predict_trade_signal:
            # Indikatoren für ML-Features berechnen
            open_val = float(ohlcv[-1][1]); high_val = float(ohlcv[-1][2])
            low_val = float(ohlcv[-1][3]); close_val = float(ohlcv[-1][4])
            volume_val = float(ohlcv[-1][5])
            atr_val = calculate_atr(ohlcv, 14)
            ema_val = calculate_ema(ohlcv, 50)
            rsi_val = calculate_rsi(ohlcv, 14)
            bb_upper_val, bb_lower_val = calculate_bollinger_bands(ohlcv, 20, 2)
            best_strat = None
            best_prob = 0.0
            for strat in candidates:
                try:
                    test_signal = strat.generate_signal(ohlcv)
                except Exception:
                    test_signal = None
                if not test_signal:
                    continue
                features = {
                    "open": open_val, "high": high_val, "low": low_val, "close": close_val, "volume": volume_val,
                    "rsi": rsi_val, "ema": ema_val, "atr": atr_val,
                    "bb_upper": bb_upper_val, "bb_lower": bb_lower_val,
                    "market_state": market, "strategy": strat.__class__.__name__, "signal": test_signal
                }
                try:
                    pred, prob = predict_trade_signal(features)
                except Exception:
                    pred, prob = None, 0.0
                if pred == 1 and prob >= best_prob:
                    best_prob = prob
                    best_strat = strat
            if best_strat:
                return best_strat
        # 1. Priorität: passende Strategie (Top-N mit suits())
        if candidates:
            return candidates[0]
        # 2. Fallback: Top-Strategie verwenden, auch wenn suits() nicht passt
        if enabled_strats:
            for strategy in self.strategies:
                if strategy.__class__.__name__ in enabled_strats:
                    return strategy
        # 3. Letzter Fallback: irgendeine zur Marktlage passende Strategie
        for strategy in self.strategies:
            if hasattr(strategy, "suits") and strategy.suits(market):
                return strategy
        # 4. Ultimativer Fallback: erste Strategie
        return self.strategies[0]



### FILE: ./strategies/indicators.py
import numpy as np

def calculate_rsi(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period + 1:
        return 50.0
    deltas = np.diff(closes)
    gain = np.where(deltas > 0, deltas, 0).sum() / period
    loss = -np.where(deltas < 0, deltas, 0).sum() / period
    if loss == 0:
        return 100.0
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_ema(ohlcv, period=14):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return closes[-1] if closes else 0.0
    ema = np.mean(closes[-period:])
    multiplier = 2 / (period + 1)
    for price in closes[-period:]:
        ema = (price - ema) * multiplier + ema
    return ema

def calculate_atr(ohlcv, period=14):
    if len(ohlcv) < period + 1:
        return 0.0
    high = [float(row[2]) for row in ohlcv]
    low = [float(row[3]) for row in ohlcv]
    close = [float(row[4]) for row in ohlcv]
    tr = []
    for i in range(1, len(ohlcv)):
        tr.append(max(
            high[i] - low[i],
            abs(high[i] - close[i-1]),
            abs(low[i] - close[i-1])
        ))
    if len(tr) < period:
        return np.mean(tr) if tr else 0.0
    atr = np.mean(tr[-period:])
    return atr

def calculate_bollinger_bands(ohlcv, period=20, multiplier=2):
    closes = [float(row[4]) for row in ohlcv if str(row[4]).replace('.', '', 1).isdigit()]
    if len(closes) < period:
        return (0.0, 0.0)
    moving_avg = np.mean(closes[-period:])
    std_dev = np.std(closes[-period:])
    upper_band = moving_avg + (std_dev * multiplier)
    lower_band = moving_avg - (std_dev * multiplier)
    return upper_band, lower_band



### FILE: ./strategies/momentum.py
from strategies.indicators import calculate_ema

class MomentumStrategy:
    def suits(self, market_type: str) -> bool:
        # Nur in klaren Trends sinnvoll!
        return market_type == "trend"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 11:
            return None
        # Momentum = aktueller Schluss minus vor 10 Perioden
        momentum = closes[-1] - closes[-10]
        if momentum > 0:
            return "BUY"
        elif momentum < 0:
            return "SELL"
        return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "trend":
            sl_mult = 1.2 if volatility < 0.01 else 2.0
            tp_mult = 2.0 if volatility < 0.01 else 4.0
        elif market_state == "sideways":
            sl_mult = 0.8
            tp_mult = 1.2
        else:  # volatile
            sl_mult = 2.0
            tp_mult = 5.0
        return sl_mult, tp_mult



### FILE: ./strategies/range_trading.py
from strategies.indicators import calculate_ema

class RangeTradingStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 21:
            return None
        highs = [float(row[2]) for row in ohlcv[-21:]]
        lows = [float(row[3]) for row in ohlcv[-21:]]
        price = closes[-1]
        # Kauf am unteren Bereich, Verkauf am oberen Bereich der Range
        if price <= min(lows[:-1]) * 1.01:
            return "BUY"
        elif price >= max(highs[:-1]) * 0.99:
            return "SELL"
        return None

    
    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "sideways":
            sl_mult = 0.6
            tp_mult = 1.0
        elif market_state == "trend":
            sl_mult = 1.0
            tp_mult = 1.5
        else:  # volatile
            sl_mult = 1.5
            tp_mult = 3.0
        return sl_mult, tp_mult




### FILE: ./strategies/reversal.py
from strategies.indicators import calculate_rsi

class ReversalStrategy:
    def suits(self, market_type: str) -> bool:
        # Nur sinnvoll im Seitwärtsmarkt
        return market_type == "sideways"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 15:
            return None
        rsi = calculate_rsi(ohlcv, 14)
        if rsi > 75:
            return "SELL"
        elif rsi < 25:
            return "BUY"
        return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "sideways":
            sl_mult = 0.8
            tp_mult = 1.3
        elif market_state == "trend":
            sl_mult = 1.3
            tp_mult = 1.7
        else:  # volatile
            sl_mult = 1.8
            tp_mult = 3.0
        return sl_mult, tp_mult



### FILE: ./strategies/rsi_ema.py
from strategies.indicators import calculate_rsi, calculate_ema, calculate_atr

class RSIEMAStrategy:
    def __init__(self, rsi_period=14, ema_period=50):
        self.rsi_period = rsi_period
        self.ema_period = ema_period

    def generate_signal(self, ohlcv):
        closes = [row[4] for row in ohlcv]
        rsi = calculate_rsi(ohlcv, self.rsi_period)
        ema = calculate_ema(ohlcv, self.ema_period)
        price = closes[-1]

        # Long wenn RSI unter 32 UND über EMA (bullisher Dip)
        if rsi < 32 and price > ema:
            return "BUY"
        # Short wenn RSI über 68 UND unter EMA (bearisher Spike)
        elif rsi > 68 and price < ema:
            return "SELL"
        else:
            return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:  # SELL
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "trend":
            sl_mult = 1.2 if volatility < 0.01 else 2.0
            tp_mult = 2.5 if volatility < 0.01 else 5.0
        elif market_state == "sideways":
            sl_mult = 0.7
            tp_mult = 1.0
        else:  # volatile
            sl_mult = 2.5
            tp_mult = 5.0
        return sl_mult, tp_mult

    def score(self, ohlcv, market_type):
        # Sehr gut in trendarmen oder schwankenden Märkten
        if market_type == "sideways":
            return 1
        return 0



### FILE: ./strategies/volatility.py
from strategies.indicators import calculate_atr, calculate_ema

class VolatilityStrategy:
    def suits(self, market_type: str) -> bool:
        return market_type == "volatile"

    def generate_signal(self, ohlcv):
        closes = [float(row[4]) for row in ohlcv]
        if len(closes) < 50:
            return None
        atr = calculate_atr(ohlcv, 14)
        ema50 = calculate_ema(ohlcv, 50)
        price = closes[-1]
        if atr > price * 0.02:  # Nur sehr volatile Märkte
            if price > ema50:
                return "BUY"
            elif price < ema50:
                return "SELL"
        return None

    def sl_tp(self, entry, atr, side, market_state, volatility):
        sl_mult, tp_mult = self.get_sl_tp_mults(market_state, volatility)
        if side == "BUY":
            sl = entry - sl_mult * atr
            tp = entry + tp_mult * atr
        else:
            sl = entry + sl_mult * atr
            tp = entry - tp_mult * atr
        return sl, tp

    @staticmethod
    def get_sl_tp_mults(market_state, volatility):
        if market_state == "volatile":
            sl_mult = 3.0
            tp_mult = 6.0
        elif market_state == "trend":
            sl_mult = 2.0
            tp_mult = 4.0
        else:  # sideways
            sl_mult = 1.2
            tp_mult = 1.6
        return sl_mult, tp_mult



### FILE: ./utils/backtester.py
# utils/backtester.py — Version 1.0.2

import os
import asyncio
import csv
import math
from datetime import datetime
from statistics import mean, pstdev
from core.client import BinanceClient
from core.trade_executor import TradeExecutor
from strategies.indicators import calculate_ema, calculate_rsi, ATR
from utils.logger import logger
from dotenv import load_dotenv


__version__ = "1.0.2"

class Backtester:
    def __init__(self, symbol: str, start: str, end: str,
                 granularity: str = '1h', initial_balance: float = 20.0):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.granularity = granularity
        self.initial_balance = initial_balance
        self.client = None
        self.executor = None
        self.reset()

    def reset(self):
        self.balance = self.initial_balance
        self.pos = None
        self.trades = []
        self.equity_curve = [self.initial_balance]

    async def run(self):
        # Lade API-Konfig aus .env
        load_dotenv()
        api_key = os.getenv("BINANCE_API_KEY")
        api_secret = os.getenv("BINANCE_API_SECRET")
        testnet = os.getenv("USE_TESTNET", "True").lower() == "true"

        # BinanceClient asynchron initialisieren
        self.client = await BinanceClient.create(api_key, api_secret, testnet)
        self.executor = TradeExecutor(self.client)

        logger.info(f"📊 Backtest für {self.symbol} gestartet…")
        ohlcv = await self.client.fetch_ohlcv(
            self.symbol, self.granularity,
            since=self._ts(self.start),
            until=self._ts(self.end)
        )

        for i in range(len(ohlcv)):
            ts, o, h, l, c, v = ohlcv[i]
            time = datetime.utcfromtimestamp(ts/1000)

            # Indikatoren berechnen
            window_ema = [row[4] for row in ohlcv[max(0, i-50):i+1]]
            window_rsi = [row[4] for row in ohlcv[max(0, i-15):i+1]]
            window_atr = ohlcv[max(0, i-15):i+1]
            ema = calculate_ema(window_ema, period=20)
            rsi = calculate_rsi(window_rsi, period=14)
            atr = calculate_atr(window_atr, period=14)

            # Entry-Signale
            if not self.pos:
                if c > ema and rsi < 30:
                    signal = 'BUY'
                elif c < ema and rsi > 70:
                    signal = 'SELL'
                else:
                    signal = None

                if signal:
                    qty = self.balance / c
                    res = await self.executor.execute_trade(
                        self.symbol, signal, qty,
                        atr_period=14, sl_multiplier=1.5, tp_multiplier=3.0,
                        martingale_factor=1.0, paper=True
                    )
                    self.pos = {
                        'entry_time': time,
                        'entry_price': res['entry_price'],
                        'sl': res['sl_price'],
                        'tp': res['tp_price'],
                        'qty': res['qty'],
                        'side': signal
                    }

            # Exit-Logik
            if self.pos:
                price = c
                side = self.pos['side']
                exit_trade = False
                if side == 'BUY' and (price <= self.pos['sl'] or price >= self.pos['tp']):
                    exit_trade = True
                elif side == 'SELL' and (price >= self.pos['sl'] or price <= self.pos['tp']):
                    exit_trade = True

                if exit_trade:
                    pnl = (price - self.pos['entry_price']) * self.pos['qty']
                    if side == 'SELL':
                        pnl *= -1
                    self.balance += pnl
                    self.trades.append({
                        'entry': self.pos['entry_price'],
                        'exit': price,
                        'pnl': pnl
                    })
                    self.equity_curve.append(self.balance)
                    logger.info(
                        f"[Backtest] {side} {self.symbol} Entry={self.pos['entry_price']:.2f} Exit={price:.2f} P&L={pnl:.4f} Bal={self.balance:.4f}"
                    )
                    self.pos = None

        stats = self._compute_metrics()
        self._save_results(stats)
        logger.info(f"📈 Backtest abgeschlossen — Endbalance: {self.balance:.2f} — Stats: {stats}")

    def _compute_metrics(self):
        returns = []
        peak = self.initial_balance
        max_dd = 0
        wins = 0

        for bal in self.equity_curve[1:]:
            ret = (bal - peak) / peak
            returns.append(ret)
            if bal > peak:
                peak = bal
            dd = (peak - bal) / peak
            max_dd = max(max_dd, dd)
            if ret > 0:
                wins += 1

        win_rate = wins / len(returns) if returns else 0
        avg_ret = mean(returns) if returns else 0
        std_ret = pstdev(returns) if len(returns) > 1 else 0.0001
        sharpe = (avg_ret / std_ret) * math.sqrt(8760) if std_ret else 0
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        return {
            'total_return': total_return,
            'max_drawdown': max_dd,
            'win_rate': win_rate,
            'sharpe_ratio': sharpe
        }

    def _save_results(self, stats: dict):
        base = f"backtest_{self.symbol}_{self.start}_{self.end}"
        with open(f"{base}.csv", 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=['entry', 'exit', 'pnl'])
            writer.writeheader()
            for t in self.trades:
                writer.writerow(t)
        with open(f"{base}_stats.txt", 'w') as f:
            for k, v in stats.items():
                f.write(f"{k}: {v}\n")

    @staticmethod
    def _ts(date_str: str) -> int:
        dt = datetime.fromisoformat(date_str)
        return int(dt.timestamp() * 1000)



### FILE: ./utils/cooldown_manager.py
# utils/cooldown_manager.py

from datetime import datetime, timedelta

class CooldownManager:
    def __init__(self, cooldown_minutes=30):
        self.cooldowns = {}  # symbol → datetime
        self.cooldown_duration = timedelta(minutes=cooldown_minutes)

    def is_in_cooldown(self, symbol: str) -> bool:
        now = datetime.utcnow()
        last = self.cooldowns.get(symbol)
        return last and (now - last) < self.cooldown_duration

    def update_cooldown(self, symbol: str):
        self.cooldowns[symbol] = datetime.utcnow()



### FILE: ./utils/drawdown_guard.py
# utils/drawdown_guard.py

from datetime import datetime
import pandas as pd

class DrawdownGuard:
    def __init__(self, csv_file="paper_trades.csv", start_balance=20.0, max_loss_pct=5.0):
        self.csv_file = csv_file
        self.start_balance = start_balance
        self.max_loss_pct = max_loss_pct

    def loss_today_exceeded(self) -> bool:
        try:
            df = pd.read_csv(self.csv_file)
            df = df[df["pnl"].notna()]
            today = datetime.utcnow().date()
            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df[df["timestamp"].dt.date == today]

            if df.empty:
                return False

            pnl_sum = df["pnl"].sum()
            loss_pct = -pnl_sum / self.start_balance * 100 if pnl_sum < 0 else 0

            return loss_pct >= self.max_loss_pct
        except Exception:
            return False  # Lieber weiter traden als fälschlich stoppen



### FILE: ./utils/email_notify.py
import os
import smtplib
from email.message import EmailMessage
from dotenv import load_dotenv
import time
from collections import defaultdict
# Globales Fehler-Cache mit Zeitstempel
_error_cache = defaultdict(lambda: 0)
ERROR_RATE_LIMIT_SECONDS = 3000  # 50 Minuten zwischen denselben Fehlern
load_dotenv()

EMAIL_HOST = os.getenv("EMAIL_HOST")
EMAIL_PORT = int(os.getenv("EMAIL_PORT", 587))
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASS = os.getenv("EMAIL_PASS")
EMAIL_TO   = os.getenv("EMAIL_TO")

def send_email(subject: str, body: str):
    global _error_cache

    cache_key = f"{subject}:{body.splitlines()[0][:50]}"  # Einfache Fehler-Signatur
    now = time.time()

    if now - _error_cache[cache_key] < ERROR_RATE_LIMIT_SECONDS:
        print(f"[Email] Rate-Limit aktiv für: {cache_key}")
        return  # Abort E-Mail, Limit aktiv

    _error_cache[cache_key] = now  # Zeitstempel aktualisieren

    try:
        # Hier bleibt dein tatsächlicher Mailversand
        import smtplib
        from email.mime.text import MIMEText
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = os.getenv("EMAIL_FROM")
        msg['To'] = os.getenv("EMAIL_TO")

        with smtplib.SMTP_SSL(os.getenv("SMTP_SERVER"), int(os.getenv("SMTP_PORT"))) as server:
            server.login(os.getenv("EMAIL_FROM"), os.getenv("EMAIL_PASS"))
            server.send_message(msg)

        print(f"[Email] Gesendet: {subject}")
    except Exception as e:
        print(f"[Email] Fehler beim Senden: {e}")



### FILE: ./utils/equity_plot.py
import os
import pandas as pd
import matplotlib.pyplot as plt

def plot_equity_curve(csv_file, output_file, start_balance=0.0):
    """
    Erstellt die Equity-Kurven-Grafik basierend auf den abgeschlossenen Trades.
    """
    if not os.path.isfile(csv_file):
        # Keine Trades – nur Startkapital als Linie
        balances = [start_balance, start_balance]
    else:
        df = pd.read_csv(csv_file)
        df_closed = df[df["pnl"].notna()]
        balances = [start_balance]
        cumulative_balance = start_balance
        for pnl in df_closed["pnl"]:
            cumulative_balance += pnl
            balances.append(cumulative_balance)
        if len(balances) < 2:
            balances = [start_balance, start_balance]
    plt.figure(figsize=(6, 4))
    plt.plot(balances, marker='o')
    plt.title("Equity Curve")
    plt.xlabel("Trades")
    plt.ylabel("Balance")
    plt.grid(True)
    try:
        plt.savefig(output_file, format='png')
    except Exception as e:
        print(f"Fehler beim Speichern der Equity-Kurve: {e}")
    plt.close()



### FILE: ./utils/equity_protector.py
# utils/equity_protector.py

import pandas as pd
import os

# utils/equity_protector.py

class EquityProtector:
    def __init__(self, initial_balance: float, threshold_pct: float = 10.0):
        """
        Schützt das Kapital, indem bei Unterschreiten einer Drawdown-Schwelle 
        die Risikonahme reduziert wird.
        :param initial_balance: Startkapital
        :param threshold_pct: Drawdown-Schwelle in Prozent, ab der das Risiko reduziert wird
        """
        self.initial_balance = initial_balance
        self.threshold_pct = threshold_pct
        self.highest_balance = initial_balance
        self._reduce_risk = False

    def update_balance(self, current_balance: float):
        """Nach jedem Trade den aktuellen Kontostand übermitteln."""
        # Höchststand aktualisieren, wenn erreicht
        if current_balance > self.highest_balance:
            self.highest_balance = current_balance
            # Bei neuem Höchststand: Risikoreduktion zurücksetzen
            self._reduce_risk = False
        # Prüfen, ob Drawdown-Schwelle unterschritten ist
        if current_balance <= self.highest_balance * (1 - self.threshold_pct/100):
            self._reduce_risk = True

    def should_reduce_risk(self) -> bool:
        """Gibt True zurück, wenn das Risiko aktuell reduziert werden soll."""
        return self._reduce_risk



### FILE: ./utils/grid_manager.py
# utils/grid_manager.py

class GridManager:
    def __init__(self, levels=3, step_pct=0.5):
        self.levels = levels
        self.step_pct = step_pct  # Abstand zwischen Grid-Leveln in %

    def generate_grid_orders(self, base_price, side):
        orders = []
        for i in range(1, self.levels + 1):
            step = base_price * self.step_pct / 100 * i
            price = base_price - step if side == "BUY" else base_price + step
            orders.append(round(price, 2))
        return orders



### FILE: ./utils/logger.py
# utils/logger.py — Version 1.0.2

import logging
import os
import sys
from logging.handlers import RotatingFileHandler

LOG_DIR = "logs"
LOG_FILE = os.path.join(LOG_DIR, "bot.log")

def setup_logger(name="bot"):
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', "%Y-%m-%d %H:%M:%S")

    # File Handler
    file_handler = RotatingFileHandler(LOG_FILE, maxBytes=5*1024*1024, backupCount=2)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Console Handler (optional)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # Prevent duplicate logs
    logger.propagate = False

    return logger

# Global Logger
logger = setup_logger()

# Capture unhandled exceptions
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logger.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))

sys.excepthook = handle_exception



### FILE: ./utils/market_classifier.py
# utils/market_classifier.py

import numpy as np
from strategies.indicators import calculate_ema, calculate_atr

def classify_market(ohlcv):
    """
    Klassifiziert den Markt als 'trend', 'sideways' oder 'volatile' basierend auf EMA, ATR und Preisdynamik.
    """
    closes = [row[4] for row in ohlcv]
    highs = [row[2] for row in ohlcv]
    lows = [row[3] for row in ohlcv]

    # Trendbestimmung über EMA-Slope und Abstand
    ema50 = calculate_ema(ohlcv, 50)
    ema200 = calculate_ema(ohlcv, 200)
    price = closes[-1]
    slope = ema50 - ema50 if len(closes) < 52 else (ema50 - calculate_ema(ohlcv[-52:], 50))

    # ATR (Volatilität)
    atr = calculate_atr(ohlcv, 14)
    price_range = max(highs[-20:]) - min(lows[-20:])
    vola_ratio = atr / price if price != 0 else 0

    # Dynamische Schwellen (tune nach Wunsch!)
    strong_trend = abs(ema50 - ema200) / price > 0.01 and abs(slope) > 0.05 * price  # mind. 1% EMA-Diff, steile Steigung
    very_volatile = vola_ratio > 0.025 or price_range / price > 0.05  # 2.5% ATR oder 5% Range in 20 Kerzen

    if strong_trend:
        return "trend"
    elif very_volatile:
        return "volatile"
    else:
        return "sideways"



### FILE: ./utils/reentry_manager.py
# utils/reentry_manager.py

from datetime import datetime, timedelta

class ReEntryManager:
    def __init__(self, cooldown_minutes=60):
        self.last_losses = {}
        self.cooldown = timedelta(minutes=cooldown_minutes)

    def register_loss(self, symbol):
        self.last_losses[symbol] = datetime.utcnow()

    def can_reenter(self, symbol):
        if symbol not in self.last_losses:
            return True
        return (datetime.utcnow() - self.last_losses[symbol]) > self.cooldown



### FILE: ./utils/risk_manager.py
class RiskManager:
    def __init__(self, initial_balance, max_risk_per_trade=0.02, leverage=5):
        # Initialisiere Kontostand und Risikoparameter
        self.initial_balance = initial_balance
        self.balance = initial_balance  # aktueller Kontostand (wird nach Trades angepasst)
        self.max_risk_per_trade = max_risk_per_trade
        self.leverage = leverage

    def update_balance(self, new_balance):
        """Aktualisiert den aktuellen Kontostand (z.B. nach Trade-Abschluss)."""
        self.balance = new_balance

    def calculate_position_size(self, entry_price, stop_loss):
        """Berechnet die Positionsgröße basierend auf Kontostand, Risiko und Stop-Loss-Abstand."""
        sl_distance = abs(entry_price - stop_loss)
        risk_amount = self.balance * self.max_risk_per_trade  # Risikobetrag in Kontowährung
        if sl_distance <= 0:
            return 0
        qty = risk_amount / sl_distance
        # Prüfe Margin-Bedarf relativ zum Kontostand unter Berücksichtigung des Leverage
        required_margin = entry_price * qty / (self.leverage if self.leverage else 1)
        if required_margin > self.balance:
            # Reduziere Positionsgröße, falls Margin-Bedarf Kontostand übersteigt
            qty = (self.balance * self.leverage) / entry_price
        return qty


### FILE: ./utils/signal_filter.py
# utils/signal_filter.py

from strategies.indicators import calculate_ema, calculate_atr

class SignalFilter:
    def __init__(self, volume_factor=1.2, atr_threshold=0.001, trend_strength=0.001):
        self.volume_factor = volume_factor       # z. B. 1.2x über 10er-Avg
        self.atr_threshold = atr_threshold       # z. B. mind. 0.1 % Bewegung
        self.trend_strength = trend_strength     # z. B. Preisabstand zu EMA20 > 0.1 %

    def passes_filters(self, ohlcv) -> bool:
        closes = [c[4] for c in ohlcv]
        highs = [c[2] for c in ohlcv]
        lows = [c[3] for c in ohlcv]
        volumes = [c[5] for c in ohlcv]

        # Trend-Erkennung
        ema = calculate_ema(ohlcv, 20)
        price = closes[-1]
        trend_diff = abs(price - ema) / ema
        if trend_diff < self.trend_strength:
            return False  # Kein klarer Trend

        # Volumen-Filter
        avg_vol = sum(volumes[-11:-1]) / 10
        if volumes[-1] < avg_vol * self.volume_factor:
            return False  # Kein Volumenimpuls

        # ATR-basierte Volatilitätsprüfung
        atr = calculate_atr(ohlcv, 14)
        if atr / price < self.atr_threshold:
            return False  # Markt zu ruhig

        return True  # Alles passt



### FILE: ./utils/strategy_blocklist.py
import pandas as pd
# utils/strategy_blocklist.py

import os

BLOCKLIST_FILE = "strategy_blocklist.txt"

class StrategyBlocklist:
    def __init__(self):
        # Set der blockierten Strategien laden, falls bestehende Datei
        self.blocked_strategies = set()
        if os.path.isfile(BLOCKLIST_FILE):
            with open(BLOCKLIST_FILE, "r") as f:
                for line in f:
                    strat = line.strip()
                    if strat:
                        self.blocked_strategies.add(strat)

    def is_blocked(self, strategy_name: str) -> bool:
        """Prüft, ob die gegebene Strategie blockiert ist."""
        return strategy_name in self.blocked_strategies

    def block_strategy(self, strategy_name: str):
        """Blockiert die angegebene Strategie und speichert sie auf die Blocklist."""
        if strategy_name not in self.blocked_strategies:
            self.blocked_strategies.add(strategy_name)
            try:
                with open(BLOCKLIST_FILE, "a") as f:
                    f.write(f"{strategy_name}\n")
            except Exception as e:
                # Fehler beim Schreiben der Datei protokollieren
                print(f"Could not write to {BLOCKLIST_FILE}: {e}")



### FILE: ./utils/strategy_leaderboard.py
import os
import pandas as pd

class StrategyLeaderboard:
    def compute_leaderboard(self, min_trades=0, top_n=None):
        """
        Berechnet die Performance je Strategie und gibt die Top-N Strategien zurück.
        Rückgabewert: (enabled_strategies, stats_df)
         - enabled_strategies: Liste der Strategie-Namen mit Top-Performance (oder None)
         - stats_df: DataFrame mit Spalten ["strategy","trades","wins","losses","winrate","total_pnl","avg_pnl"]
        """
        if not os.path.isfile("paper_trades.csv"):
            # Keine Trades vorhanden
            stats_df = pd.DataFrame(columns=["strategy", "trades", "wins", "losses", "winrate", "total_pnl", "avg_pnl"])
            return (None, stats_df)
        df = pd.read_csv("paper_trades.csv")
        df_closed = df[df["pnl"].notna()]
        if df_closed.empty:
            stats_df = pd.DataFrame(columns=["strategy", "trades", "wins", "losses", "winrate", "total_pnl", "avg_pnl"])
            return (None, stats_df)
        stats_list = []
        grouped = df_closed.groupby("strategy")
        for strat_name, group in grouped:
            trades = len(group)
            wins = int((group["pnl"] > 0).sum())
            losses = int((group["pnl"] <= 0).sum())
            winrate = round((wins / trades * 100) if trades > 0 else 0.0, 2)
            total_pnl = round(group["pnl"].sum(), 2)
            avg_pnl = round((total_pnl / trades) if trades > 0 else 0.0, 2)
            stats_list.append({
                "strategy": strat_name,
                "trades": trades,
                "wins": wins,
                "losses": losses,
                "winrate": winrate,
                "total_pnl": total_pnl,
                "avg_pnl": avg_pnl
            })
        stats_df = pd.DataFrame(stats_list)
        # DataFrame nach Gesamt-PnL sortieren (beste Strategie zuerst)
        stats_df = stats_df.sort_values(by="total_pnl", ascending=False).reset_index(drop=True)
        enabled_strategies = None
        if top_n is not None:
            eligible = stats_df
            if min_trades:
                eligible = stats_df[stats_df["trades"] >= min_trades]
            if not eligible.empty:
                top_strats = eligible.sort_values(by="total_pnl", ascending=False).head(top_n)
                enabled_strategies = top_strats["strategy"].tolist()
        return (enabled_strategies, stats_df)



### FILE: ./utils/strategy_watchdog.py
# utils/strategy_watchdog.py

import csv
import os
from datetime import datetime
from collections import defaultdict

WATCHDOG_FILE = "strategy_watchdog.csv"

class StrategyWatchdog:
    def __init__(self):
        self.stats = defaultdict(lambda: {"trades": 0, "wins": 0, "losses": 0})
        self._load_existing()

    def _load_existing(self):
        if not os.path.isfile(WATCHDOG_FILE):
            return
        with open(WATCHDOG_FILE, mode="r") as f:
            reader = csv.DictReader(f)
            for row in reader:
                strat = row["strategy"]
                self.stats[strat] = {
                    "trades": int(row["trades"]),
                    "wins": int(row["wins"]),
                    "losses": int(row["losses"])
                }

    def record_trade(self, strategy_name: str, pnl: float):
        stat = self.stats[strategy_name]
        stat["trades"] += 1
        if pnl > 0:
            stat["wins"] += 1
        else:
            stat["losses"] += 1
        self._save()

    def _save(self):
        with open(WATCHDOG_FILE, mode="w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["strategy", "trades", "wins", "losses"])
            for strat, s in self.stats.items():
                writer.writerow([strat, s["trades"], s["wins"], s["losses"]])



### FILE: ./utils/trade_logger.py
import csv
import os
from datetime import datetime

def log_trade(symbol, side, entry_price, stop_loss, take_profit, qty, strategy, leverage, trades_csv="paper_trades.csv"):
    """
    Loggt einen neuen Trade-Einstieg in die CSV-Datei (paper_trades.csv).
    Enthält alle relevanten Felder, zunächst ohne Exit-Informationen.
    """
    file_exists = os.path.isfile(trades_csv)
    fieldnames = [
        "timestamp", "symbol", "side", "entry_price", "qty",
        "stop_loss", "take_profit", "current_sl",
        "exit_price", "exit_reason", "pnl",
        "leverage", "strategy"
    ]
    trade_data = {
        "timestamp": datetime.utcnow().isoformat(),
        "symbol": symbol,
        "side": side,
        "entry_price": round(float(entry_price), 4),
        "qty": round(float(qty), 4),
        "stop_loss": (round(float(stop_loss), 4) if stop_loss is not None else ""),
        "take_profit": (round(float(take_profit), 4) if take_profit is not None else ""),
        "current_sl": (round(float(stop_loss), 4) if stop_loss is not None else ""),
        "exit_price": "",
        "exit_reason": "",
        "pnl": "",
        "leverage": leverage,
        "strategy": strategy
    }
    with open(trades_csv, mode="a", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        if not file_exists:
            writer.writeheader()
        writer.writerow(trade_data)



### FILE: ./utils/trade_tracker.py
import os
import pandas as pd
from utils.strategy_watchdog import StrategyWatchdog

def update_trade_pnls(current_prices, atr_lookup=None, trades_csv="paper_trades.csv"):
    """
    Aktualisiert offene Trades in der CSV mit aktuellen Stop-Loss/Take-Profit-Verletzungen und berechnet PnL.
    Gibt eine Liste geschlossener Verlust-Trades zurück, um Grid-Recovery anzustoßen.
    """
    if not os.path.isfile(trades_csv):
        return []
    df = pd.read_csv(trades_csv)
    closed_loss_trades = []
    # Iteriere über alle Trades und überprüfe offene Positionen
    for idx, row in df.iterrows():
        if pd.isna(row["pnl"]) or row["pnl"] == "":
            symbol = row["symbol"]
            side = row["side"]
            price = current_prices.get(symbol)
            if price is None:
                continue
            # Aktuellen Stop-Loss (getrailt oder initial) und Take-Profit bestimmen
            stop_price = None
            tp_price = None
            if "current_sl" in df.columns:
                val = str(row.get("current_sl"))
                stop_price = float(val) if val not in ["", "nan", "None"] else None
            if stop_price is None:
                # Fallback auf initialen Stop-Loss
                val = str(row.get("stop_loss"))
                stop_price = float(val) if val not in ["", "nan", "None"] else None
            val_tp = str(row.get("take_profit"))
            tp_price = float(val_tp) if val_tp not in ["", "nan", "None"] else None
            exit_price = None
            exit_reason = None
            # Exit-Bedingungen überprüfen
            if side == "BUY":
                if stop_price is not None and price <= stop_price:
                    exit_price = stop_price
                    exit_reason = "stop_loss_hit"
                elif tp_price is not None and price >= tp_price:
                    exit_price = tp_price
                    exit_reason = "take_profit_hit"
            elif side == "SELL":
                if stop_price is not None and price >= stop_price:
                    exit_price = stop_price
                    exit_reason = "stop_loss_hit"
                elif tp_price is not None and price <= tp_price:
                    exit_price = tp_price
                    exit_reason = "take_profit_hit"
            # Wenn ein Exit ausgelöst wird, Trade schließen
            if exit_price is not None and exit_reason is not None:
                entry_price = float(row["entry_price"])
                qty = float(row["qty"])
                # PnL berechnen
                if side == "BUY":
                    pnl_value = (exit_price - entry_price) * qty
                else:  # SELL
                    pnl_value = (entry_price - exit_price) * qty
                df.at[idx, "exit_price"] = round(exit_price, 4)
                df.at[idx, "exit_reason"] = exit_reason
                df.at[idx, "pnl"] = round(pnl_value, 4)
                # Watchdog-Statistik aktualisieren
                try:
                    sw = StrategyWatchdog()
                    sw.record_trade(row["strategy"], float(pnl_value))
                except Exception as e:
                    print(f"Watchdog-Update Fehler: {e}")
                # Bei Verlust-Trade für Grid-Recovery vormerken
                if pnl_value < 0:
                    closed_loss_trades.append((
                        symbol,
                        side,
                        entry_price,
                        qty,
                        float(row["stop_loss"]) if str(row.get("stop_loss")) not in ["", "nan", "None"] else exit_price,
                        float(row["take_profit"]) if str(row.get("take_profit")) not in ["", "nan", "None"] else exit_price
                    ))
    # CSV mit aktualisierten Trades speichern
    df.to_csv(trades_csv, index=False)
    return closed_loss_trades



### FILE: ./utils/trailing_stop.py
import os
import pandas as pd

def update_trailing_stops(trades_csv="paper_trades.csv", current_prices=None, trail_pct=50):
    """
    Passt den Stop-Loss für offene Trades an (Trailing Stop).
    trail_pct bestimmt, wie viel Prozent des aktuell erzielten Profits abgesichert werden.
    """
    if current_prices is None or not os.path.isfile(trades_csv):
        return
    df = pd.read_csv(trades_csv)
    if "current_sl" not in df.columns:
        # Wenn kein Trailing-Stop-Feld vorhanden, keine Anpassung vornehmen
        return
    modified = False
    for idx, row in df.iterrows():
        # Nur offene Trades (ohne PnL) berücksichtigen
        if pd.isna(row["pnl"]) or row["pnl"] == "":
            symbol = row["symbol"]
            side = row["side"]
            entry_price = float(row["entry_price"])
            price = current_prices.get(symbol)
            if price is None:
                continue
            current_sl = None
            try:
                current_sl = float(row["current_sl"])
            except:
                current_sl = None
            # Trailing-Stop für Long-Positionen
            if side == "BUY" and current_sl is not None:
                if price > entry_price:
                    # Neuen SL so setzen, dass trail_pct% des Gewinns gesichert sind
                    desired_sl = entry_price + (price - entry_price) * (trail_pct / 100.0)
                    if desired_sl > current_sl:
                        df.at[idx, "current_sl"] = round(desired_sl, 4)
                        modified = True
            # Trailing-Stop für Short-Positionen
            elif side == "SELL" and current_sl is not None:
                if price < entry_price:
                    desired_sl = entry_price - (entry_price - price) * (trail_pct / 100.0)
                    if desired_sl < current_sl:
                        df.at[idx, "current_sl"] = round(desired_sl, 4)
                        modified = True
    if modified:
        df.to_csv(trades_csv, index=False)



